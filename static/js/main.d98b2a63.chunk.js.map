{"version":3,"sources":["priority_queue.js","logo.svg","App.js","reportWebVitals.js","MainSvg.js","dataHacker.js","CSVData.js","GapMinderNew.js","ManuallyTree.js","Example1.js","LocalCluster.js","util.js","BSpline.js","AdaptiveIsovalue.js","HierarchicalCluster.js","BMOAlgo.js","AlgorithmEntry.js","IndexUI.js","BubbleDemo.js","KelpDiagram.js","KelpFusion.js","CalOverLap.js","index.js"],"names":["PriorityQueue","d","this","_d","_elements","module","exports","prototype","checkEdgeCrossing","P1","P2","Q1","Q2","Math","min","x","max","y","isEmpty","size","peek","Error","modify_Prim","e1","e2","thisid","weightcross","szbefore","length","i","s","start","e","end","id","clusterid2","hasOwnProperty","cat","score","splice","tmp","enq","sz","parseInt","adjust","searchFather","f","m","j","_compare","modify_Kruskal_V2","fs","clusterid1","fe","push","modify_Kruskal","fa","deq","first","last","pop","current","largest","left","right","_swap","element","parent","floor","forEach","fn","a","b","aux","pid","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","colors","jsgraphs","require","POINT_EDGE_EPS","Component","clustering","calDistance","x1","y1","x2","y2","sqrt","pow","getVecNorm","vec","normalizeVec","norm","drawCircle","r","fill","stroke","d3","append","attr","drawRect","width","height","color","drawLine","on","PointToSegDist","cross","d2","px","py","calTanPoint","cx","cy","radius","point","vc1c2","radC1C2","acos","theta","p1","cos","sin","p2","PI","calCommonTanPoint","r1","r2","tanPoints","delta1","delta2","vecpq","dir","newpointp","newpointq","dir2","newpointp2","newpointq2","intersecx","intersecy","tanpoints1","tanpoints2","p3","delta","abs","drawArc","startp","endp","center","pathstr","largearcflag","vec1","vec2","crossmul","getDegreeTwoVec","norm1","norm2","rotatePoint","rx0","ry0","alpha","crossMul","BSpline","points","degree","copy","dimension","baseFunc","basisDeg2","baseFuncRangeInt","basisDeg3","basisDeg4","basisDeg5","seqAt","dim","margin","n","getInterpol","seq","t","rangeInt","tInt","result","calcAt","res","g","offsetX","offsetY","viewWidth","viewHeight","MarchingSquaresJS","IsoInsideTest","AreaCal","IntersectionQuery","ShapeInfo","Intersection","Point2D","buffer","nodeR1","nodeR0","edgeR1","edgeR0","intervals","pixelGroup","gapBetween","fixdis","control_points","initialControlPoints","is_selected","eps","nearpts","hasChangeView","prepoints","svgwidth","svgheight","minItemArea","Number","MAX_VALUE","editSeg","lineFunction","curve","lineFunction_reDraw","clone","obj","Date","setTime","getTime","Array","Object","AdaptiveIsovalue","onChangeEdgeWidth","value","setState","edgeWidth","changeEdgeWidth","selectedEdge","onChangeNodeR0","onChangeNodeR1","onChangeEdgeR0","onChangeEdgeR1","onChangePixelGroup","onChangeGap","state","hasSelectEdge","isfirstcreate","pointData","canvasWidth","canvasHeight","maxX","maxY","minX","minY","maxDis","MIN_VALUE","catPointDict","catEdgeDict","edges","maxDistance","itemShape","itemBBox","catEnergyField","catNotGroup","activeRegion","energyField","field","editMode","editIndex","updatedEnergyPoints","edgeControlPoints","hasMST","updateIdx","hasBubbles","firstFlag","X","Y","Width","Height","props","onRef","document","getElementById","getBoundingClientRect","oncontextmenu","pdict","flag","c","catArray","nowcat","edict","filledges","catarr","startpoint","editPoints","editEdges","HpointData","Hedges","console","time","shape","parseFloat","toString","cats","split","catarray","multicat","centralizeData","calEdgeLength","calActiveRegion","updatePoints","updateEdges","preProcessPoints","preProcessEdges","calEnergyField_Part","timeEnd","calFinalEnergeField_Part","fillCrossingEdge_Part","remove","findOutLine","calOutLine","calEdgeControlPoints","that","log","selectAll","filter","init","createMST","loadEdgeData","handleCreated","ViewFlag","minx","miny","maxx","maxy","virtrual","vpoints","virtrualNodes","p","colorArray","call","extent","scaleExtent","transform","event","items","index","getElementsByTagName","getAttribute","getBBox","bbox","sortArr","avgdis","tempcontrolpoints","k","controlpoints","minDis","minindex","edge","dis","order","iscontinue","temppoints","lastindex","sort","dw","firstOutline","secondOutline","dot","dx","dy","drawPathData","reDraw","stopPropagation","handleClick","vstart","vend","v","thisindex","minlength","maxlength","endpoint","vpoint","nowp","nextp","edgelength","maxEdgeLength","minEdgeLength","nextProps","nextState","nextContext","fieldData","startY","boundingY","startX","boundingX","endY","boundingHeight","endX","boundingWidth","finalField","isoDict","calISOLine","polygontest","tmp_polygon","prelength","polygon","selectidx","curlen","meandis","sidx","isthis","st_idx","pt_len","j_pt","idx1","idx2","ve1","ve2","ve3","ve3_len","test_pt","is_use_inner","j_y","j_x","path_Info","curdata","drawISOLinesV2","JSON","stringify","calEnergyField","calFinalEnergeField","fillCrossingEdge","createGapInBoundary","drawEdges","drawPointData","ceil","centerX","centerY","barrierMap","item","lx1","ly1","lx2","ly2","projlenSq","dotprod","lenSq","distancetoendnode","distancetoedge","mindis","distancetostartnode","totaldistance","getPointEdgeDistance","enddis","sp","se","selength","distancetonode","rect1","rect2","maxpdis","k1","isGroup","isgroup","k2","calDistanceToEdge","pointMap","pointBarrierMap","edgeBarrierMap","pointIndexMap","edgeIndexMap","edgeIndexMap2","subUpdate","members","startx","endx","starty","endy","realx","realy","distance","calDistanceToItem","energy","EDGELENGTH_THRESH","startid","endid","calDistanceToEdgeV2","distancetoEdge","distancetoNode","totalDistance","newR1","delflag","it","relativex","relativey","hasSameCat","samecat","c1","cat1","c2","cat2","area_abc","area_abd","area_cda","gap","deletePoints","isboundary","isolines","isolinepoints","isoLineMap","relativepoints","isoInsidePoints","pointInPolygon","notDeleteIndex","nodePoints","totalInside","isolineIndex","deleteindex","isdelete","newisolines","catarr1","catarr2","gfield","finalvalue","isInside","thisPointID","gpointIndexMap","thisEdgeID","gedgeIndexMap","thiscat","gbarrierMap","gwidth","gheight","othervalue","otherinside","otherPointID","otherEdgeID","othercat","isContained","gpointBarrierMap","Set","updateidx","preK","bounding","smoothEnergyField","idx","val","lines","val1","val2","tmpx","uy","ux","target","map","style","dat","Polygon","max_y","min_y","max_x","min_x","NET","ymax","AET","curi","CurSize","fx","fy","relativeotherx","relativeothery","P_1","P_2","p_x1","shift","p_x2","x_begin","x_end","cut","len","bx1","by1","bx2","by2","dragstarted","execflag","_groups","attributes","tmp_idx","isnum","iidx","jidx","v1","v2","dragged","sourceEvent","ex","ey","reDrawData","cur_len","tmp_pts","q","tmpDict","sid","cur_idx","s_pts","tmpPath","node","totLen","getTotalLength","r1_idx","dis1","r2_idx","dis2","tmp_p","getPointAtLength","tmpdis1","tmpdis2","dragended","v3","fillPolygon","button","pointpath","data","isoLines","polygons","linearRing","noFrame","isoLineDict","tpoints","splinePoints","spline","kernel","sum","kernelsize","anchor","C","ny","nx","exp","normalizeKernel","isSingular","edgeCrossingList","start1","end1","linesToCheck1","vlength","start2","end2","linesToCheck2","l1","l2","crossInfo","newFieldDict","crossingPoints","fillArea","crosspoint","otherid","line","crossline","dl","lineLength","vec3","linedirvec","normdirvec","step","topBoundPoints","bottomBoundPoints","lastTop","lastBottom","rightstop","topstop","bottomstop","newanchor1","disalongline","topfind","bottomfind","newpointtop","newxtop","newytop","otherx","othery","newpointbottom","newxbottom","newybottom","fillPolyPoints","leftstop","newanchor2","fillPolygonForEdge","getGaussianKernel","sx","sy","cur_width","cur_height","newField","newvalue","formatpoints","isInterior","parentID","updateEnergyPoints","span","onChange","disabled","onClick","getData","bind","hasLoadData","removeOverlaps","defaultProps","preEdgeDict","curEdgeDict","FileSaver","weightMess","maxCross","DISTANCE_THRESHHOLD","priority_queue","svgid","opsvgid","preEdges","tmpEditEdges","editView","BeforeWidth","BeforeHeight","ScreenWidth","ScreenHeight","HierarchicalCluster","ref","child","read","hasinit","hasEdit","hascreated","issplit","graph","clustergraph","isSelect","selectItem","clusterDict","clustergraphInfo","clusterArr","noiseDict","intersecEdges","vis","heap1","heap2","QTree","edgesdict","draggedIndex","draggedEdgeIndex","draggedEdgeSeg","nodeStartDict","nodeEndDict","lastClickIndex","lastClickItem","deletedEdge","addedEdge","tempEdges","window","screen","availHeight","availWidth","dissum","disnum","tmpp1","calEPS","optimizeMST","applyEdit","beginTime","generateTreeWithHierarchical","endTime","countEdgeCrossingWithRouting","hasCreate","Graph","V","label","disArray","messArray","tempedges","mess","calEdgeMess","weight","calEdgeWeight","node1","node2","crossnum","edgecat","sortedEdges","removeEdggeList","sortEdgesGlobal","DepthFirstSearch","hasPathTo","checkNewEdge","addEdge","checkConnect","tempEdgeList","scores","calEdgeWeightWithCrossing","minCost","maxindex","sortEdgesGlobalWithMinDis","edgesnum","nodesnum","dfs","id1","id2","removelist","num","isPointInEdgeRange","calPointEdgeDistance","calVecCosine","vec4","seg1","SVGElement","select","empty","insert","drawOneEdge","each","savedData","fetch","method","headers","mode","cache","json","removeindex","countEdgeCrossing","isedit","newGraph","cc","ConnectedComponents","componentCount","newClusterDict","componentId","idnum","getElementsByClassName","newEdges","recalculateSpanningTreeAfterEdit","drawOneEdgeAfterEdit","tmpe","recalculateSpanningTree","new","ei","thisedge","pcat","linesToCheck","ids","swap","checkline","intersecInfo","findCrossingBetweenEdgeRect","rec","rect","line1","line3","line2","line4","point1","point2","vnode","cornerpointindex","cornerpoint","iternum","vnode1","vnode2","centerpoint","movevec","movenorm","checkVNodeInBound","minCross","bestVnode","potentialNode","pnode","count","node3","temppoint","samepoiint","newid","index1","index2","newedge","isLocalTree","surfaceRoutingEdge","oneEdge","dragControlPoint","edgeindex","segindex","bubbleState","editReDraw","dragEdge","handleMouseDown","newline","edgeIndex","segIndex","thisedgeindex","thissegindex","deleteEdge","findCircle","catEdges","nodeDegree","finish","circleEdges","has","lastcat","checkCircle","isAdded","worstindex","worstscore","worstEdge","drag","nodeindex","st","en","rerouting","w","h","deleteEdges","reroutingEdges","pointedgedis","preEdge","tmpp","vnodes1","flag1","st1_p","en1_p","st2_p","en2_p","vnodes2","path","clickIndex","hasLinked","lines1","vnodes","lines2","p4","midx","midy","midnode","initWithNoCluster","preAddedClusters","catclusters","startclusterid","endclusterid","merged","newclusterdict","createGraphWithCluster","createLocalTree","hierarchicalMergeV2","dbscan","DBSCAN","dataset","pointDataSet","clusters","run","clusterPoints","noise","g2","cluster1","cluster2","calClusterDistance","minstart","minend","minScore","bestStart","bestEnd","minScoreWithDis","links","minIndex","minScoreWithDistance","minIndexWithDistance","hasBest","checkConnectBetweenTwoCluster","rectangle","top","intersections","intersect","status","pointInRectangle","weightCross","isDeleted","checkConnectBetweenTwoClusterV2","totcluster","optimalLinks1","optimalLinks2","addLinks","checkConnectBetweenAllCluster","bestLink","unionFather","checkConnectBetweenAllClusterV2","optimalLinks","link","findOptimalLink","findMinScore","sortEdgesGlobalWithCluster","findLinkBetweenCluster","checkConnectBetweenCluster","clusterstart","clusterend","infostr","handleManually","afterEditReDraw","content","blob","Blob","type","saveAs","marginTop","checkedChildren","unCheckedChildren","editBackbone","AlgorithmEntry","alert","finishInput","svg","svgsaver","Header","Select","Option","Layout","Footer","Sider","Content","columns","title","dataIndex","render","text","key","tags","tag","keynum","GroupDict","cur_set","is_input","IndexUI","updateview","GroupData","name","dataFile","scaleX","scaleY","selValue","hasCreateMST","menu","Item","rel","savePNG","saveSVG","saveData","box","handleMousedown","undefined","Scale","tmpg","handleDeleteNode","addNewPoints","set","tmp_index","findIndex","GroupCat","curcat","tmpcat","tmpGroupData","scale_ratio_x","scale_ratio_y","transform_dx","transform_dy","ratio","filename","drawInit","saveSvgAsPng","viewbox","svgstr","html","options","p5","pad1","pad2","background","textAlign","fontFamily","fontWeight","fontSize","theme","padding","className","float","border","showSearch","placeholder","changeSel","handleUpload","overlay","arrow","DownOutlined","pagination","position","scroll","dataSource","BubbleDemo","d3Voronoi","re","tanPointsNum","deltaDeg","triangulate","EdgeWidth","neighbors","pathDataToPolys","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.d98b2a63.chunk.js","sourcesContent":["//修改自：https://github.com/janogonzalez/priorityqueuejs\n\nmodule.exports = PriorityQueue;\n\nfunction PriorityQueue(d) {\n    this._d = d;\n    this._elements = [];\n}\n\nPriorityQueue.prototype.checkEdgeCrossing = function(P1,P2,Q1,Q2){\n    if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\n        Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\n        Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\n        Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\n        if(\n            ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\n            ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\n        ){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    else{\n        return false\n    }\n}\n\nPriorityQueue.prototype.isEmpty = function() {\n    return this.size() === 0;\n};\n\nPriorityQueue.prototype.peek = function() {\n    if (this.isEmpty()) throw new Error('PriorityQueue is empty');\n    return this._elements[0];\n};\n\nPriorityQueue.prototype.modify_Prim = function(e1,e2,thisid,weightcross){\n    //let a = this._elements.length\n    //console.log(\"modify before: \" + a)\n    let szbefore = this._elements.length;\n    for(let i = this._elements.length - 1;i >= 0;i --){\n        let s = this._d[this._elements[i]].start;\n        let e = this._d[this._elements[i]].end;\n        let id = this._d[this._elements[i]].clusterid2;\n        if((!this._d.hasOwnProperty(this._elements[i])) || id == thisid){\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n            this._d[this._elements[i]].score += weightcross\n        }\n    }\n    let tmp = this._elements;\n    this._elements = [];\n    for(let i = 0;i< tmp.length;i++){\n        this.enq(tmp[i]);\n    }\n\n    let sz = this._elements.length;\n    if(sz <= 1 || sz == szbefore){\n        return;\n    }\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n        this.adjust(i,sz - 1);\n    }\n\n}\n\nPriorityQueue.prototype.searchFather = function (f,x){\n    while(x!=f[x]){\n        f[x] = f[f[x]];\n        x = f[x];\n    }\n    return x;\n}\n\nPriorityQueue.prototype.adjust = function(start, m){\n    let i = start;\n    let j = 2 * i + 1;\n    let tmp = this._elements[i];\n    while(j <= m){\n        if(j < m && this._compare(j, j + 1)){\n            j ++;\n        }\n        if(this._d[tmp].score <= this._d[this._elements[j]].score){\n            break;\n        }\n        else{\n            this._elements[i] = this._elements[j];\n            //V1\n            //this._d[this._elements[i]].pid = i;\n            i = j;\n            j = 2 * j + 1;\n        }\n    }\n    this._elements[i] = tmp;\n    //V1\n    //this._d[this._elements[i]].pid = i;\n}\n//function(e1,e2,f,weightcross,fa)\n\nPriorityQueue.prototype.modify_Kruskal_V2 = function(e1,e2,f,weightcross){\n\n    //let szbefore = this._elements.length;\n    let tmp = []\n    for(let i = this._elements.length - 1;i >= 0;i --){\n        let s = this._d[this._elements[i]].start;\n        let e = this._d[this._elements[i]].end;\n        let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\n        let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\n        if((!this._d.hasOwnProperty(this._elements[i]))){\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(fs == fe){\n            delete this._d[this._elements[i]];\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n            this._d[this._elements[i]].score += weightcross\n        }\n        tmp.push(this._elements[i])\n    }\n\n    let sz = tmp.length;\n\n    if(sz <= 1){\n        return;\n    }\n\n    this._elements=[]\n\n    for(let i = 0;i < sz;i ++){\n        this.enq(tmp[i]);\n    }\n\n    //for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n    //    this.adjust(i,sz - 1);\n    //}\n\n}\n\nPriorityQueue.prototype.modify_Kruskal = function(e1,e2,f,weightcross,fa){\n    //let a = this._elements.length\n    //console.log(\"modify before: \" + a)\n    //let szbefore = this._elements.length;\n    //for(let i = this._elements.length - 1;i >= 0;i --){\n    //    let s = this._d[this._elements[i]].start;\n    //    let e = this._d[this._elements[i]].end;\n    //    let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\n    //    let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\n    //    if((!this._d.hasOwnProperty(this._elements[i]))){\n    //        this._elements.splice(i,1);\n    //        continue;\n    //    }\n    //    if(fs == fa && fe == fa){\n    //        delete this._d[this._elements[i]];\n    //        this._elements.splice(i,1);\n    //        continue;\n    //    }\n    //    if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n    //        this._d[this._elements[i]].score += weightcross\n    //    }\n    //}\n\n    let sz = this._elements.length;\n\n    //if(sz <= 1 || sz == szbefore){\n    //    return;\n    //}\n\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n        this.adjust(i,sz - 1);\n    }\n\n    //for(let i = 0;i < sz;i ++){\n    //    this._d[this._elements[i]].pid = i;\n    //}\n\n}\n\nPriorityQueue.prototype.deq = function() {\n    //let a = this._elements.length\n    //console.log(\"deq before: \" + a)\n    //delete this._d[this._elements[0]];\n    var first = this.peek();\n    //V1\n    //this._d[first].pid = -1;\n    var last = this._elements.pop();\n    var size = this.size();\n    if (size === 0) return first;\n\n    this._elements[0] = last;\n    var current = 0;\n\n    while (current < size) {\n        var largest = current;\n        var left = (2 * current) + 1;\n        var right = (2 * current) + 2;\n\n        if (left < size && this._compare(left, largest) >= 0) {\n            largest = left;\n        }\n\n        if (right < size && this._compare(right, largest) >= 0) {\n            largest = right;\n        }\n\n        if (largest === current) break;\n\n        this._swap(largest, current);\n        current = largest;\n    }\n    //let b = this._elements.length\n    //console.log(\"deq after: \" + b)\n    return first;\n};\n\nPriorityQueue.prototype.enq = function(element) {\n    //let a = this._elements.length\n    //console.log(\"enq before: \" + a)\n    var size = this._elements.push(element);\n    var current = size - 1;\n\n    while (current > 0) {\n        var parent = Math.floor((current - 1) / 2);\n        if (this._compare(current, parent) <= 0) break;\n        this._swap(parent, current);\n        current = parent;\n    }\n   //let b = this._elements.length\n   //console.log(\"enq after: \" + b)\n    return size;\n};\n\nPriorityQueue.prototype.size = function() {\n    return this._elements.length;\n};\n\nPriorityQueue.prototype.forEach = function(fn) {\n    return this._elements.forEach(fn);\n};\n\nPriorityQueue.prototype._compare = function(a, b) {\n    return this._d[this._elements[b]].score - this._d[this._elements[a]].score;\n};\n\nPriorityQueue.prototype._swap = function(a, b) {\n    var aux = this._elements[a];\n    this._d[this._elements[a]].pid = b;\n    this._d[this._elements[b]].pid = a;\n    this._elements[a] = this._elements[b];\n    this._elements[b] = aux;\n};","export default __webpack_public_path__ + \"static/media/logo.2d27ead7.svg\";","import logo from './logo.svg';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.js</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#434343','#8701ec','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\n\r\n\r\nclass MainSvg extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.maxDistance=-1\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        let centerx=minx+(maxx-minx)/2\r\n        let centery=miny+(maxy-miny)/2\r\n        let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x+=move[0]\r\n            this.pointData[i].y+=move[1]\r\n        }\r\n        this.maxX=maxx+move[0]\r\n        this.minX=minx+move[0]\r\n        this.maxY=maxy+move[1]\r\n        this.minY=miny+move[1]\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x-=this.minX-20\r\n            this.pointData[i].y-=this.minY-20\r\n        }\r\n    }\r\n\r\n    calEPS(){\r\n        POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample3.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n               this.centralizeData()\r\n                this.calEPS()\r\n                this.createGraph()\r\n                this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                this.drawEdges()\r\n                this.drawPointData()\r\n                this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n        Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n        Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n        Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n            for (let i=0;i<sortedEdges.length;i++){\r\n                let start=sortedEdges[i][0]\r\n                let end=sortedEdges[i][1]\r\n                let weight=sortedEdges[i][2]\r\n                let dis=sortedEdges[i][3]\r\n                let mess=sortedEdges[i][4]\r\n\r\n                if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                    continue\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n                if(!dfs.hasPathTo(end)){\r\n                    if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                        this.graph.addEdge(start,end)\r\n                        // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                        this.edges.push({\r\n                            start:start,\r\n                            end:end,\r\n                            weight:weight,\r\n                            dis:dis,\r\n                            mess:mess\r\n                        })\r\n                        // this.graph.node(start).label=true\r\n                        // this.graph.node(end).label=true\r\n                    }\r\n                    else{\r\n                        removeEdggeList.push({\r\n                            start:start,\r\n                            end:end,\r\n                            weight:weight,\r\n                            dis:dis,\r\n                            crossnum:-1,\r\n                            mess:mess\r\n                        })\r\n                    }\r\n                    // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                    // console.log(this.graph.adj(start))\r\n                    // this.drawLine(this.pointData)\r\n                }\r\n            }\r\n\r\n        while(!this.checkConnect()){\r\n                let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n            // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n/*        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index=i\r\n            d3.select(\"svg\")\r\n                .append(\"circle\")\r\n                .attr(\"cx\",this.pointData[i].x)\r\n                .attr(\"cy\",this.pointData[i].y)\r\n                .attr(\"r\",this.pointData[i].radius)\r\n                .attr(\"fill\",colors[this.pointData[i].cat])\r\n                .attr(\"catefory\",this.pointData[i].cat)\r\n                .attr(\"index\",index)\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.pointData[index])\r\n                })\r\n                .on(\"drag\",function(){\r\n                    console.log(\"drag!\")\r\n                })\r\n                .call(drag)\r\n        }\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        let maxOneCross=Number.MIN_VALUE\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            let oneCrossNum=0\r\n\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                        oneCrossNum+=1\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(oneCrossNum>maxOneCross){\r\n                maxOneCross=oneCrossNum\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n        console.log(\"max crossing num of one edge: \"+maxOneCross)\r\n\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.savePointData.bind(this)}> Save </button>\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default MainSvg","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\n\r\n\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass DataHacker extends Component{\r\n    constructor() {\r\n        super();\r\n        this.globalCategory=0\r\n        this.points=[]\r\n        this.numOfPoints=0\r\n        this.nowCategory=0\r\n        this.jsonoutput=null\r\n        this.input=null\r\n        this.width=60\r\n        this.height=70\r\n    }\r\n\r\n    componentDidMount() {\r\n        d3.select(\"svg\")\r\n            .on(\"click\",this.leftClick.bind(this))\r\n/*        for (let i=0;i<11;i++){\r\n            d3.select(\"svg\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",(i+1)*1000/11)\r\n                .attr(\"y1\",0)\r\n                .attr(\"x2\",(i+1)*1000/11)\r\n                .attr(\"y2\",1000)\r\n                .attr(\"stroke\", \"black\")\r\n                .attr(\"stroke-width\", \"2px\");\r\n\r\n        }*/\r\n\r\n    }\r\n\r\n\r\n    drawPoint(x,y,color,cat,index){\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",7)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .on(\"click\",this.deletePoint.bind(this))\r\n    }\r\n\r\n    drawRect(x,y,w,h,color,cat,index){\r\n        d3.select(\"svg\")\r\n            .append(\"rect\")\r\n            .attr(\"x\",x-w/2)\r\n            .attr(\"y\",y-h/2)\r\n            .attr(\"width\",w)\r\n            .attr(\"height\",h)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .on(\"click\",this.deletePoint.bind(this))\r\n        d3.select(\"svg\")\r\n            .append(\"text\")\r\n            .attr(\"x\",x-w/2)\r\n            .attr(\"y\",y-h/2)\r\n            .attr(\"index\",index)\r\n            .style(\"font-size\",12)\r\n            .text(index)\r\n    }\r\n\r\n    deletePoint(e){\r\n        e.stopPropagation()\r\n        let el=e.target\r\n        let index=d3.select(el).attr(\"index\")\r\n        this.points[index]=-1\r\n        d3.select(el).remove()\r\n        console.log(index)\r\n        d3.selectAll(\"text\")\r\n            .filter(function(d,i){\r\n                return d3.select(this).attr(\"index\")==index\r\n            })\r\n            .remove()\r\n        // console.log(this.points)\r\n    }\r\n\r\n    leftClick(e){\r\n        // console.log(e)\r\n        let x=e.offsetX\r\n        let y=e.offsetY\r\n        // this.drawRect(x,y,this.width,this.height,colors[this.nowCategory],this.nowCategory,this.numOfPoints)\r\n        this.drawPoint(x,y,colors[this.nowCategory],this.nowCategory,this.numOfPoints)\r\n        this.points.push({\r\n            x:x,\r\n            y:y,\r\n            cat:this.nowCategory,\r\n            id:this.numOfPoints,\r\n            radius:7\r\n            // width:this.width,\r\n            // height:this.height\r\n        })\r\n        this.numOfPoints+=1\r\n        // console.log(this.points)\r\n    }\r\n\r\n    savePoints(){\r\n        let tempPoints=[]\r\n        let num=0\r\n        for (let i=0;i<this.points.length;i++){\r\n            if(this.points[i]!=-1){\r\n                this.points[i].id=num\r\n                num+=1\r\n                tempPoints.push(this.points[i])\r\n            }\r\n        }\r\n        this.points=tempPoints\r\n        d3.select(\"svg\").selectAll(\"circle\").remove()\r\n        d3.select(\"svg\").selectAll(\"text\").remove()\r\n\r\n        for (let i=0;i<this.points.length;i++){\r\n            // this.drawRect(this.points[i].x,this.points[i].y,this.points[i].width,this.points[i].height,colors[this.points[i].cat],this.points[i].cat,i)\r\n            this.drawPoint(this.points[i].x,this.points[i].y,colors[this.points[i].cat],this.points[i].cat,i)\r\n\r\n        }\r\n        this.numOfPoints=this.points.length\r\n\r\n        for (let i=0;i<this.points.length;i++){\r\n            this.points[i].cat=this.points[i].cat.toString()\r\n            this.points[i].shape=\"circle\"\r\n\r\n        }\r\n\r\n        // console.log(this.points)\r\n        let res=JSON.stringify(this.points)\r\n        this.jsonoutput.innerHTML=res\r\n        console.log(res)\r\n    }\r\n\r\n    addCategory(){\r\n        this.globalCategory+=1\r\n        this.nowCategory=this.globalCategory\r\n        console.log(this.globalCategory)\r\n    }\r\n\r\n    loadPoints(){\r\n        fetch('/data/savedDate.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.points=data\r\n                this.numOfPoints=this.points.length-1\r\n                let categories=[]\r\n\r\n                for (let i=0;i<this.points.length;i++){\r\n                    this.drawPoint(this.points[i].x,this.points[i].y,colors[this.points[i].cat],this.points[i].cat,i)\r\n                    if(categories.indexOf(this.points[i].cat)<0){\r\n                        categories.push(this.points[i].cat)\r\n                    }\r\n                }\r\n                this.globalCategory=categories.length-1\r\n                 this.nowCategory=this.globalCategory\r\n                console.log(this.points)\r\n            })\r\n    }\r\n\r\n    switchCategory(){\r\n        let cat=parseInt(this.input.value)\r\n        this.nowCategory=cat\r\n        // this.input.value=\"\"\r\n        console.log(cat)\r\n    }\r\n    changeWidthHeight(){\r\n        let wh=this.input2.value.split(\",\")\r\n        console.log(this.input.value)\r\n        let w=parseFloat(wh[0])\r\n        let h=parseFloat(wh[1])\r\n        this.width=w\r\n        this.height=h\r\n        // this.input.value=\"\"\r\n        console.log(w,h)\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <svg id={\"hacksvg\"} width={\"1000px\"} height={\"1000px\"} >\r\n                </svg>\r\n                <button onClick={this.addCategory.bind(this)}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"800px\"}}>Add Category</button>\r\n                <input ref={(input)=>this.input=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"750px\"}}></input>\r\n                <button onClick={this.switchCategory.bind(this)}  style={{width:200,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"750px\",marginLeft:10}}>Change Category</button>\r\n                <button onClick={this.savePoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"700px\",marginLeft:10}}>Save</button>\r\n                <button onClick={this.loadPoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"700px\",marginLeft:10}}>Load</button>\r\n                <input ref={(input)=>this.input2=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"650px\"}}></input>\r\n                <button onClick={this.changeWidthHeight.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"650px\",marginLeft:10}}>Change Width and Height</button>\r\n                <label ref={(jsonoutput)=>this.jsonoutput=jsonoutput} style={{width:300,height:200,fontSize:\"10px\",position:\"absolute\",left:\"1550px\",bottom:\"300px\",marginLeft:10,overflow:\"scroll\"}}>\r\n\r\n                </label>\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default DataHacker","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass CSVData extends Component{\r\n    constructor() {\r\n        super();\r\n        this.population=null\r\n        this.lifeExp=null\r\n        this.fertility=null\r\n        this.geoInfo=null\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.getPopulation()\r\n    }\r\n\r\n    getPopulation(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/population_total.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.population=data\r\n                console.log(\"population\")\r\n                console.log(that.population)\r\n                that.getLifeExpectancy()\r\n            })\r\n    }\r\n\r\n    getLifeExpectancy(){\r\n        let that=this\r\n        d3.csv(\"data/GapMinder/life_expectancy_years.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.lifeExp=data\r\n                console.log(\"lifeexp\")\r\n                console.log(that.lifeExp)\r\n                that.getFertility()\r\n            })\r\n    }\r\n\r\n    getFertility(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/children_per_woman_total_fertility.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.fertility=data\r\n                console.log(\"fertility\")\r\n                console.log(that.fertility)\r\n                that.getGroInfo()\r\n            })\r\n    }\r\n\r\n    getGroInfo(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/ddf--entities--geo--country.csv\",function(data){\r\n            return {\r\n                country:data.name,\r\n                value:data.worldregion\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.geoInfo=data\r\n                console.log(that.geoInfo)\r\n                that.dataFusion()\r\n            })\r\n    }\r\n\r\n    dataFusion(){\r\n        let datapoint=[]\r\n        let countrylist={}\r\n        let catnum=0\r\n        let catDict={}\r\n\r\n        for (let i=0;i<this.fertility.length;i++){\r\n            if(this.fertility[i].value==\"\"){\r\n                continue\r\n            }\r\n            let country=this.fertility[i].country\r\n            let hascat=false\r\n\r\n            for (let j=0;j<this.geoInfo.length;j++){\r\n                if(!catDict.hasOwnProperty(this.geoInfo[j].value)){\r\n                    catDict[this.geoInfo[j].value]=catnum\r\n                    catnum+=1\r\n                }\r\n                if(country==this.geoInfo[j].country){\r\n                    // datapoint[i].geo=this.geoInfo[j].value\r\n                    // datapoint[i].cat=catDict[this.geoInfo[j].value]\r\n                    hascat=true\r\n                    break\r\n                }\r\n            }\r\n            if(!hascat){\r\n                console.log(this.fertility[i].country)\r\n                continue\r\n            }\r\n            else{\r\n                datapoint.push({\r\n                    country:this.fertility[i].country,\r\n                    fertility:parseFloat(this.fertility[i].value)\r\n                })\r\n            }\r\n\r\n        }\r\n\r\n        for (let i=0;i<datapoint.length;i++){\r\n            let country=datapoint[i].country\r\n\r\n            for (let j=0;j<this.population.length;j++){\r\n                if(country==this.population[j].country){\r\n                    datapoint[i].population=parseInt(this.population[j].value)\r\n                    break\r\n                }\r\n            }\r\n            for (let j=0;j<this.lifeExp.length;j++){\r\n                if(country==this.lifeExp[j].country){\r\n                    datapoint[i].lifeExp=parseFloat(this.lifeExp[j].value)\r\n                    break\r\n                }\r\n            }\r\n            for (let j=0;j<this.geoInfo.length;j++){\r\n                if(country==this.geoInfo[j].country){\r\n                    datapoint[i].geo=this.geoInfo[j].value\r\n                    datapoint[i].cat=catDict[this.geoInfo[j].value]\r\n                    break\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n\r\n\r\n        this.data=datapoint\r\n        // console.log(JSON.stringify(datapoint))\r\n        console.log(datapoint)\r\n        this.drawScatterPlot()\r\n\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",5)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"circle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n\r\n        let xscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.fertility)})),d3.max(this.data.map((d)=>{return d.fertility}))])\r\n            .range([0,800])\r\n        let yscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.lifeExp)})),d3.max(this.data.map((d)=>{return d.lifeExp}))])\r\n            .range([1000,0])\r\n        let rscale=d3.scaleSqrt().domain([d3.min(this.data.map((d)=>{return d.population})),d3.max(this.data.map((d)=>{return d.population}))])\r\n            .range([3,20])\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(xscale(this.data[i].fertility),yscale(this.data[i].lifeExp),rscale(this.data[i].population),colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    getCSV(){\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    render(){\r\n        return (<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default CSVData","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass GapMinderNew extends  Component{\r\n    constructor() {\r\n        super();\r\n        this.population=[]\r\n        this.fertility=[]\r\n        this.lifeExp=[]\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        let that=this\r\n        d3.csv(\"data/GapMinder-new/population.csv\",function(data){\r\n            // console.log(data)\r\n                // console.log(data[i])\r\n                let country=data.Country\r\n                that.data.push({\r\n                    country:country,\r\n                    population:parseInt(data.Pop1985),\r\n                    fertility:parseFloat(data.F1985),\r\n                    lifeExp:parseFloat(data.L1985),\r\n                    geo:data.Group\r\n                })\r\n        }).then(function(data){\r\n            let catDict={}\r\n            let catnum=0\r\n            for (let i=0;i<that.data.length;i++){\r\n                if(!catDict.hasOwnProperty(that.data[i].geo)){\r\n                    catDict[that.data[i].geo]=catnum\r\n                    catnum++\r\n                }\r\n            }\r\n            for (let i=0;i<that.data.length;i++){\r\n                that.data[i].cat=catDict[that.data[i].geo]\r\n            }\r\n            console.log(that.data)\r\n            that.drawScatterPlot()\r\n\r\n        })\r\n\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n\r\n        let xscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.fertility)})),d3.max(this.data.map((d)=>{return d.fertility}))])\r\n            .range([50,900])\r\n        let yscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.lifeExp)})),d3.max(this.data.map((d)=>{return d.lifeExp}))])\r\n            .range([900,0])\r\n        let rscale=d3.scaleSqrt().domain([d3.min(this.data.map((d)=>{return d.population})),d3.max(this.data.map((d)=>{return d.population}))])\r\n            .range([5,20])\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(xscale(this.data[i].fertility),yscale(this.data[i].lifeExp),rscale(this.data[i].population),colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",r)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"circle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    render() {\r\n        return(<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default GapMinderNew","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#8701ec','#434343','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\n\r\n\r\nclass ManuallyTree extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n/*        let centerx=minx+(maxx-minx)/2\r\n        let centery=miny+(maxy-miny)/2\r\n        let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x+=move[0]\r\n            this.pointData[i].y+=move[1]\r\n        }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x-=this.minX-20\r\n            this.pointData[i].y-=this.minY-20\r\n        }*/\r\n    }\r\n\r\n    calEPS(){\r\n        POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                // this.calEPS()\r\n                // this.createGraph()\r\n                // this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                // this.drawEdges()\r\n                this.drawPointData()\r\n                // this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        console.log(this.edges)\r\n        d3.selectAll(\"line\").remove()\r\n        let that=this\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let node1=this.edges[i].start\r\n            let node2=this.edges[i].end\r\n\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[node1].x)\r\n                .attr(\"y1\",this.pointData[node1].y)\r\n                .attr(\"x2\",this.pointData[node2].x)\r\n                .attr(\"y2\",this.pointData[node2].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",i)\r\n                .on(\"click\",function(){\r\n                    let removeindex=d3.select(this).attr(\"index\")\r\n                    that.edges[removeindex].isdelete=true\r\n                    d3.select(this).remove()\r\n                    console.log(that.edges)\r\n                })\r\n        }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetEdge1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n        }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n                <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default ManuallyTree","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#ffcc99','#001aff','#c0c0c0','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass Example1 extends  Component{\r\n    constructor() {\r\n        super();\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        let that=this\r\n        d3.csv(\"data/GapMinder-new/ex1.csv\",function(data){\r\n            // console.log(data)\r\n            // console.log(data[i])\r\n            let country=data.Country\r\n            that.data.push({\r\n                x:parseInt(data.xfield),\r\n                y:parseFloat(data.yfield),\r\n                cat:data.cat\r\n            })\r\n        }).then(function(data){\r\n            console.log(that.data)\r\n            that.drawScatterPlot()\r\n\r\n        })\r\n\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(this.data[i].x,this.data[i].y,10,colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"rect\")\r\n            .attr(\"x\",x-r)\r\n            .attr(\"y\",y-r)\r\n            .attr(\"width\",r)\r\n            .attr(\"height\",r)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"rectangle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    render() {\r\n        return(<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default Example1","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#8701ec','#434343','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\nvar clustering = require('density-clustering');\r\n\r\n\r\nclass LocalCluster extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n    }\r\n\r\n    calEPS(){\r\n        // POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let dis=this.calDistance(this.pointData[i],this.pointData[j])\r\n                if(dis>maxDis){\r\n                    maxDis=dis\r\n                }\r\n            }\r\n        }\r\n        POINT_EDGE_EPS=maxDis*0.035\r\n/*                d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",POINT_EDGE_EPS)\r\n            .attr(\"cy\",POINT_EDGE_EPS)\r\n            .attr(\"r\",POINT_EDGE_EPS)\r\n            .attr(\"fill\",\"black\")*/\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                this.calEPS()\r\n                // this.findCluster()\r\n                this.createGraph()\r\n                this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                this.drawPointData()\r\n                // this.generateTreeWithHierarchical()\r\n                this.drawEdges()\r\n                this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n\r\n\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnectBetweenCluster(){\r\n        for(let k in this.clusterDict){\r\n            let start=this.clusterDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n            for (let i=1;i<this.clusterDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.clusterDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        console.log(this.edges)\r\n        d3.selectAll(\"line\").remove()\r\n        let that=this\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let node1=this.edges[i].start\r\n            let node2=this.edges[i].end\r\n\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[node1].x)\r\n                .attr(\"y1\",this.pointData[node1].y)\r\n                .attr(\"x2\",this.pointData[node2].x)\r\n                .attr(\"y2\",this.pointData[node2].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",i)\r\n                .on(\"click\",function(){\r\n                    let removeindex=d3.select(this).attr(\"index\")\r\n                    that.edges[removeindex].isdelete=true\r\n                    d3.select(this).remove()\r\n                    console.log(that.edges)\r\n                })\r\n        }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetEdge2.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                // .on(\"drag\",function(){\r\n                //     console.log(\"drag!\")\r\n                // })\r\n                .call(drag)\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                // .on(\"drag\",function(){\r\n                //     console.log(\"drag!\")\r\n                // })\r\n                .call(drag)\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    createLocalTree(points){\r\n        //1. find center point\r\n        //2. generate tree\r\n        let midx=0\r\n        let midy=0\r\n        for (let i=0;i<points.length;i++){\r\n            midx+=points[i].x\r\n            midy+=points[i].y\r\n        }\r\n        midx=midx/points.length\r\n        midy=midy/points.length\r\n        let midnode={\r\n            x:midx,\r\n            y:midy\r\n        }\r\n        let minDis=Number.MAX_VALUE\r\n        let minindex=-1\r\n        for (let i=0;i<points.length;i++){\r\n            let dis=this.calDistance(midnode,points[i])\r\n            if(dis<minDis){\r\n                minDis=dis\r\n                minindex=i\r\n            }\r\n        }\r\n\r\n\r\n\r\n        for (let i=0;i<points.length;i++){\r\n            if(i!=minindex){\r\n                this.edges.push({\r\n                    start:points[minindex].id,\r\n                    end:points[i].id,\r\n                })\r\n                this.graph.addEdge(points[minindex].id,points[i].id)\r\n            }\r\n        }\r\n\r\n        // console.log(this.edges)\r\n/*        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }*/\r\n\r\n    }\r\n\r\n    generateTreeWithHierarchical(){\r\n        this.findCluster()\r\n        this.createGraphWithCluster()\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                this.createLocalTree(this.clusterDict[k][i])\r\n            }\r\n        }\r\n\r\n        this.mergeCluster()\r\n    }\r\n\r\n    findCluster(){\r\n        for (var k in this.catPointDict){\r\n            console.log(k)\r\n            this.clusterDict[k]=[]\r\n            this.noiseDict[k]=[]\r\n            var dbscan = new clustering.DBSCAN();\r\n            let dataset=[]\r\n            let pointDataSet=[]\r\n// parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster\r\n\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n            }\r\n            // console.log(dataset)\r\n            // console.log(pointDataSet)\r\n            var clusters = dbscan.run(dataset, POINT_EDGE_EPS, 2);\r\n            console.log(clusters, dbscan.noise);\r\n            let point\r\n            for(let i=0;i<clusters.length;i++){\r\n                let clusterPoints=[]\r\n                for (let j=0;j<clusters[i].length;j++){\r\n                     clusterPoints.push(pointDataSet[clusters[i][j]])\r\n                    // console.log(point)\r\n/*                    let point=dataset[clusters[i][j]]\r\n                    d3.select(\"svg\")\r\n                        .append(\"circle\")\r\n                        .attr(\"cx\",point[0])\r\n                        .attr(\"cy\",point[1])\r\n                        .attr(\"r\",10)\r\n                        .attr(\"fill\",\"none\")\r\n                        .attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",2)*/\r\n                }\r\n                // this.createLocalTree(clusterPoints)\r\n                this.clusterDict[k].push(clusterPoints)\r\n            }\r\n            for (let i=0;i<dbscan.noise.length;i++){\r\n                this.clusterDict[k].push([pointDataSet[dbscan.noise[i]]])\r\n            }\r\n        }\r\n        console.log(this.clusterDict)\r\n        // console.log(this.noiseDict)\r\n    }\r\n\r\n    createGraphWithCluster(){\r\n        let clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n            }\r\n\r\n        }\r\n        this.clusterArr=clusterArr\r\n        console.log(this.clusterArr)\r\n        var g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        this.clustergraph=g\r\n\r\n        var g2 = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g2.V;i++){\r\n            g2.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g2\r\n    }\r\n\r\n    calClusterDistance(cluster1,cluster2){\r\n        let dissum=0\r\n        let num=0\r\n        let mindis=Number.MAX_VALUE\r\n        for(let i=0;i<cluster1.length;i++){\r\n            for (let j=0;j<cluster2.length;j++){\r\n                // dissum+=this.calDistance(cluster1[i],cluster2[j])\r\n                // num+=1\r\n                let dis=this.calDistance(cluster1[i],cluster2[j])\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                }\r\n            }\r\n        }\r\n        return mindis\r\n    }\r\n\r\n    sortEdgesGlobalWithCluster(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.clusterDict){\r\n            for(let i=0;i<this.clusterDict[k].length;i++){\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let dis=this.calClusterDistance(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    // let mess=this.calEdgeMess(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    disArray.push(dis)\r\n                    // messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    // tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                    tempedges.push([this.clusterDict[k][i].id,this.clusterDict[k][j].id,dis])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            // let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            // edges.push([start,end,weight,dis,mess])\r\n            edges.push([start,end,weight,dis])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    findLinkBetweenCluster(cluster1,cluster2){\r\n        let mindis=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                if(!this.checkNewEdge(start,end)){\r\n                    flag=true\r\n                    let dis=this.calDistance(start,end)\r\n                    if(dis<mindis){\r\n                        mindis=dis\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return [flag,minstart,minend,mindis]\r\n    }\r\n\r\n    findOptimalLink(cluster1,cluster2){\r\n        let mincrossnum=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                let crossnum=0\r\n\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n\r\n                }\r\n                if(crossnum<mincrossnum){\r\n                    mincrossnum=crossnum\r\n                    minstart=start\r\n                    minend=end\r\n                }\r\n                else if(crossnum==mincrossnum){\r\n                    let dis1=this.calDistance(minstart,minend)\r\n                    let dis2=this.calDistance(start,end)\r\n                    if(dis2<dis1){\r\n                        mincrossnum=crossnum\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return [minstart,minend,mincrossnum]\r\n    }\r\n\r\n    mergeCluster(){\r\n        //average distance as distance between clusters\r\n        //find an optimal link with least crossing\r\n\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithCluster()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            // let mess=sortedEdges[i][4]\r\n\r\n\r\n\r\n            if(this.clusterArr[start].cat!=this.clusterArr[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n\r\n                let link=this.findLinkBetweenCluster(this.clusterArr[start].points,this.clusterArr[end].points)\r\n\r\n                if(link[0]){\r\n                    this.clustergraph.addEdge(start,end)\r\n                    this.graph.addEdge(link[1].id,link[2].id)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:link[1].id,\r\n                        end:link[2].id,\r\n                        weight:link[3],\r\n                        dis:link[3],\r\n                        // mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        // mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n        // this.drawEdges()\r\n\r\n        while(!this.checkConnectBetweenCluster()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.findOptimalLink(this.clusterArr[start].points,this.clusterArr[end].points)\r\n                    removeEdggeList[i].weight=scores[3]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push({\r\n                        clusterstart:start,\r\n                        clusterend:end,\r\n                        start:scores[0].id,\r\n                        end:scores[1].id,\r\n                        weight:scores[2],\r\n                        crossnum:scores[2]\r\n                    })\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.clustergraph.addEdge(tempEdgeList[maxindex].clusterstart,tempEdgeList[maxindex].clusterend)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                // dis:tempEdgeList[maxindex].dis,\r\n                // mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // this.drawEdges()\r\n            console.log()\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n                <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default LocalCluster","import * as d3 from \"d3\";\r\n\r\nexport function add(a,b){\r\n    return a+b\r\n}\r\n\r\nexport function calDistance(x1,y1,x2,y2){\r\n    return Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2))\r\n}\r\n\r\nexport function getVecNorm(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    return norm\r\n}\r\n\r\nexport function normalizeVec(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    let newvec=[vec[0]/norm,vec[1]/norm]\r\n    return newvec\r\n}\r\n\r\nexport function drawCircle(x,y,r,fill,stroke){\r\n    d3.select(\"#mainsvg\")\r\n        .append(\"circle\")\r\n        .attr(\"class\",\"elespace\")\r\n        .attr(\"cx\",x)\r\n        .attr(\"cy\",y)\r\n        .attr(\"r\",r)\r\n        .attr(\"fill\",fill)\r\n        .attr(\"stroke\",stroke)\r\n        .attr(\"stroke-width\",1)\r\n}\r\n\r\nexport function drawRect(x,y,width,height,color){\r\n    d3.select(\"svg\")\r\n        .append(\"rect\")\r\n        .attr(\"x\",x-width/2)\r\n        .attr(\"y\",y-height/2)\r\n        .attr(\"width\",width)\r\n        .attr(\"height\",height)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",color)\r\n        .attr(\"stroke-width\",2)\r\n}\r\n\r\nexport function drawPolygon(points,dx,dy,color){\r\n    d3.select(\"svg\").append(\"path\")\r\n        .style(\"fill\", \"none\")\r\n        .style(\"stroke\",color)\r\n        .style(\"stroke-width\", 0.5)\r\n        .attr(\"d\", function () {\r\n            var p = \"\";\r\n            p += (d3.line()\r\n                    .x(function (dat) {\r\n                        return dat[0]+dx;\r\n                    })\r\n                    .y(function (dat) {\r\n                        return dat[1]+dy;\r\n                    })\r\n            )(points)+ \"\";\r\n            return p;\r\n        })\r\n        .on('mouseover', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"red\")\r\n                .style(\"stroke-width\", 2);\r\n        })\r\n        .on('mouseout', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"black\")\r\n                .style(\"stroke-width\", 0.5);\r\n        });\r\n}\r\nexport function drawLine(start,end,color,width){\r\n    d3.select(\"svg\").append(\"line\")\r\n        .attr(\"x1\",start[0])\r\n        .attr(\"y1\",start[1])\r\n        .attr(\"x2\",end[0])\r\n        .attr(\"y2\",end[1])\r\n        .attr(\"stroke-width\",width)\r\n        .attr(\"stroke\",color)\r\n        .on(\"mouseover\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",\"red\")\r\n        })\r\n        .on(\"mouseout\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",color)\r\n        })\r\n}\r\n\r\nexport function  isContained(catarr,cat){\r\n    catarr=catarr.split(\",\")\r\n    for(let i=0;i<catarr.length;i++){\r\n        if(catarr[i]==cat){\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nexport function  PointToSegDist( x,  y,  x1,  y1,  x2,  y2)\r\n{\r\n     let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n    // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n    if (cross <= 0) return -1\r\n\r\n     let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n    // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n    if (cross >= d2) return -1\r\n\r\n\r\n\r\n    let r = cross / d2;\r\n    let px = x1 + (x2 - x1) * r;\r\n    let py = y1 + (y2 - y1) * r;\r\n    return Math.sqrt((x - px) * (x - px) + (py - y) * (py - y));\r\n}\r\n\r\nfunction calLineCirclePoint(){\r\n    //ax+by+c=0\r\n}\r\n\r\nexport function calTanPoint(cx,cy,radius,point) {\r\n    //点到圆心的距离\r\n    let d = Math.sqrt(Math.pow(cx - point.x,2) + Math.pow(cy - point.y,2));\r\n    let vc1c2 = {x:point.x - cx,y:-point.y + cy}; //屏幕坐标系与笛卡尔坐标系是y轴是反着的\r\n    let radC1C2 = Math.acos(vc1c2.x / Math.sqrt(Math.pow(vc1c2.x,2) + Math.pow(vc1c2.y,2)));\r\n    let theta = Math.acos(radius/d);\r\n    if(point.y < cy){\r\n        let p1 = {x:cx + Math.cos(theta + radC1C2)*radius,y:cy - Math.sin(theta + radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(theta - radC1C2)*radius,y:cy + Math.sin(theta - radC1C2)*radius};\r\n        return {p1:p1,p2:p2};\r\n    }else{\r\n        radC1C2 = Math.PI - radC1C2;\r\n        let p1 = {x:cx + Math.cos(Math.PI - theta - radC1C2)*radius,y:cy + Math.sin(Math.PI - theta - radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(Math.PI - (theta - radC1C2))*radius,y:cy - Math.sin(Math.PI - (theta - radC1C2))*radius};\r\n        return {p1:p1,p2:p2};\r\n    }\r\n}\r\n\r\nexport function calCommonTanPoint(x1,y1,r1,x2,y2,r2){\r\n    let tanPoints=[]\r\n    let delta1=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1+r2,2)//+\r\n    let delta2=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1-r2,2)//-\r\n\r\n    let p1=r1*(x2*x2+y2*y2-x1*x2-y1*y2)\r\n    let p2=r2*(x1*x1+y1*y1-x1*x2-y1*y2)\r\n    let q=x1*y2-x2*y1\r\n\r\n    //four points\r\n    let vecpq=[x2-x1,y2-y1]\r\n    let normvec=[-vecpq[1],vecpq[0]]\r\n    let dir=normalizeVec(normvec)\r\n    let newpointp=[x1+r1*dir[0],y1+r1*dir[1]]\r\n    let newpointq=[x2+r2*dir[0],y2+r2*dir[1]]\r\n\r\n    tanPoints.push([newpointp,newpointq])\r\n\r\n    let dir2=[-1*dir[0],-1*dir[1]]\r\n    let newpointp2=[x1+r1*dir2[0],y1+r1*dir2[1]]\r\n    let newpointq2=[x2+r2*dir2[0],y2+r2*dir2[1]]\r\n\r\n    tanPoints.push([newpointp2,newpointq2])\r\n\r\n\r\n    if(delta1<0&&delta2<0){\r\n        return []\r\n    }\r\n    else if(delta1<0&&delta2>0){\r\n        //相交, just four points, two lines\r\n        return tanPoints\r\n    }\r\n    else if(delta1==0&&delta2>0){\r\n        //外切, five points, two lines\r\n        return tanPoints\r\n\r\n    }\r\n    else if(delta1>0&&delta2>0){\r\n        //外离, eight points, four lines\r\n        let intersecx=(r1*x2+r2*x1)/(r1+r2)\r\n        let intersecy=(r1*y2+r2*y1)/(r1+r2)\r\n        let tanpoints1=calTanPoint(x1,y1,r1,{x:intersecx,y:intersecy})\r\n        let tanpoints2=calTanPoint(x2,y2,r2,{x:intersecx,y:intersecy})\r\n\r\n        let p1=tanpoints1.p1\r\n        let p2={x:intersecx,y:intersecy}\r\n        let p3=tanpoints2.p1\r\n\r\n        let delta=(p3.y-p1.y)*(p2.x-p1.x)-(p2.y-p1.y)*(p3.x-p1.x)\r\n        if(Math.abs(delta)<=0.000001){\r\n            //p1p1\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n\r\n        }\r\n    else{\r\n        //p1p2\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n        }\r\n\r\n    return tanPoints\r\n\r\n    }\r\n\r\n    else{\r\n        return []\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nexport function drawArc(startp,endp,center,radius){\r\n    let pathstr=\"\"\r\n    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n    let largearcflag=0\r\n    let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n    let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n    let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n    if(crossmul>0){\r\n        largearcflag=1\r\n    }\r\n    else if(crossmul<=0){\r\n        largearcflag=0\r\n    }\r\n    pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n    d3.select(\"svg\")\r\n        .append(\"path\")\r\n        .attr(\"d\",pathstr)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",\"black\")\r\n        .attr(\"stroke-width\",\"1\")\r\n}\r\n\r\nexport function getDegreeTwoVec(vec1,vec2){\r\n    let norm1=getVecNorm(vec1)\r\n    let norm2=getVecNorm(vec2)\r\n    let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n\r\n    let cos=dot/(norm1*norm2)\r\n\r\n    return Math.acos(cos)\r\n\r\n}\r\n\r\nexport function rotatePoint(x,y,rx0,ry0,alpha){\r\n    let x0= (x - rx0)*Math.cos(alpha) - (y - ry0)*Math.sin(alpha) + rx0 ;\r\n    let y0= (x - rx0)*Math.sin(alpha) + (y - ry0)*Math.cos(alpha) + ry0 ;\r\n    return [x0,y0]\r\n}\r\n\r\nexport function crossMul(vec1,vec2){\r\n\r\n    return vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n}\r\n\r\nexport function clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}","var BSpline = function(points,degree,copy){\r\n    if(copy){\r\n        this.points = []\r\n        for(var i = 0;i<points.length;i++){\r\n            this.points.push(points[i]);\r\n        }\r\n    }else{\r\n        this.points = points;\r\n    }\r\n    this.degree = degree;\r\n    this.dimension = points[0].length;\r\n    if(degree == 2){\r\n        this.baseFunc = this.basisDeg2;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 3){\r\n        this.baseFunc = this.basisDeg3;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 4){\r\n        this.baseFunc = this.basisDeg4;\r\n        this.baseFuncRangeInt = 3;\r\n    }else if(degree == 5){\r\n        this.baseFunc = this.basisDeg5;\r\n        this.baseFuncRangeInt = 3;\r\n    } \r\n};\r\n\r\nBSpline.prototype.seqAt = function(dim){\r\n    var points = this.points;\r\n    var margin = this.degree + 1;\r\n    return function(n){\r\n        if(n < margin){\r\n            return points[0][dim];\r\n        }else if(points.length + margin <= n){\r\n            return points[points.length-1][dim];\r\n        }else{\r\n            return points[n-margin][dim];\r\n        }\r\n    };\r\n};\r\n\r\nBSpline.prototype.basisDeg2 = function(x){\r\n    if(-0.5 <= x && x < 0.5){\r\n        return 0.75 - x*x;\r\n    }else if(0.5 <= x && x <= 1.5){\r\n        return 1.125 + (-1.5 + x/2.0)*x;\r\n    }else if(-1.5 <= x && x < -0.5){\r\n        return 1.125 + (1.5 + x/2.0)*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg3 = function(x){\r\n    if(-1 <= x && x < 0){\r\n        return 2.0/3.0 + (-1.0 - x/2.0)*x*x;\r\n    }else if(1 <= x && x <= 2){\r\n        return 4.0/3.0 + x*(-2.0 + (1.0 - x/6.0)*x);\r\n    }else if(-2 <= x && x < -1){\r\n        return 4.0/3.0 + x*(2.0 + (1.0 + x/6.0)*x);\r\n    }else if(0 <= x && x < 1){\r\n        return 2.0/3.0 + (-1.0 + x/2.0)*x*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg4 = function(x){\r\n    if(-1.5 <= x && x < -0.5){\r\n        return 55.0/96.0 + x*(-(5.0/24.0) + x*(-(5.0/4.0) + (-(5.0/6.0) - x/6.0)*x));\r\n    }else if(0.5 <= x && x < 1.5){\r\n        return 55.0/96.0 + x*(5.0/24.0 + x*(-(5.0/4.0) + (5.0/6.0 - x/6.0)*x));\r\n    }else if(1.5 <= x && x <= 2.5){\r\n        return 625.0/384.0 + x*(-(125.0/48.0) + x*(25.0/16.0 + (-(5.0/12.0) + x/24.0)*x));\r\n    }else if(-2.5 <= x && x <= -1.5){\r\n        return 625.0/384.0 + x*(125.0/48.0 + x*(25.0/16.0 + (5.0/12.0 + x/24.0)*x));\r\n    }else if(-1.5 <= x && x < 1.5){\r\n        return 115.0/192.0 + x*x*(-(5.0/8.0) + x*x/4.0);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg5 = function(x){\r\n    if(-2 <= x && x < -1){\r\n        return 17.0/40.0 + x*(-(5.0/8.0) + x*(-(7.0/4.0) + x*(-(5.0/4.0) + (-(3.0/8.0) - x/24.0)*x)));\r\n    }else if(0 <= x && x < 1){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 - x/12.0)*x*x);\r\n    }else if(2 <= x && x <= 3){\r\n        return 81.0/40.0 + x*(-(27.0/8.0) + x*(9.0/4.0 + x*(-(3.0/4.0) + (1.0/8.0 - x/120.0)*x)));\r\n    }else if(-3 <= x && x < -2){\r\n        return 81.0/40.0 + x*(27.0/8.0 + x*(9.0/4.0 + x*(3.0/4.0 + (1.0/8.0 + x/120.0)*x)));\r\n    }else if(1 <= x && x < 2){\r\n        return 17.0/40.0 + x*(5.0/8.0 + x*(-(7.0/4.0) + x*(5.0/4.0 + (-(3.0/8.0) + x/24.0)*x)));\r\n    }else if(-1 <= x && x < 0){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 + x/12.0)*x*x);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.getInterpol = function(seq,t){\r\n    var f = this.baseFunc;\r\n    var rangeInt = this.baseFuncRangeInt;\r\n    var tInt = Math.floor(t);\r\n    var result = 0;\r\n    for(var i = tInt - rangeInt;i <= tInt + rangeInt;i++){\r\n        result += seq(i)*f(t-i);\r\n    }\r\n    return result;\r\n};\r\n\r\nBSpline.prototype.calcAt = function(t){\r\n    t = t*((this.degree+1)*2+this.points.length);//t must be in [0,1]\r\n    if(this.dimension == 2){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t)];\r\n    }else if(this.dimension == 3){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t),this.getInterpol(this.seqAt(2),t)];\r\n    }else{\r\n        var res = [];\r\n        for(var i = 0;i<this.dimension;i++){\r\n            res.push(this.getInterpol(this.seqAt(i),t));\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nexport default BSpline\r\n","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport { Slider, InputNumber, Row, Col } from 'antd';\r\nimport 'antd/dist/antd.css'; // or 'antd/dist/antd.less'\r\nimport { Button } from 'antd';\r\n\r\nimport * as d3 from \"d3\"\r\nimport {calDistance, drawRect, normalizeVec, drawPolygon, drawLine,PointToSegDist,getVecNorm} from \"./util\"\r\nimport {isoBandOptions} from \"marchingsquares/src/options\";\r\nimport {main} from \"d3/dist/package\";\r\n\r\nimport BSpline from \"./BSpline\";\r\n\r\nvar MarchingSquaresJS = require('marchingsquares');\r\nvar IsoInsideTest = require('point-in-polygon');\r\nvar AreaCal = require('2d-polygon-area');\r\n//barrier map:\r\n//1: inside the gap of a node\r\n//2: inside the gap of an edge\r\n//3. inside a node\r\n//4. inside an edge\r\n//5. inside the initial field of a node\r\n//6. inside the initial field of an edge\r\n\r\n// Note: X and Y attribute are all center point for both circle and rectangle!\r\n\r\nvar pointDataName=\"BubbleSetExample1.txt\"\r\nvar edgeDataName=\"BubbleSetEdge1.txt\"\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar buffer=10\r\n// var nodeR0=10\r\n// var nodeR1=20\r\n// var edgeR0=15\r\n// var edgeR1=20\r\nvar nodeR1=15\r\nvar nodeR0=nodeR1-5\r\n\r\nvar edgeR1=20\r\nvar edgeR0=edgeR1-5\r\n\r\n\r\nvar defaultEdgeWidth=5\r\nvar edgeWidth=5 //5-10\r\nvar itemEnergyShape=\"circle\"\r\nvar nodeWeight=1\r\nvar edgeWeight=1\r\nvar nodeNegWeight=-0.8\r\nvar edgeNegWeight=0\r\nvar barrierGap=3\r\nvar intervals = [0.001]\r\nvar pixelGroup = 2\r\nvar gapBetween=1\r\nvar fixdis = Math.sqrt(0.25 * (pixelGroup - 1) * (pixelGroup - 1) + 0.25 * (pixelGroup - 1) * (pixelGroup - 1))\r\nvar control_points={}\r\nvar initialControlPoints={}\r\nvar is_selected={}\r\nvar eps = 1e-10\r\nvar move_points = []\r\nvar mid_point = 0\r\nvar nearpts = []\r\nvar svg;\r\nvar g;\r\nvar hasChangeView = false;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\nvar prepoints = []\r\n\r\nvar svgwidth = 2000\r\nvar svgheight = 2000\r\nvar skipPoint = 10\r\nvar minItemArea = Number.MAX_VALUE\r\n\r\nvar editSeg = {}\r\nvar recalNum = 0\r\nvar recal = false\r\nvar remove_Polys = {}\r\n\r\nvar lineFunction = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveBasisClosed);\r\n\r\nvar lineFunction_reDraw = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveCardinal);\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//d3.select(\"svg\")\r\nclass AdaptiveIsovalue extends  Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n        edges: PropTypes.array\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[],\r\n        edges:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            nodeR0: 10,\r\n            nodeR1: 20,\r\n            edgeR0: 15,\r\n            edgeR1: 20,\r\n            pixelGroup: 3,\r\n            gapBetween:1,\r\n            edgeWidth: defaultEdgeWidth,\r\n            hasSelectEdge:false\r\n        }\r\n        this.isfirstcreate=true\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.edgeControlPoints=[]\r\n        this.hasMST=false\r\n        this.updateIdx = []\r\n        this.hasBubbles = false\r\n        this.firstFlag = true\r\n    }\r\n\r\n    init(){\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.updateIdx = []\r\n        this.firstFlag = true\r\n    }\r\n\r\n    bubbleState(){\r\n        return this.hasBubbles\r\n    }\r\n\r\n    setViewBox(X, Y, Width, Height){\r\n        X = offsetX\r\n        Y = offsetY\r\n        Width = viewWidth\r\n        Height = viewHeight\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n        //let svg = d3.select(\"svg\");\r\n\r\n\r\n        //this.getData()\r\n    }\r\n\r\n    preProcessPoints(points, pdict){\r\n        for(let i = 0;i < points.length; i ++){\r\n            let tmp\r\n            if(points[i].flag == true){\r\n                tmp = this.pointData[points[i].id]\r\n                tmp.flag = true\r\n            }\r\n            else{\r\n                tmp = points[i]\r\n            }\r\n            for (let c = 0;c < tmp.catArray.length; c ++){\r\n                let nowcat = tmp.catArray[c]\r\n                if(!pdict.hasOwnProperty(nowcat)){\r\n                    pdict[nowcat] = []\r\n                }\r\n                pdict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    preProcessEdges(edges, edict, filledges){\r\n        //console.log(\"preProcessEdges\")\r\n        //console.log(edges)\r\n        //console.log(this.edges)\r\n        for(let i = 0;i < edges.length; i ++){\r\n            let tmp\r\n            let catarr\r\n            if(edges[i].flag == true){\r\n                tmp = this.edges[edges[i].id]\r\n                tmp.flag = true\r\n                catarr = this.pointData[tmp.start].catArray\r\n                filledges.push(tmp)\r\n            }\r\n            else{\r\n                tmp = edges[i]\r\n                catarr = tmp.startpoint.catArray\r\n            }\r\n            for (let c = 0;c < catarr.length; c ++){\r\n                let nowcat = catarr[c]\r\n                if(!edict.hasOwnProperty(nowcat)){\r\n                    edict[nowcat] = []\r\n                }\r\n                edict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    editReDraw(editPoints, editEdges, HpointData, Hedges){\r\n\r\n        //console.log(\"editReDraw:\")\r\n        //console.log(editEdges)\r\n\r\n        console.time(\"Total Time\")\r\n\r\n        let tmpedges = clone(this.edges)\r\n        //console.log(\"Before:\")\r\n        //console.log(tmpedges)\r\n\r\n        this.pointData = HpointData\r\n        this.edges = Hedges\r\n        this.catPointDict = {}\r\n        this.catEdgeDict = {}\r\n        this.updateIdx = []\r\n        this.itemShape = this.pointData[0].shape\r\n\r\n        for (let i = 0; i < this.pointData.length; i++) {\r\n            this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id = i\r\n            this.pointData[i].cat = this.pointData[i].cat.toString()\r\n            let cats = this.pointData[i].cat.split(\",\")\r\n            let catarray = []\r\n            if (cats.length > 1) {\r\n                this.pointData[i].multicat = true\r\n                for (let c = 0; c < cats.length; c++) {\r\n                    catarray.push(cats[c])\r\n                }\r\n            } else {\r\n                this.pointData[i].multicat = false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray = catarray\r\n        }\r\n\r\n        this.centralizeData(false)\r\n\r\n        this.calEdgeLength()\r\n\r\n        this.calActiveRegion(false)\r\n\r\n        let updatePoints = {}\r\n        let updateEdges = {}\r\n        let filledges = []\r\n\r\n        this.preProcessPoints(editPoints, updatePoints)\r\n        this.preProcessEdges(editEdges, updateEdges, filledges)\r\n\r\n        //console.log(\"After:\")\r\n        //console.log(this.edges)\r\n        //console.log(\"Update Edges:\")\r\n        //console.log(updateEdges)\r\n\r\n        //console.log(\"update info:\")\r\n        //console.log(updatePoints)\r\n        //console.log(updateEdges)\r\n\r\n        console.time(\"cal energy field\")\r\n        //this.calEnergyField()\r\n        this.calEnergyField_Part(updatePoints, updateEdges)\r\n        console.timeEnd(\"cal energy field\")\r\n\r\n        //d3.selectAll(\"rect\").remove()\r\n        //for(let k in this.catEnergyField){\r\n            //this.drawEnergyField(\"0\")\r\n        //}\r\n\r\n\r\n\r\n        console.time(\"cal final energy field\")\r\n        //this.calFinalEnergeField()\r\n        //d3.selectAll(\"#final\").remove()\r\n        this.calFinalEnergeField_Part()\r\n        console.timeEnd(\"cal final energy field\")\r\n\r\n        console.time(\"fill cross edge\")\r\n        this.fillCrossingEdge_Part(filledges)\r\n        console.timeEnd(\"fill cross edge\")\r\n\r\n        d3.selectAll(\"path\").remove()\r\n        //d3.selectAll(\"rect\").remove()\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        //this.drawEdges()\r\n//\r\n        //this.drawPointData()\r\n\r\n\r\n\r\n        console.timeEnd(\"Total Time\")\r\n\r\n        let that=this\r\n        function handleSvgClick(){\r\n            console.log(\"click svg!\")\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n    }\r\n\r\n    getData(){\r\n        //let that=this\r\n        //fetch('/data/'+pointDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n            //.then(res=>res.json())\r\n            //.then(data=>{\r\n        if(this.props.pointData && this.props.edges) {\r\n            if(this.props.edges.length > 0){\r\n                this.hasMST = true;\r\n            }\r\n            this.init();\r\n            if(this.hasMST == false){\r\n                let tmp = this.props.createMST()\r\n                this.pointData = tmp[0]\r\n                this.edges = tmp[1]\r\n                colors = tmp[2]\r\n                this.hasMST = true;\r\n            }\r\n            else{\r\n                this.pointData = this.props.pointData\r\n                this.edges = this.props.edges\r\n            }\r\n            //console.log(\"Draw Bubbles\")\r\n            //console.log(this.pointData)\r\n            //console.log(this.edges)\r\n            this.itemShape = this.pointData[0].shape\r\n            for (let i = 0; i < this.pointData.length; i++) {\r\n                this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n                this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n                this.pointData[i].id = i\r\n                this.pointData[i].cat = this.pointData[i].cat.toString()\r\n\r\n                if(this.pointData[i].hasOwnProperty(\"radius\")){\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].radius * this.pointData[i].radius * Math.PI)\r\n                }\r\n                else{\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].width * this.pointData[i].width)\r\n                }\r\n\r\n                let cats = this.pointData[i].cat.split(\",\")\r\n                let catarray = []\r\n                if (cats.length > 1) {\r\n                    this.pointData[i].multicat = true\r\n                    for (let c = 0; c < cats.length; c++) {\r\n                        catarray.push(cats[c])\r\n                    }\r\n                } else {\r\n                    this.pointData[i].multicat = false\r\n                    catarray.push(this.pointData[i].cat)\r\n                }\r\n                this.pointData[i].catArray = catarray\r\n            }\r\n\r\n            this.loadEdgeData()\r\n            if(this.props.handleCreated){\r\n                this.props.handleCreated()\r\n            }\r\n        }\r\n            //})\r\n\r\n    }\r\n\r\n\r\n\r\n    centralizeData(ViewFlag){\r\n        this.minX=Number.MAX_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.maxX=Number.MIN_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            //this.pointData[i].isGroup=true;\r\n            if(itemEnergyShape==\"circle\"){\r\n                if(this.itemShape==\"rectangle\"){\r\n                    let r=Math.sqrt(Math.pow(this.pointData[i].width,2)+Math.pow(this.pointData[i].height,2))/2\r\n                    this.pointData[i].radius=r\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].radius\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].radius\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].radius\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].radius\r\n\r\n            }\r\n            else if(itemEnergyShape==\"rectangle\"){\r\n                if(this.itemShape==\"circle\"){\r\n                    this.pointData[i].width=this.pointData[i].radius*2\r\n                    this.pointData[i].height=this.pointData[i].radius*2\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].width/2\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].width/2\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].height/2\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].height/2\r\n\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,this.pointData[i].maxX)\r\n            this.maxY=Math.max(this.maxY,this.pointData[i].maxY)\r\n            this.minX=Math.min(this.minX,this.pointData[i].minX)\r\n            this.minY=Math.min(this.minY,this.pointData[i].minY)\r\n\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                    this.catPointDict[nowcat].minX = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxX = Number.MIN_VALUE\r\n                    this.catPointDict[nowcat].minY = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxY = Number.MIN_VALUE\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,this.pointData[i].minX)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,this.pointData[i].maxX)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,this.pointData[i].minY)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,this.pointData[i].maxY)\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let catarr=this.pointData[start].catArray\r\n\r\n            let minx=Math.min(this.pointData[start].x,this.pointData[end].x)\r\n            let miny=Math.min(this.pointData[start].y,this.pointData[end].y)\r\n            let maxx=Math.max(this.pointData[start].x,this.pointData[end].x)\r\n            let maxy=Math.max(this.pointData[start].y,this.pointData[end].y)\r\n\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                for (let p=0;p<vpoints.length;p++){\r\n                    let x=vpoints[p][0]\r\n                    let y=vpoints[p][1]\r\n                    minx=Math.min(minx,x)\r\n                    miny=Math.min(miny,y)\r\n                    maxx=Math.max(maxx,x)\r\n                    maxy=Math.max(maxy,y)\r\n                }\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,maxx)\r\n            this.maxY=Math.max(this.maxY,maxy)\r\n            this.minX=Math.min(this.minX,minx)\r\n            this.minY=Math.min(this.minY,miny)\r\n\r\n            this.edges[i].x=minx\r\n            this.edges[i].y=miny\r\n            this.edges[i].width=maxx-minx\r\n            this.edges[i].height=maxy-miny\r\n\r\n            //this.edges[i].isGroup=true;\r\n\r\n            for (let c=0;c<catarr.length;c++){\r\n                // let catarr=this.pointData[this.edges[i].start].catArray\r\n                let nowcat=catarr[c]\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,minx)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,maxx)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,miny)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,maxy)\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat=this.edges[i].cat\r\n            if(!this.catEdgeDict.hasOwnProperty(cat)){\r\n                this.catEdgeDict[cat]=[]\r\n            }\r\n            this.catEdgeDict[cat].push(this.edges[i])\r\n\r\n        }\r\n        //console.log(this.catEdgeDict)\r\n\r\n        if(ViewFlag){\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n////\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n//\r\n            d3.selectAll('g').attr(\"transform\",\"\");\r\n        }\r\n\r\n\r\n        if(hasChangeView == false){\r\n            offsetX = this.minX-Math.max(nodeR1,edgeR1)-buffer-10\r\n            offsetY = this.minY-Math.max(nodeR1,edgeR1)-buffer-10\r\n            viewWidth = this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            viewHeight = this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            hasChangeView = true\r\n        }\r\n\r\n    }\r\n\r\n\r\n    drawPointData(){\r\n        colors = this.props.colorArray\r\n        // d3.select(\"svg\").selectAll(\"*\").remove();\r\n        svg = d3.select('svg');\r\n\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let items=[]\r\n\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"circle\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    \"id\":items[i].getAttribute(\"index\"),\r\n                    \"bbox\":items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"rect\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    isInEdgeRange(x,y,start,end){\r\n        let x1=start.x\r\n        let y1=start.y\r\n        let x2=end.x\r\n        let y2=end.y\r\n\r\n        let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n        // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n        if (cross <= 0) return false\r\n\r\n        let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n        // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n        if (cross >= d2) return false\r\n\r\n        return true\r\n    }\r\n\r\n    calEdgeControlPoints(){\r\n        function sortArr(a,b){\r\n            return a.avgdis-b.avgdis\r\n        }\r\n        this.edgeControlPoints=[]\r\n        let tempcontrolpoints=[]\r\n        for(let i=0;i<this.edges.length;i++){\r\n            this.edgeControlPoints.push([])\r\n            tempcontrolpoints.push([])\r\n        }\r\n        for (var k in control_points){\r\n            for (let n=0;n<control_points[k].length;n++){\r\n                let controlpoints=control_points[k][n]\r\n                for(let i=0;i<controlpoints.length;i++){\r\n                    let minDis=Number.MAX_VALUE\r\n                    let minindex=-1\r\n                    for(let e=0;e<this.edges.length;e++){\r\n                        let edge=this.edges[e]\r\n                        if(edge.cat!=k){\r\n                            continue\r\n                        }\r\n                        let start=this.pointData[edge.start]\r\n                        let end=this.pointData[edge.end]\r\n                        let dis=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n                        if(dis>0){\r\n                            if(dis<minDis){\r\n                                minDis=dis\r\n                                minindex=e\r\n                            }\r\n                        }\r\n                    }\r\n                    if(minindex>=0){\r\n                        tempcontrolpoints[minindex].push({\r\n                            order:n,\r\n                            index:i,\r\n                            dis:minDis\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        // console.log(tempcontrolpoints[153])\r\n\r\n        for(let i=0;i<tempcontrolpoints.length;i++){\r\n            let iscontinue=false\r\n            let temppoints=[]\r\n            for(let j=1;j<tempcontrolpoints[i].length;j++){\r\n                let lastindex=tempcontrolpoints[i][j-1].index\r\n                let index=tempcontrolpoints[i][j].index\r\n                if(index-lastindex==1){\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                    else{\r\n                        iscontinue=true\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                }\r\n                else{\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                        iscontinue=false\r\n\r\n                        this.edgeControlPoints[i].push(temppoints)\r\n\r\n                        temppoints=[]\r\n                    }\r\n                    else{\r\n\r\n                    }\r\n                }\r\n            }\r\n            if(iscontinue){\r\n                temppoints.push(tempcontrolpoints[i][tempcontrolpoints[i].length-1])\r\n                this.edgeControlPoints[i].push(temppoints)\r\n            }\r\n        }\r\n        console.log(this.edgeControlPoints)\r\n\r\n        for (let i=0;i<this.edgeControlPoints.length;i++){\r\n            if(this.edgeControlPoints[i].length>2){\r\n                for (let j=0;j<this.edgeControlPoints[i].length;j++){\r\n                    let avgdis=0\r\n                    for (let p=0;p<this.edgeControlPoints[i][j].length;p++){\r\n                        avgdis+=this.edgeControlPoints[i][j][p].dis\r\n                    }\r\n                    avgdis=avgdis/this.edgeControlPoints[i][j].length\r\n                    this.edgeControlPoints[i][j].avgdis=avgdis\r\n                }\r\n                this.edgeControlPoints[i].sort(sortArr)\r\n                let tmp=[this.edgeControlPoints[i][0],this.edgeControlPoints[i][1]]\r\n                this.edgeControlPoints[i]=tmp\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    changeEdgeWidth(index,width){\r\n        let dw=width-defaultEdgeWidth\r\n        dw=dw*1.5\r\n        // console.log(width,dw)\r\n        //recalculate energy field\r\n/*        let i=index\r\n        let edges=this.edges\r\n        let k=edges[index].cat\r\n        let controlpoints=control_points[k]\r\n        let start=this.pointData[edges[index].start]\r\n        let end=this.pointData[edges[index].end]\r\n        let distances=[]\r\n        for (let i=0;i<controlpoints.length;i++){\r\n            let distoedge=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n            distances.push(distoedge)\r\n        }\r\n\r\n        let iscontinue=false\r\n        let temppoints={\r\n            points:[],\r\n            dis:0\r\n        }\r\n        let potentialPoints=[]\r\n        for(let i=0;i<distances.length;i++){\r\n            if(distances[i]>=0){\r\n                if(iscontinue){\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n                else{\r\n                    iscontinue=true\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n            }\r\n            else{\r\n                if(iscontinue){\r\n                    if(temppoints.points.length>1){\r\n                        temppoints.dis=temppoints.dis/temppoints.points.length\r\n                        potentialPoints.push(temppoints)\r\n                    }\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    iscontinue=false\r\n                }\r\n                else{\r\n\r\n                }\r\n            }\r\n        }\r\n        for(let i=0;i<potentialPoints.length;i++){\r\n            for(let p=0;p<potentialPoints[i].points.length;p++){\r\n                let point=controlpoints[potentialPoints[i].points[p]]\r\n                drawRect(point[0],point[1],1,1,\"red\")\r\n            }\r\n        }\r\n        console.log(potentialPoints)*/\r\n        let k=this.edges[index].cat\r\n        let start=this.pointData[this.edges[index].start]\r\n        let end=this.pointData[this.edges[index].end]\r\n        let dir=[end.x-start.x,end.y-start.y]\r\n\r\n        let norm=[-dir[1],dir[0]]\r\n        norm=normalizeVec(norm)\r\n\r\n        // drawLine([start.x,start.y],[start.x+50*norm[0],start.y+50*norm[1]],\"red\")\r\n\r\n        //console.log(\"changEdgeWidth:\")\r\n        //console.log(this.edgeControlPoints)\r\n\r\n        let controlpoints=this.edgeControlPoints[index]\r\n            let firstOutline=controlpoints[0]\r\n            let secondOutline=controlpoints[1]\r\n            let p1=control_points[k][firstOutline[0].order][firstOutline[0].index]\r\n            let vec1=[p1[0]-start.x,p1[1]-start.y]\r\n            let dot=vec1[0]*norm[0]+vec1[1]*norm[1]\r\n\r\n            let firstMidpoint=firstOutline.length/2\r\n            let secondMidpoint=secondOutline.length/2\r\n\r\n            if(dot>0){\r\n                //same direction with firstOutline\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n\r\n            }\r\n            else{\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n            }\r\n\r\n            //apply changes to energy field\r\n\r\n\r\n\r\n        let drawPathData=\"\";\r\n        for(let j = 0;j < control_points[k].length; j ++){\r\n            drawPathData += lineFunction(control_points[k][j]);\r\n        }\r\n        this.reDraw(k,this,drawPathData)\r\n\r\n\r\n    }\r\n\r\n    handleEdgeWidth(event, element){\r\n        event.stopPropagation()\r\n        let that = this\r\n        that.selectedEdge=parseInt(d3.select(element).attr(\"index\"))\r\n        that.setState({\r\n            hasSelectEdge:true\r\n        })\r\n        d3.select(\"svg\").selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(element).attr(\"index\"))==that.selectedEdge\r\n            })\r\n            .attr(\"stroke\",\"red\")\r\n            .attr(\"opacity\",1)\r\n    }\r\n\r\n    drawEdges(){\r\n        d3.select(\"#mainsvg\").selectAll(\"line\").remove()\r\n        let that=this\r\n\r\n        function handleClick(event){\r\n            event.stopPropagation()\r\n            that.selectedEdge=parseInt(d3.select(this).attr(\"index\"))\r\n            that.setState({\r\n                hasSelectEdge:true\r\n            })\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",1)\r\n        }\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                let vend\r\n                for (let v=0;v<vpoints.length;v++){\r\n                    vend=vpoints[v]\r\n                    g.append(\"line\")\r\n                        .attr(\"x1\",vstart[0])\r\n                        .attr(\"y1\",vstart[1])\r\n                        .attr(\"x2\",vend[0])\r\n                        .attr(\"y2\",vend[1])\r\n                        .attr(\"index\",index)\r\n                        .attr(\"stroke-width\",3)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"opacity\",0)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",1)\r\n                        })\r\n                        .on(\"mouseout\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",0)\r\n                        })\r\n                        .on(\"click\",handleClick)\r\n                    vstart=vend\r\n                }\r\n                vend=[this.pointData[end].x,this.pointData[end].y]\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n            else{\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",this.pointData[start].x)\r\n                    .attr(\"y1\",this.pointData[start].y)\r\n                    .attr(\"x2\",this.pointData[end].x)\r\n                    .attr(\"y2\",this.pointData[end].y)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    calEdgeLength(){\r\n        let minlength=Number.MAX_VALUE\r\n        let maxlength=Number.MIN_VALUE\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let startpoint=this.pointData[this.edges[i].start]\r\n            let endpoint=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vpoint=this.edges[i].virtrualNodes\r\n                let nowp\r\n                let nextp\r\n                let edgelength=0\r\n                nowp=[startpoint.x,startpoint.y]\r\n                for (let i=0;i<vpoint.length;i++){\r\n                    nextp=vpoint[i]\r\n                    edgelength+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                    nowp=nextp\r\n                }\r\n                edgelength+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let edgelength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n        this.maxEdgeLength=maxlength\r\n        this.minEdgeLength=minlength\r\n\r\n    }\r\n\r\n    componentWillUpdate(nextProps, nextState, nextContext) {\r\n    }\r\n\r\n    findOutLine(){\r\n        for (var k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n        intervals=[0.01]\r\n        console.time(\"isoline\")\r\n\r\n        // total field to active region\r\n        let fieldData = {}\r\n        for(var k in this.catEnergyField){\r\n            fieldData[k] = []\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let i = 0\r\n            for(let y = startY; y < endY; y ++){\r\n                fieldData[k].push([])\r\n                for(let x = startX; x < endX; x ++){\r\n                    fieldData[k][i].push(this.catEnergyField[k].finalField[y][x])\r\n                }\r\n                i ++\r\n            }\r\n        }\r\n\r\n        let isoDict=this.calISOLine(intervals, fieldData)\r\n\r\n        //console.log(isoDict)\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {};\r\n\r\n\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].boundingX\r\n            let dy=this.catEnergyField[k].boundingY\r\n            let prelength = 0\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                let sk = skipPoint\r\n                if(isoDict[k][i].length < 30){\r\n                    //continue;\r\n                }\r\n                if(isoDict[k][i].length < 50){\r\n                    //sk = 1\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n\r\n                    if(prelength==0){\r\n                        tmp_polygon[k].selectidx = []\r\n                        control_points[k] = []\r\n                    }\r\n\r\n                    tmp_polygon[k].selectidx.push(tmp_polygon[k].length - 1)\r\n\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n\r\n                    let curlen = control_points[k].length\r\n                    control_points[k][curlen] = [];\r\n                    control_points[k][curlen] = polygon;\r\n\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                    prelength ++\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        console.timeEnd(\"isoline\")\r\n\r\n        console.time(\"remove isoline\")\r\n        //console.log(tmp_polygon)\r\n\r\n        for(let k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k] = []\r\n        }\r\n\r\n\r\n        //remove_Polys = {}\r\n\r\n        for(var k in isoDict){\r\n            //let dx=this.catEnergyField[k].boundingX\r\n            //let dy=this.catEnergyField[k].boundingY\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                let isthis = false\r\n                for(let j = 0;j < sidx.length; j ++){\r\n                    if(i == sidx[j]){\r\n                        isthis = true\r\n                        break\r\n                    }\r\n                }\r\n                if(isthis){\r\n                    continue\r\n                }\r\n                let flag = true;\r\n                for(let p = 0; p < sidx.length; p ++){\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx[p]]);\r\n                        if(flag == false){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n\r\n                    if(AreaCal(tmp_polygon[k][i]) < minItemArea){\r\n                        continue\r\n                    }\r\n\r\n                    let st_idx = 0\r\n                    let pt_len = tmp_polygon[k][i].length\r\n                    let j_pt = [-1,-1]\r\n                    while(st_idx < pt_len){\r\n                        let idx1 = (st_idx - 1 + pt_len) % pt_len\r\n                        let idx2 = (st_idx + 1) % pt_len\r\n                        let ve1 = [tmp_polygon[k][i][idx1][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx1][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve2 = [tmp_polygon[k][i][idx2][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx2][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve3 = [ve1[0] + ve2[0], ve1[1] + ve2[1]]\r\n                        let ve3_len = Math.sqrt(ve3[0] * ve3[0] + ve3[1] * ve3[1])\r\n                        if(ve3_len != 0){\r\n                            ve3 = [ve3[0] / ve3_len, ve3[1] / ve3_len]\r\n                        }\r\n                        let test_pt = [tmp_polygon[k][i][st_idx][0] + 2 * ve3[0], tmp_polygon[k][i][st_idx][1] + 2 * ve3[1]]\r\n                        if(IsoInsideTest(test_pt, tmp_polygon[k][i])){\r\n                            j_pt = [test_pt[0], test_pt[1]]\r\n                            break;\r\n                        }\r\n                        st_idx ++\r\n                    }\r\n\r\n                    let is_use_inner = true\r\n\r\n                    if(j_pt[0] != -1 && j_pt[1] != -1){\r\n                        //if(k==\"2\"){\r\n                        //  g.append(\"circle\")\r\n                        //      .attr(\"cx\",j_pt[0])\r\n                        //      .attr(\"cy\",j_pt[1])\r\n                        //      .attr(\"r\",3)\r\n                        //      .attr(\"fill\",\"black\")\r\n//\r\n                        //}\r\n\r\n                        let j_y = parseInt((j_pt[1] -this.catEnergyField[k].y) / pixelGroup)\r\n                        let j_x = parseInt((j_pt[0] -this.catEnergyField[k].x) / pixelGroup)\r\n                        //if(k==\"2\"){\r\n                        //    console.log(\"inner outline!\")\r\n                        //    console.log(\"(\" + j_pt[0] + \", \" + j_pt[1] + \")\")\r\n                        //    console.log(this.catEnergyField[\"2\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].edgeIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].edgeIndexMap[j_y][j_x])\r\n                        //}\r\n                        //console.log(\"inner outline!\")\r\n                        //console.log(this.catEnergyField[k].field[j_y][j_x])\r\n                        //console.log(this.catEnergyField[k].finalField[j_y][j_x])\r\n                        if(this.catEnergyField[k].finalField[j_y][j_x] > 0.01){\r\n                            is_use_inner = false\r\n                        }\r\n                    }\r\n\r\n                    if(!is_use_inner){\r\n                        continue\r\n                    }\r\n\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n                /*\r\n                else{\r\n                    recal = true\r\n                    if(!remove_Polys.hasOwnProperty(k)){\r\n                        remove_Polys[k] = []\r\n                    }\r\n                    let tmp_polygon = []\r\n                    let sub_polygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j ++){\r\n                        let realx = isoDict[k][i][j][0]*pixelGroup + dx\r\n                        let realy = isoDict[k][i][j][1]*pixelGroup + dy\r\n                        sub_polygon.push([realx, realy])\r\n                        let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                        let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n                        tmp_polygon.push([x, y])\r\n                    }\r\n                    remove_Polys[k].push(tmp_polygon)\r\n                    this.fillPolygon(sub_polygon, k, 0, true)\r\n                }\r\n\r\n                 */\r\n            }\r\n        }\r\n        console.timeEnd(\"remove isoline\")\r\n\r\n    }\r\n\r\n    calOutLine(){\r\n\r\n        //if(recal && recalNum == 0){\r\n        //    recalNum += 1\r\n        //    for(let k in remove_Polys){\r\n        //        this.recalFinalEnergeField(k)\r\n        //    }\r\n        //}\r\n//\r\n        //if(this.firstFlag){\r\n        //    this.firstFlag = false\r\n        //    this.createGapInBoundary()\r\n        //}\r\n\r\n\r\n        //this.findOutLine()\r\n\r\n        let path_Info = {}\r\n\r\n        for(var k in this.catEnergyField){\r\n            path_Info[k] = []\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                path_Info[k].push(lineFunction(control_points[k][i]))\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        console.log(\"path_info!!!\")\r\n        console.log(JSON.stringify(path_Info))\r\n\r\n        for (var k in control_points){\r\n            initialControlPoints[k]=[]\r\n            for (let i=0;i<control_points[k].length;i++){\r\n                initialControlPoints[k][i]=[]\r\n                for (let j=0;j<control_points[k][i].length;j++){\r\n                    initialControlPoints[k][i].push([])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][0])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][1])\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    loadEdgeData(){\r\n        //let that=this\r\n        //fetch('/data/'+edgeDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n                //this.edges=data\r\n                console.time(\"Total Time\")\r\n\r\n                this.centralizeData(true)\r\n\r\n\r\n                // this.drawEdges()\r\n                this.calEdgeLength()\r\n                this.calActiveRegion(true)\r\n\r\n                console.time(\"cal energe\")\r\n                this.calEnergyField()\r\n                console.timeEnd(\"cal energe\")\r\n\r\n                console.time(\"cal final energe\")\r\n                //this.calFinalEnergeFieldV2()\r\n                this.calFinalEnergeField()\r\n                console.timeEnd(\"cal final energe\")\r\n\r\n                console.time(\"fill cross edge\")\r\n                this.fillCrossingEdge()\r\n                console.timeEnd(\"fill cross edge\")\r\n\r\n\r\n                console.time(\"create gap\")\r\n                this.createGapInBoundary()\r\n                console.timeEnd(\"create gap\")\r\n\r\n                //console.time(\"smooth\")\r\n                // this.smoothEnergyField()\r\n                //console.timeEnd(\"smooth\")\r\n\r\n                // for(let k in this.catPointDict){\r\n                //    this.drawEnergyField(k);\r\n                // }\r\n\r\n\r\n\r\n                d3.select(\"svg\").selectAll(\"*\").remove()\r\n                g = d3.select('svg').append(\"g\")\r\n\r\n                //g.append(\"image\")\r\n                //    .attr(\"x\",-42)\r\n                //    .attr(\"y\",-42)\r\n                //    .attr(\"width\",995)\r\n                //    .attr(\"height\",1350)\r\n                //    .attr(\"xlink:href\",\"/data/background/Manhatton.jpg\")\r\n\r\n                recal = false\r\n                recalNum = 0\r\n\r\n                this.findOutLine()\r\n                this.calOutLine()\r\n\r\n                /*\r\n\r\n                // re-cal the energy field for inner outline\r\n                for (var k in this.catEnergyField){\r\n                    this.catEnergyField[k].tfinalField = []\r\n                    for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                        this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                        for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                            let val = this.catEnergyField[k].finalField[y][x];\r\n                            if(IsoInsideTest([x, y], polygontest[k])){\r\n                                //console.log(\"test!!\")\r\n                                if(val > 0){\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                                }\r\n                                else{\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                                }\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].finalField[y][x] = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                let isoLineDict={}\r\n                for (var k in this.catEnergyField){\r\n                    var isoLines = [];\r\n                    isoLines=MarchingSquaresJS\r\n                        .isoLines(this.catEnergyField[k].tfinalField,\r\n                            intervals,\r\n                            {\r\n                                polygons: false,\r\n                                linearRing: false,\r\n                                noFrame:true\r\n                            }\r\n                        )\r\n                    isoLineDict[k]=isoLines[0]\r\n                }\r\n\r\n                for (var k in isoLineDict){\r\n                    //console.log(isoLineDict[k])\r\n                    let dx=this.catEnergyField[k].x\r\n                    let dy=this.catEnergyField[k].y\r\n                    for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                        if(isoLineDict[k][i].length < 30){\r\n                            continue;\r\n                        }\r\n                        let curlen = control_points[k].length;\r\n                        control_points[k][curlen] = [];\r\n                        for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                            control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                        }\r\n                        let meandis = 0;\r\n                        let sz = control_points[k][curlen].length;\r\n                        for(let j = 0; j < sz; j ++){\r\n                            meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                                control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                        }\r\n                        meandis /= sz\r\n                        control_points[k][curlen].meandis = meandis;\r\n                    }\r\n                    //this.drawEnergyField(k);\r\n                }\r\n\r\n                 */\r\n\r\n                //this.drawEnergyField(\"2\")\r\n                //this.drawEnergyField(\"3\")\r\n\r\n                this.calEdgeControlPoints()\r\n\r\n\r\n\r\n                this.drawEdges()\r\n                this.drawPointData()\r\n\r\n                //for(let k in this.catEnergyField){\r\n                //    this.drawEnergyField(k)\r\n                //}\r\n\r\n                console.timeEnd(\"Total Time\")\r\n\r\n                let that=this\r\n                function handleSvgClick(){\r\n                    console.log(\"click svg!\")\r\n                    d3.select(\"svg\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                        .attr(\"opacity\",0)\r\n                    that.selectedEdge=-1\r\n                    that.setState({\r\n                        hasSelectEdge:false,\r\n                        edgeWidth:defaultEdgeWidth\r\n                    })\r\n                }\r\n                        d3.select(\"svg\")\r\n                            .on(\"click\",handleSvgClick)\r\n\r\n            //})\r\n    }\r\n\r\n    afterEditReDraw(){\r\n\r\n        this.pointData = this.props.pointData\r\n\r\n        this.edges = this.props.edges\r\n\r\n        this.drawEdges()\r\n\r\n        this.drawPointData()\r\n\r\n        let that=this\r\n\r\n        function handleSvgClick(){\r\n            console.log(\"click svg!\")\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n    }\r\n\r\n    calActiveRegion(flag){\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(flag || !this.catEnergyField.hasOwnProperty(k)){\r\n                this.catEnergyField[k]={}\r\n                //console.log(\"calActiveRegion:\")\r\n                //console.log(k)\r\n            }\r\n\r\n            let maxx=this.catPointDict[k].maxX\r\n            let minx=this.catPointDict[k].minX\r\n            let maxy=this.catPointDict[k].maxY\r\n            let miny=this.catPointDict[k].minY\r\n\r\n            //console.log(\"active region: \")\r\n            //console.log([maxx, minx, maxy, miny])\r\n\r\n            this.catEnergyField[k].boundingX=minx-Math.max(nodeR1,edgeR1)-buffer\r\n            this.catEnergyField[k].boundingY=miny-Math.max(nodeR1,edgeR1)-buffer\r\n\r\n            this.catEnergyField[k].boundingWidth=Math.ceil((maxx-minx+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n            this.catEnergyField[k].boundingHeight=Math.ceil((maxy-miny+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n\r\n            if(flag || !this.catEnergyField[k].hasOwnProperty(\"field\")){\r\n\r\n                let centerX = this.catEnergyField[k].boundingX + 0.5 * this.catEnergyField[k].boundingWidth\r\n                let centerY = this.catEnergyField[k].boundingY + 0.5 * this.catEnergyField[k].boundingHeight\r\n\r\n                this.catEnergyField[k].x = parseInt((centerX - 0.5 * svgwidth))\r\n                this.catEnergyField[k].y = parseInt((centerY - 0.5 * svgheight))\r\n\r\n                this.catEnergyField[k].width = parseInt(svgwidth / pixelGroup)\r\n                this.catEnergyField[k].height = parseInt(svgheight / pixelGroup)\r\n\r\n                this.catEnergyField[k].field=[]\r\n                this.catEnergyField[k].barrierMap=[]\r\n                for (let i=0;i<svgheight;i++){\r\n                    this.catEnergyField[k].field.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].barrierMap.push(new Array(svgwidth).fill(0))\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.hasBubbles = true\r\n\r\n    }\r\n\r\n    calDistanceToItem(x,y,item){\r\n        //TODO: Rectangle items\r\n        //inside is 0\r\n        if(itemEnergyShape==\"circle\"){\r\n            let dis=calDistance(x,y,item.x,item.y)\r\n            if(dis<item.radius){\r\n                return 0\r\n            }\r\n            else{\r\n                return dis-item.radius\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    getPointEdgeDistance(lx1, ly1, lx2, ly2, x, y) {\r\n        var x1 = lx1;\r\n        var y1 = ly1;\r\n        var x2 = lx2 - x1;\r\n        var y2 = ly2 - y1;\r\n        var px = x - x1;\r\n        var py = y - y1;\r\n        var dotprod = px * x2 + py * y2;\r\n        var projlenSq;\r\n        if(dotprod <= 0) {\r\n            projlenSq = 0;\r\n        } else {\r\n            px = x2 - px;\r\n            py = y2 - py;\r\n            dotprod = px * x2 + py * y2;\r\n            if(dotprod <= 0) {\r\n                projlenSq = 0;\r\n            } else {\r\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\r\n            }\r\n        }\r\n        var lenSq = px * px + py * py - projlenSq;\r\n        if(lenSq < 0) {\r\n            lenSq = 0;\r\n        }\r\n        return Math.sqrt(lenSq);\r\n    }\r\n\r\n    calDistanceToEdgeV2(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint, endpoint\r\n        if(edge.flag == false){\r\n            startpoint = edge.startpoint\r\n            endpoint = edge.endpoint\r\n        }\r\n        else{\r\n            startpoint=this.pointData[edge.start]\r\n            endpoint=this.pointData[edge.end]\r\n        }\r\n        if(edge.virtrual && edge.virtrualNodes.length > 0){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1*ep[1]]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calDistanceToEdge(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint=this.pointData[edge.start]\r\n        let endpoint=this.pointData[edge.end]\r\n        if(edge.virtrual){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1*ep[1]]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    isRectIntersects (rect1,rect2) {\r\n        if(rect1.width <= 0 || rect1.height <= 0 || rect2.width <= 0 || rect2.height <= 0) return false;\r\n        return (rect2.maxX > rect1.minX &&\r\n            rect2.maxY > rect1.minY &&\r\n            rect2.minX < rect1.maxX &&\r\n            rect2.minY < rect1.maxY);\r\n    };\r\n\r\n    isThisCat(point,cat){\r\n        let catarr=point.catArray\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    LabelGroupElement(){\r\n        let maxpdis = nodeR1 * 2\r\n        for(let k1 in this.catPointDict){\r\n\r\n            // cal for points\r\n            for(let i = 0;i < this.catPointDict[k1].length; i ++){\r\n                if(this.catPointDict[k1][i].isGroup==false){\r\n                    continue;\r\n                }\r\n                let isgroup = true;\r\n                let x1 = this.catPointDict[k1][i].x;\r\n                let y1 = this.catPointDict[k1][i].y;\r\n                for(let k2 in this.catPointDict){\r\n//\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n//\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(calDistance(x1,y1,x2,y2) < maxpdis + this.catPointDict[k2][j].radius + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n//\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    // cal edge\r\n                    if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                        continue;\r\n                    }\r\n                    for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                        if(this.calDistanceToEdge(x1,y1,this.catEdgeDict[k2][j])[0] < maxpdis + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catEdgeDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n                }\r\n                this.catPointDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n            // cal for edges\r\n            if(!this.catEdgeDict.hasOwnProperty(k1)){\r\n                continue;\r\n            }\r\n            for(let i = 0;i < this.catEdgeDict[k1].length;i ++){\r\n                let s1 = this.pointData[this.catEdgeDict[k1][i].start];\r\n                let e1 = this.pointData[this.catEdgeDict[k1][i].end];\r\n                if(this.catEdgeDict[k1][i].isGroup == false){\r\n                    continue;\r\n                }\r\n                let isgroup = true\r\n                for(let k2 in this.catPointDict){\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(this.calDistanceToEdge(x2,y2,this.catEdgeDict[k1][i])[0] < maxpdis + this.catPointDict[k2][j].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    //// cal edge\r\n                    //if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                    //    continue;\r\n                    //}\r\n                    //for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                    //    let s2 = this.pointData[this.catEdgeDict[k2][j].start];\r\n                    //    let e2 = this.pointData[this.catEdgeDict[k2][j].end];\r\n                    //    if(this.checkEdgeCrossing(s1,e1,s2,e2)[0]){\r\n                    //        isgroup = false;\r\n                    //        this.catEdgeDict[k2][j].isGroup = false;\r\n                    //        break;\r\n                    //    }\r\n                    //}\r\n                    //if(isgroup==false){\r\n                    //    break;\r\n                    //}\r\n//\r\n                }\r\n                this.catEdgeDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField_Part(updatePoints, updateEdges){\r\n\r\n        //console.log(\"calEnergyField_Part:\")\r\n        //console.log(updateEdges)\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(!this.catEnergyField[k].hasOwnProperty(\"finalField\")){\r\n                // group attrs\r\n                this.catPointDict[k].pointMap=[]\r\n                this.catEnergyField[k].pointBarrierMap=[]\r\n                this.catEnergyField[k].edgeBarrierMap=[]\r\n                this.catEnergyField[k].pointIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap2=[]\r\n                this.catEnergyField[k].finalField = []\r\n                this.catEnergyField[k].subUpdate = []\r\n\r\n                for (let y=0;y<svgheight;y++){\r\n                    this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                    this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n\r\n                    this.catEnergyField[k].edgeIndexMap2.push([])\r\n                    for(let x=0;x<svgwidth;x++){\r\n                        this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for(var k in this.catPointDict){\r\n\r\n            if(!updatePoints.hasOwnProperty(k)){\r\n                updatePoints[k] = []\r\n            }\r\n\r\n            if(!updateEdges.hasOwnProperty(k)){\r\n                updateEdges[k] = []\r\n            }\r\n\r\n            let members = updatePoints[k]\r\n\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                //this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n\r\n                            if(members[i].flag == false){\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.01 || this.catEnergyField[k].edgeIndexMap[y][x] == -1){\r\n                                    this.catEnergyField[k].field[y][x] = 0\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=-1\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                            }\r\n                            else{\r\n\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                        if(members[i].flag == true){\r\n\r\n                            if(distance<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=1\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                                }\r\n                            }\r\n\r\n                            if(distance<=fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=3\r\n                                //this.catPointDict[k].pointMap[i].push([x,y])\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n            console.log(this.maxEdgeLength)\r\n            // cal positive value of edges\r\n            let edges=updateEdges[k]\r\n            edges.sort(function(a,b){\r\n                return a.flag - b.flag\r\n            })\r\n            //console.log(\"Sort Edegs:\")\r\n            //console.log(edges)\r\n            for (let i=0;i<edges.length;i++){\r\n                // cal positive value for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                let startid=edges[i].start\r\n                let endid=edges[i].end\r\n                startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToEdgeV2(realx,realy,edges[i])\r\n                        let distancetoEdge=distance[0]\r\n                        let distancetoNode=distance[1]\r\n                        let totalDistance=distance[2]\r\n\r\n                        if(distancetoNode<0){\r\n                            continue\r\n                        }\r\n\r\n                        if(distancetoEdge<edgeR1+fixdis){\r\n                            let newR1=edgeR1\r\n                            let reducefactor=edgeR1/10\r\n                            let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                            if(totalDistance>EDGELENGTH_THRESH){\r\n                                newR1=2*edgeR1/(1+factor*distancetoNode)\r\n                            }\r\n                            if(newR1>edgeR1){\r\n                                newR1=edgeR1\r\n                            }\r\n\r\n                            if(newR1>2*nodeR1){\r\n                                newR1=2*nodeR1\r\n                            }\r\n                            let energy\r\n                            if(distancetoEdge>newR1){\r\n                                energy=0\r\n                            }\r\n                            else{\r\n                                energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                            }\r\n\r\n\r\n                            if(edges[i].flag == true){\r\n                                let preenergy = this.catEnergyField[k].finalField[y][x]\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                let delflag = false\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x] == -1 && this.catEnergyField[k].edgeIndexMap2[y][x].length == 1){\r\n                                    if(this.catEnergyField[k].edgeIndexMap2[y][x][0].start == startid && this.catEnergyField[k].edgeIndexMap2[y][x][0].end == endid){\r\n                                        delflag = true\r\n                                    }\r\n                                }\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.01 || delflag){\r\n                                    this.catEnergyField[k].field[y][x]=0\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                    for(let it = this.catEnergyField[k].edgeIndexMap2[y][x].length - 1; it >= 0 ; it --){\r\n                                        let s = this.catEnergyField[k].edgeIndexMap2[y][x][it].start\r\n                                        let e = this.catEnergyField[k].edgeIndexMap2[y][x][it].end\r\n                                        if(s==startid&&e==endid){\r\n                                            this.catEnergyField[k].edgeIndexMap2[y][x].splice(it,1)\r\n                                        }\r\n                                    }\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                                //if(this.catEnergyField[k].pointIndexMap[y][x] != -1){\r\n                                //    this.catEnergyField[k].barrierMap[y][x]=this.catEnergyField[k].pointBarrierMap[y][x]\r\n                                //    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                //    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                //}\r\n                            }\r\n\r\n                        }\r\n\r\n                        /*\r\n                        let startpoint=this.pointData[startid]\r\n                        let endpoint=this.pointData[endid]\r\n\r\n                        if(startpoint.multicat&&endpoint.multicat){\r\n                            let hasSameCat=false\r\n                            let samecat=-1\r\n                            for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                let cat1=startpoint.catArray[c1]\r\n                                if(cat1!=k){\r\n                                    for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                        let cat2=endpoint.catArray[c2]\r\n                                        if(cat2!=k){\r\n                                            if(cat2==cat1){\r\n                                                hasSameCat=true\r\n                                                samecat=cat1\r\n                                                break\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                            if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                if(distancetoEdge<edgeR1+20+fixdis){\r\n                                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                    let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                    let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                    let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                    // let energyscale=100\r\n\r\n                                    if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                        this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                        this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        */\r\n\r\n                        if(edges[i].flag == true){\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField(){\r\n\r\n        //TODO: edge and node use different barrier map\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            // group attrs\r\n            this.catPointDict[k].pointMap=[]\r\n            this.catEnergyField[k].pointBarrierMap=[]\r\n            this.catEnergyField[k].edgeBarrierMap=[]\r\n            this.catEnergyField[k].pointIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap2=[]\r\n            this.catEnergyField[k].finalField = []\r\n            this.catEnergyField[k].subUpdate = []\r\n\r\n            for (let y=0;y<svgheight;y++){\r\n                this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap2.push([])\r\n                for(let x=0;x<svgwidth;x++){\r\n                    this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                }\r\n            }\r\n\r\n            //// not group attrs\r\n            //this.catPointDict[k].gpointMap=[]\r\n            //this.catEnergyField[k].gpointBarrierMap=[]\r\n            //this.catEnergyField[k].gedgeBarrierMap=[]\r\n            //this.catEnergyField[k].gpointIndexMap=[]\r\n            //this.catEnergyField[k].gedgeIndexMap=[]\r\n//\r\n            //for(let y=0;y<this.catEnergyField[k].gheight;y++){\r\n            //    this.catEnergyField[k].gpointBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gedgeBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gpointIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //    this.catEnergyField[k].gedgeIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //}\r\n\r\n\r\n        }\r\n\r\n        // cal bbox of edges\r\n        // fix to cal at this.centralizeData()\r\n\r\n        // cal the real active region\r\n        //this.LabelGroupElement()\r\n\r\n        for(var k in this.catPointDict){\r\n            let members=this.catPointDict[k]\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                            this.catEnergyField[k].field[y][x]+=energy\r\n                            if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                this.catEnergyField[k].barrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n                        }\r\n                        if(point.multicat){\r\n                            let catarr=point.catArray\r\n                            for (let c=0;c<catarr.length;c++){\r\n                                if(catarr[c]!=k&&parseInt(catarr[c])<parseInt(k)){\r\n                                    if(distance<nodeR1+10){\r\n                                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[catarr[c]].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[catarr[c]].y)/pixelGroup)\r\n                                        let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[catarr[c]].width&&relativey<this.catEnergyField[catarr[c]].height){\r\n                                            // this.catEnergyField[catarr[c]].field[relativey][relativex]+=energy\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if(distance<=barrierGap+fixdis){\r\n                            if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].barrierMap[y][x]=1\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                            }\r\n                        }\r\n\r\n                        if(distance<=fixdis){\r\n                            //inside\r\n                            this.catEnergyField[k].barrierMap[y][x]=3\r\n                            this.catPointDict[k].pointMap[i].push([x,y])\r\n                            this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                            this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            // let EDGELENGTH_THRESH=(this.maxEdgeLength+this.minEdgeLength)/3\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/2\r\n            // let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n\r\n            // cal positive value of edges\r\n            if(this.catEdgeDict.hasOwnProperty(k)){\r\n                let edges=this.catEdgeDict[k]\r\n                for (let i=0;i<edges.length;i++){\r\n                    // cal positive value for pixel group\r\n                    let startx\r\n                    let endx\r\n                    let starty\r\n                    let endy\r\n                    let startid=edges[i].start\r\n                    let endid=edges[i].end\r\n                    startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                    endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                    starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                    endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                    for (let y=starty;y<endy;y++){\r\n                        for (let x=startx;x<endx;x++){\r\n                            let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                            let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                            let distance=this.calDistanceToEdge(realx,realy,edges[i])\r\n                            let distancetoEdge=distance[0]\r\n                            let distancetoNode=distance[1]\r\n                            let totalDistance=distance[2]\r\n\r\n                            if(distancetoNode<0){\r\n                                continue\r\n                            }\r\n\r\n                            if(distancetoEdge<edgeR1+fixdis){\r\n                                let newR1=edgeR1\r\n                                // let factor=(edgeR1-2)/this.maxEdgeLength\r\n                                let reducefactor=edgeR1/10\r\n                                let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                                if(totalDistance>EDGELENGTH_THRESH){\r\n                                    newR1=2*edgeR1/(1+factor*distancetoNode)\r\n\r\n\r\n                                    // newR1=2*edgeR1/(1+factor*distancetoNode/4)\r\n\r\n                                    // weight=1-Math.pow(factor,2)\r\n                                    // let factor=2*(Math.exp(2)-1)/this.maxEdgeLength\r\n                                    // weight=1/(Math.log(1+factor*distancetoNode)+2)\r\n\r\n                                    // weight=weight*2\r\n                                }\r\n                                if(newR1>edgeR1){\r\n                                    newR1=edgeR1\r\n                                }\r\n\r\n                                if(newR1>2*nodeR1){\r\n                                    newR1=2*nodeR1\r\n                                }\r\n                                let energy\r\n                                if(distancetoEdge>newR1){\r\n                                    energy=0\r\n                                }\r\n                                else{\r\n                                    energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                }\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n\r\n                            }\r\n\r\n                            let startpoint=this.pointData[startid]\r\n                            let endpoint=this.pointData[endid]\r\n\r\n                            if(startpoint.multicat&&endpoint.multicat){\r\n                                let hasSameCat=false\r\n                                let samecat=-1\r\n                                for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                    let cat1=startpoint.catArray[c1]\r\n                                    if(cat1!=k){\r\n                                        for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                            let cat2=endpoint.catArray[c2]\r\n                                            if(cat2!=k){\r\n                                                if(cat2==cat1){\r\n                                                    hasSameCat=true\r\n                                                    samecat=cat1\r\n                                                    break\r\n                                                }\r\n                                            }\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                                if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                    if(distancetoEdge<edgeR1+20+fixdis){\r\n                                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                        let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                        // let energyscale=100\r\n\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                            this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                            this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                            this.catEnergyField[samecat].edgeIndexMap2[relativey][relativex].push({start:startpoint.id, end:endpoint.id})\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    checkEdgeCrossing(a, b, c, d){\r\n\r\n        // 三角形abc 面积的2倍\r\n        var area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\r\n\r\n        // 三角形abd 面积的2倍\r\n        var area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);\r\n\r\n        // 面积符号相同则两点在线段同侧,不相交 (对点在线段上的情况,本例当作不相交处理);\r\n        if ( area_abc*area_abd>=0 ) {\r\n            return [false];\r\n        }\r\n\r\n        // 三角形cda 面积的2倍\r\n        var area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);\r\n        // 三角形cdb 面积的2倍\r\n        // 注意: 这里有一个小优化.不需要再用公式计算面积,而是通过已知的三个面积加减得出.\r\n        var area_cdb = area_cda + area_abc - area_abd ;\r\n        if (  area_cda * area_cdb >= 0 ) {\r\n            return [false];\r\n        }\r\n\r\n        //计算交点坐标\r\n        var t = area_cda / ( area_abd- area_abc );\r\n        var dx= t*(b.x - a.x),\r\n            dy= t*(b.y - a.y);\r\n        return[true, { x: a.x + dx , y: a.y + dy }];\r\n\r\n    }\r\n\r\n    createGapInBoundary(){\r\n        let gap=this.state.gapBetween\r\n        if(gap==0)\r\n            return\r\n        for (var k in this.catEnergyField){\r\n            let field=this.catEnergyField[k].finalField\r\n            let deletePoints=[]\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    if(field[y][x]==0){\r\n                        continue\r\n                    }\r\n\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4)\r\n                        continue\r\n\r\n                    //check if it is the boundary\r\n                    let isboundary=false\r\n                    for (let i=0;i<gap;i++){\r\n                        let delta=i+1\r\n                        //right\r\n                        if(x+delta<this.catEnergyField[k].width){\r\n                            if(field[y][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left\r\n                        if(x-delta>0){\r\n                            if(field[y][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //up\r\n                        if(y-delta>0){\r\n                            if(field[y-delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //down\r\n                        if(y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-top\r\n                        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n                            if(field[y-delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-bottom\r\n                        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-top\r\n                        if(x-delta>0&&y-delta>0){\r\n                            if(field[y-delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-bottom\r\n                        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(isboundary){\r\n                        // this.catEnergyField[k].finalField[y][x]=0\r\n                        deletePoints.push([x,y])\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for (let i=0;i<deletePoints.length;i++){\r\n                let x=deletePoints[i][0]\r\n                let y=deletePoints[i][1]\r\n                this.catEnergyField[k].finalField[y][x]=0\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    removeEmptyZone(isoDict){\r\n\r\n        // for (var k in this.catEnergyField){\r\n        //     for (let y=0;y<this.catEnergyField[k].height;y++){\r\n        //         for (let x=0;x<this.catEnergyField[k].width;x++){\r\n        //             if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==4){\r\n        //                 this.catEnergyField[k].finalField[y][x]=0\r\n        //             }\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        for (var k in isoDict){\r\n            let isolines=isoDict[k]\r\n            let isolinepoints=[]\r\n            let finalField=this.catEnergyField[k].finalField\r\n            this.catEnergyField[k].isoLineMap=[]\r\n\r\n            for (let i=0;i<isolines.length;i++){\r\n                let relativepoints=[]\r\n                for (let p=0;p<isolines[i].length;p++){\r\n                    relativepoints.push({x:isolines[i][p][0], y:isolines[i][p][1]})\r\n                }\r\n                isolinepoints.push(relativepoints)\r\n            }\r\n\r\n            let isoInsidePoints=[]\r\n            for (let i=0;i<isolinepoints.length;i++){\r\n                isoInsidePoints.push([])\r\n            }\r\n\r\n            for (let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].isoLineMap.push([])\r\n                for (let x=0;x<this.catEnergyField[k].width;x++){\r\n                    this.catEnergyField[k].isoLineMap[y].push(-1)\r\n\r\n                    if(finalField[y][x]>0){\r\n                        for (let i=0;i<isolinepoints.length;i++){\r\n                            //check if it is inside the isoline\r\n                            let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},isolinepoints[i])\r\n                            if(intersect){\r\n                                isoInsidePoints[i].push([x,y])\r\n                                this.catEnergyField[k].isoLineMap[y][x]=i\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            let notDeleteIndex=[]\r\n            for (let i=0;i<this.catPointDict[k].pointMap.length;i++){\r\n                let nodePoints=this.catPointDict[k].pointMap[i]\r\n                let totalInside=true\r\n                let isolineIndex=-1\r\n\r\n                // if(k==\"5\"&&i==0){\r\n                //     console.log()\r\n                // }\r\n\r\n                for (let n=0;n<nodePoints.length;n++){\r\n                    let x=nodePoints[n][0]\r\n                    let y=nodePoints[n][1]\r\n                    if(n==0){\r\n                        if(this.catEnergyField[k].isoLineMap[y][x]>-1){\r\n                            isolineIndex=this.catEnergyField[k].isoLineMap[y][x]\r\n                        }\r\n                    }\r\n                    if(this.catEnergyField[k].isoLineMap[y][x]==-1||this.catEnergyField[k].isoLineMap[y][x]!=isolineIndex){\r\n                        totalInside=false\r\n                        break\r\n                    }\r\n\r\n                }\r\n\r\n                if(totalInside){\r\n                    notDeleteIndex.push(isolineIndex)\r\n                }\r\n\r\n            }\r\n\r\n            let deleteindex=[]\r\n\r\n            for(let i=0;i<isoInsidePoints.length;i++){\r\n                let isdelete=true\r\n                for (let j=0;j<notDeleteIndex.length;j++){\r\n                    if(i==notDeleteIndex[j]){\r\n                        isdelete=false\r\n                        break\r\n                    }\r\n                }\r\n                if(isdelete){\r\n                    deleteindex.push(i)\r\n                }\r\n            }\r\n\r\n\r\n            for (let i=0;i<deleteindex.length;i++){\r\n                let index=deleteindex[i]\r\n                let deletePoints=isoInsidePoints[index]\r\n\r\n                for(let p=0;p<deletePoints.length;p++){\r\n                    let x=deletePoints[p][0]\r\n                    let y=deletePoints[p][1]\r\n                    this.catEnergyField[k].finalField[y][x]=0\r\n                }\r\n            }\r\n\r\n            let newisolines=[]\r\n            for (let i=0;i<isolines.length;i++){\r\n                let isdelete=false\r\n                for (let j=0;j<deleteindex.length;j++){\r\n                    if(i==deleteindex[j]){\r\n                        isdelete=true\r\n                        break\r\n                    }\r\n\r\n                }\r\n                if(!isdelete){\r\n                    newisolines.push(isolines[i])\r\n                }\r\n\r\n            }\r\n\r\n            isoDict[k]=newisolines\r\n        }\r\n        console.log(isoDict)\r\n        return isoDict\r\n    }\r\n\r\n    isSameCat(catarr1,catarr2){\r\n        for(let i=0;i<catarr1.length;i++){\r\n            let cat1=catarr1[i]\r\n            for (let j=0;j<catarr2.length;j++){\r\n                let cat2=catarr2[j]\r\n                if(cat1==cat2){\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isContained(catarr,cat){\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calFinalEnergeFieldForOverlap(){\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = this.catEnergyField[k].field\r\n            for(let y in this.catNotGroup[k]){\r\n                //this.catEnergyField[k].finalField.push(new Array(this.catEnergyField[k].width).fill(0))\r\n                for(let x in this.catNotGroup[k][y]){\r\n                    y = parseInt(y);\r\n                    x = parseInt(x);\r\n                    let px = Math.ceil(x/pixelGroup)\r\n                    let py = Math.ceil(y/pixelGroup)\r\n                    let realx=x+this.catEnergyField[k].x\r\n                    let realy=y+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].gfield[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].gpointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].gedgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].gbarrierMap[y][x]==3||this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].gfield[y][x]==0){\r\n                        // drawRect(realx,realy,1,1,\"red\")\r\n                        value=1\r\n                        this.catEnergyField[k].gfield[y][x]=1\r\n                        this.catEnergyField[k].field[py][px]=1\r\n                    }\r\n\r\n\r\n                    /*                    if (!isInside&&value==0){\r\n                                            continue\r\n                                        }*/\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].x+this.catEnergyField[k2].gwidth&&realx>this.catEnergyField[k2].x&&realy<this.catEnergyField[k2].y+this.catEnergyField[k2].gheight&&realy>this.catEnergyField[k2].y){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x))\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y))\r\n\r\n                                let othervalue=this.catEnergyField[k2].gfield[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].gpointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].gedgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].gpointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].gbarrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].gbarrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[py][px]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[py][px]==4){\r\n                        this.catEnergyField[k].finalField[py][px]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateEnergyPoints(){\r\n        //update final energyfield according to this.updatedEnergyPoints\r\n        for (var k in this.updatedEnergyPoints){\r\n            for (let p=0;p<this.updatedEnergyPoints[k].length;p++){\r\n                let x=this.updatedEnergyPoints[k][p][0]\r\n                let y=this.updatedEnergyPoints[k][p][1]\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=this.catEnergyField[k].field[y][x]\r\n                // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                let finalvalue=value\r\n                let isInside=false\r\n\r\n                if(value == 0){\r\n                    continue;\r\n                }\r\n\r\n               if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    isInside=true\r\n                }\r\n\r\n                if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                    value=1\r\n                    this.catEnergyField[k].field[y][x]=1\r\n                }\r\n\r\n                if (value==0){\r\n                    // drawRect(realx,realy,1,1,\"black\")\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField){\r\n                    if(k2==k)\r\n                        continue\r\n\r\n                    if(k2!=k){\r\n                        if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                            let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                            let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                            let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                            let otherinside=false\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ){\r\n\r\n                                if(this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==1|| this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==3){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                otherinside=true\r\n                            }\r\n\r\n\r\n                            if (othervalue==0){\r\n                                // drawRect(realx,realy,1,1,\"black\")\r\n                                continue\r\n                            }\r\n\r\n                            // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                            // drawRect(realx,realy,1,1,\"blue\")\r\n                            if(!isInside&&!otherinside){\r\n\r\n                                if(othervalue>value){\r\n                                    finalvalue=0\r\n                                    // drawRect(realx,realy,2,2,\"red\")\r\n                                    // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                    break\r\n                                }\r\n                                else{\r\n                                    finalvalue=value\r\n                                }\r\n                                // finalvalue=0\r\n                                // finalvalue=value\r\n\r\n                            }\r\n                            else if(isInside&&!otherinside){\r\n                                // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                //pass\r\n\r\n                                finalvalue=value\r\n                            }\r\n                            else if(!isInside&&otherinside){\r\n                                // drawRect(realx,realy,2,2,\"black\")\r\n                                // drawRect(realx,realy,1,1,\"orange\")\r\n                                finalvalue=0\r\n                                break\r\n                            }\r\n                            else if(isInside&&otherinside){\r\n\r\n                                // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else{\r\n                                    finalvalue=0\r\n                                }\r\n                                // finalvalue=0\r\n\r\n\r\n                            }\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                            //     finalvalue=0\r\n                            // }\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                //if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                //    this.catEnergyField[k].finalField[y][x]=10000\r\n                //}\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calFinalEnergeField_Part(){\r\n\r\n        this.updateIdx = new Set(this.updateIdx)\r\n        //console.log(\"calFinalEnergeField_Part:\")\r\n        //console.log(this.updateIdx)\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = clone(this.catEnergyField[k].field)\r\n            for(let updateidx of this.updateIdx){\r\n\r\n\r\n                    let realx=parseInt(updateidx[1])\r\n                    let realy=parseInt(updateidx[0])\r\n\r\n\r\n                    //console.log(\"(\" + realx + \", \" + realy + \")\")\r\n\r\n                    let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                    let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n\r\n                    x = Math.min(x, this.catEnergyField[k].width - 1)\r\n                    y = Math.min(y, this.catEnergyField[k].height - 1)\r\n                    x = Math.max(x, 0)\r\n                    y = Math.max(y, 0)\r\n\r\n                    //d3.select('g').append('circle')\r\n                    //    .attr('id','final')\r\n                    //    .attr('cx',realx)\r\n                    //    .attr('cy',realy)\r\n                    //    .attr('r',1)\r\n                    //    .attr('fill','red')\r\n\r\n                    //console.log(\"(\" + this.catEnergyField[k].width + \", \" + this.catEnergyField[k].height + \")\")\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    //if(value == 0){\r\n                    //    continue\r\n                    //}\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside && this.catEnergyField[k].field[y][x] <= 0.01 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        value=1\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n        }\r\n\r\n    }\r\n\r\n    calFinalEnergeField(){\r\n\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n        for (var k in this.catEnergyField){\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        value=1\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<=this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>=this.catEnergyField[k2].boundingX&&realy<=this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>=this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n                                }\r\n\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    recalFinalEnergeField(preK){\r\n\r\n        let bounding = {}\r\n        for(let k in this.catEnergyField){\r\n            bounding[k] = {\r\n                minX : Number.MAX_VALUE,\r\n                minY : Number.MAX_VALUE,\r\n                maxX : Number.MIN_VALUE,\r\n                maxY : Number.MIN_VALUE\r\n            }\r\n        }\r\n\r\n        for (var k in this.catEnergyField){\r\n            if(k == preK){\r\n                continue\r\n            }\r\n            for(let p=0;p<this.updatedEnergyPoints[preK].length;p++) {\r\n\r\n                let realx = this.updatedEnergyPoints[preK][p][0] * pixelGroup + this.catEnergyField[preK].x\r\n                let realy = this.updatedEnergyPoints[preK][p][1] * pixelGroup + this.catEnergyField[preK].y\r\n\r\n                let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup);\r\n                let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup);\r\n\r\n\r\n                bounding[k].minX = Math.min(bounding[k].minX, x)\r\n                bounding[k].minY = Math.min(bounding[k].minY, y)\r\n                bounding[k].maxX = Math.max(bounding[k].maxX, x)\r\n                bounding[k].maxY = Math.max(bounding[k].maxY, y)\r\n\r\n                let value = this.catEnergyField[k].field[y][x]\r\n                let finalvalue = value\r\n                let isInside = false\r\n\r\n                let thisPointID = this.catEnergyField[k].pointIndexMap[y][x]\r\n                let thisEdgeID = this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                let thiscat\r\n\r\n                if (thisEdgeID == -1 && thisPointID == -1) {\r\n                    continue\r\n                }\r\n\r\n                if (thisEdgeID > -1) {\r\n                    if (this.pointData[thisEdgeID].multicat) {\r\n                        thiscat = this.pointData[thisEdgeID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisEdgeID].cat]\r\n                    }\r\n                }\r\n\r\n                if (thisPointID > -1) {\r\n                    if (this.pointData[thisPointID].multicat) {\r\n                        thiscat = this.pointData[thisPointID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisPointID].cat]\r\n                    }\r\n                }\r\n\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 3 || this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    isInside = true\r\n                }\r\n\r\n                if (isInside && this.catEnergyField[k].field[y][x] == 0) {\r\n                    this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                    this.catEnergyField[k].edgeIndexMap2[y][x].push({\r\n                        start: this.edges[thisEdgeID].start,\r\n                        end: this.edges[thisEdgeID].end\r\n                    })\r\n                    value = 1\r\n                    this.catEnergyField[k].field[y][x] = 1\r\n                }\r\n\r\n                if (value == 0) {\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField) {\r\n\r\n                    if (k2 == k)\r\n                        continue\r\n\r\n                    if(k2 == preK){\r\n                        // TODO : compare final value\r\n\r\n\r\n                        continue\r\n                    }\r\n\r\n                    if (realx <= this.catEnergyField[k2].boundingX + this.catEnergyField[k2].boundingWidth * pixelGroup && realx >= this.catEnergyField[k2].boundingX && realy <= this.catEnergyField[k2].boundingY + this.catEnergyField[k2].boundingHeight * pixelGroup && realy >= this.catEnergyField[k2].boundingY) {\r\n                        let relativex = Math.floor((realx - this.catEnergyField[k2].x) / pixelGroup)\r\n                        let relativey = Math.floor((realy - this.catEnergyField[k2].y) / pixelGroup)\r\n\r\n                        let othervalue = this.catEnergyField[k2].field[relativey][relativex]\r\n                        let otherinside = false\r\n                        let otherPointID = this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                        let otherEdgeID = this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                        let othercat\r\n\r\n                        if (otherPointID == -1 && otherEdgeID == -1) {\r\n                            continue\r\n                        }\r\n\r\n                        if (otherEdgeID > -1) {\r\n                            if (this.pointData[otherEdgeID].multicat) {\r\n                                othercat = this.pointData[otherEdgeID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherEdgeID].cat]\r\n                            }\r\n                        }\r\n\r\n                        if (otherPointID > -1) {\r\n                            if (this.pointData[otherPointID].multicat) {\r\n                                othercat = this.pointData[otherPointID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherPointID].cat]\r\n                            }\r\n                        }\r\n\r\n\r\n                        // if(aim){\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        // if(k==\"11\"&&k2==\"0\"){\r\n                        //         drawRect(realx,realy,1,1,\"red\")\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        if (this.isContained(othercat, k)) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // if(k==\"11\"&&k2==\"0\"){\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // }\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n                        }\r\n\r\n\r\n                        if (this.isContained(thiscat, k2) && this.catEnergyField[k2].pointBarrierMap[relativey][relativex] != 3) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n\r\n                        }\r\n\r\n                        if (this.catEnergyField[k2].barrierMap[relativey][relativex] == 3 || this.catEnergyField[k2].barrierMap[relativey][relativex] == 4) {\r\n                            otherinside = true\r\n                        }\r\n\r\n                        if (othervalue == 0) {\r\n                            continue\r\n                        }\r\n\r\n                        if (!isInside && !otherinside) {\r\n                            if (othervalue > value) {\r\n                                finalvalue = 0\r\n                                break\r\n                            } else {\r\n                                finalvalue = value\r\n                            }\r\n                        } else if (isInside && !otherinside) {\r\n                            finalvalue = value\r\n                        } else if (!isInside && otherinside) {\r\n                            finalvalue = 0\r\n                            break\r\n                        } else if (isInside && otherinside) {\r\n                           if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                                finalvalue = value\r\n                            } else {\r\n                                finalvalue = 0\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x] = finalvalue\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    this.catEnergyField[k].finalField[y][x] = 10000\r\n                }\r\n            }\r\n        }\r\n\r\n        this.smoothEnergyField(bounding)\r\n\r\n    }\r\n\r\n    updateFinalField(idx,k,val){\r\n\r\n        let id = parseInt(idx);\r\n        let sz = control_points[k].length;\r\n        //console.log([id,sz]);\r\n        let points = []\r\n        let miny = Number.MAX_VALUE\r\n        let maxy = Number.MIN_VALUE\r\n        for(let j = -1;j <= 1;j ++ ){\r\n            points.push({\r\n                x:control_points[k][(id + j) % sz][0],\r\n                y:control_points[k][(id + j) % sz][1]\r\n            })\r\n            miny = Math.min(miny,control_points[k][(id + j) % sz][1]);\r\n            maxy = Math.max(maxy,control_points[k][(id + j) % sz][1]);\r\n        }\r\n//\r\n        let lines = []\r\n//\r\n        for(let j = 0;j < 3;j ++){\r\n            let p1 = points[j]\r\n            let p2 = points[(j+1)%3]\r\n            let tmp = {}\r\n            tmp.y1 = Math.min(p1.y,p2.y);\r\n            tmp.y2 = Math.max(p1.y,p2.y);\r\n            if(p1.y == p2.y){\r\n                tmp.flag = true;\r\n                tmp.val1 = Math.min(p1.x,p2.x);\r\n                tmp.val2 = Math.max(p1.x,p2.x);\r\n            }\r\n            else{\r\n                tmp.flag = false;\r\n                tmp.val1 = (p2.x - p1.x) / (p2.y - p1.y);\r\n                tmp.val2 = (p1.x * p2.y - p2.x * p1.y) / (p2.y - p1.y);\r\n            }\r\n            lines.push(tmp);\r\n        }\r\n//\r\n        for(let y = miny;y < maxy;y ++){\r\n//\r\n            let x1 = Number.MAX_VALUE;\r\n            let x2 = Number.MIN_VALUE;\r\n            let flag = false;\r\n//\r\n            for(let j = 0; j < 3;j ++){\r\n                if(y >= lines[j].y1 && y <= lines[j].y2){\r\n                    if(lines[j].flag == true){\r\n                        x1 = lines[j].val1;\r\n                        x2 = lines[j].val2;\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                    else{\r\n                        let tmpx = lines[j].val1 * y + lines[j].val2;\r\n                        x1 = Math.min(x1, tmpx);\r\n                        x2 = Math.max(x2,tmpx);\r\n                    }\r\n                }\r\n            }\r\n//\r\n            if(flag==true && val == 0){\r\n                continue;\r\n            }\r\n            else{\r\n                x1 = parseInt(x1)\r\n                x2 = parseInt(x2)\r\n                for(let x = x1;x <= x2;x ++){\r\n                    //console.log(\"(\" + this.catEnergyField[k].x + \", \" + this.catEnergyField[k].y + \", \"+ pixelGroup + \")\");\r\n                    //console.log(\"(\" + this.catEnergyField[k].height + \", \" + this.catEnergyField[k].width + \")\")\r\n                    let uy = Math.min(parseInt((y - this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                    let ux = Math.min(parseInt((x - this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                    uy = Math.max(uy,0)\r\n                    ux = Math.max(ux,0)\r\n                    //alert(\"(\" + x + \", \" + y + \")\");\r\n                    // this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].field[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.updatedEnergyPoints[k].push([parseInt(ux),parseInt(uy)])\r\n                }\r\n            }\r\n//\r\n        }\r\n        //console.log(this.catEnergyField[k].finalField)\r\n    }\r\n\r\n    drawEnergyField(k){\r\n        colors = this.props.colorArray\r\n\r\n        let field=this.catEnergyField[k].finalField\r\n        //let field = this.catEnergyField[k].field\r\n        for(let y=0;y<field.length;y++){\r\n            for (let x=0;x<field[y].length;x++){\r\n                if(field[y][x]<0.0001)\r\n                    continue\r\n                let that=this\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=field[y][x]\r\n\r\n                g.append(\"rect\")\r\n                    .attr(\"x\",realx-0.5)\r\n                    .attr(\"y\",realy-0.5)\r\n                    .attr(\"width\",1)\r\n                    .attr(\"height\",1)\r\n                    .attr(\"class\",\"energyfieldrect\")\r\n                    .attr(\"fill\", function(){\r\n                        // if(value==-1){\r\n                        //     return \"red\"\r\n                        // }\r\n                        // if(value==-2){\r\n                        //     return \"green\"\r\n                        // }\r\n                        return colors[parseInt(k)]\r\n                    })\r\n                    .attr(\"opacity\",1)\r\n                    .attr(\"fieldvalue\",value)\r\n                    .on(\"mouseover\",function(d){\r\n                        console.log(d3.select(d.target).attr(\"fieldvalue\"))\r\n                        // console.log(\"2: \"+that.catEnergyField[\"2\"].finalField[y][x])\r\n                        // console.log(x,y)\r\n                        // console.log(\"1: \"+that.catEnergyField[\"1\"].barrierMap[y][x])\r\n\r\n                    })\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawBarrierMap(){\r\n        for(var k in this.catEnergyField){\r\n\r\n\r\n            let map=this.catEnergyField[k].barrierMap\r\n            for(let i=0;i<this.catEnergyField[k].height;i++){\r\n                for(let j=0;j<this.catEnergyField[k].width;j++){\r\n                    let realy=i+this.catEnergyField[k].y\r\n                    let realx=j+this.catEnergyField[k].x\r\n                    if(map[i][j]==3){\r\n                        drawRect(realx,realy,1,1,\"red\")\r\n                    }\r\n                    if(map[i][j]==4){\r\n                        drawRect(realx,realy,1,1,\"green\")\r\n                    }\r\n                    if(map[i][j]==1){\r\n                        drawRect(realx,realy,1,1,\"yellow\")\r\n                    }\r\n                    if(map[i][j]==2){\r\n                        drawRect(realx,realy,1,1,\"orange\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    drawBSpline(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            if(i==0){\r\n                console.log(lines[i]);\r\n            }\r\n            g.append(\"path\")\r\n                .style(\"fill\", color)\r\n                .style(\"stroke\",\"none\")\r\n                // .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 0.5)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0];\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1];\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                    console.log(i)\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', color)\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n    }\r\n\r\n    drawBSplineV2(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        g.append(\"path\")\r\n            .style(\"fill\", color)\r\n            .style(\"stroke\",\"none\")\r\n            // .style(\"stroke-width\", 0.5)\r\n            .style('opacity', 0.5)\r\n            .attr(\"d\", function () {\r\n                var p = \"\";\r\n                p += (d3.line()\r\n                        .x(function (dat) {\r\n                            return dat[0];\r\n                        })\r\n                        .y(function (dat) {\r\n                            return dat[1];\r\n                        })\r\n                )(lines)+ \"\";\r\n                return p;\r\n            })\r\n            .on('mouseover', function () {\r\n                d3.select(this)\r\n                    .style('stroke', \"red\")\r\n                    .style(\"stroke-width\", 3);\r\n            })\r\n            .on('mouseout', function () {\r\n                d3.select(this)\r\n                    .style('stroke', color)\r\n                    .style(\"stroke-width\", 0.5);\r\n            });\r\n\r\n    }\r\n\r\n    fillPolygonForEdge(Polygon, k, field, othercat){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n\r\n                //......\r\n                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                //d3.select('g').append('circle')\r\n                //    .attr('cx',realx)\r\n                //    .attr('cy',realy)\r\n                //    .attr('r',1)\r\n                //    .attr('fill','green')\r\n\r\n                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n\r\n                                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                //d3.select('g').append('circle')\r\n                                //    .attr('cx',realx)\r\n                                //    .attr('cy',realy)\r\n                                //    .attr('r',1)\r\n                                //    .attr('fill','green')\r\n\r\n                                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                                        //d3.select('g').append('circle')\r\n                                        //    .attr('cx',realx)\r\n                                        //    .attr('cy',realy)\r\n                                        //    .attr('r',1)\r\n                                        //    .attr('fill','blue')\r\n                                    }\r\n                                }\r\n\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    fillPolygon(Polygon,k,val,cut = false){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                if(!cut){\r\n                    this.catEnergyField[k].field[fy][fx] = val;\r\n                }\r\n                this.updatedEnergyPoints[k].push([fx,fy])\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n                                //console.log((x_begin,i));\r\n                                //canvas[parseInt(x_begin)][parseInt(i)] = val;\r\n                                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                                if(!cut){\r\n                                    this.catEnergyField[k].field[fy][fx] = val;\r\n                                }\r\n                                this.updatedEnergyPoints[k].push([fx,fy])\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    drawISOLinesV2(k,that,curdata){\r\n        colors = this.props.colorArray\r\n\r\n        editSeg[k] = []\r\n\r\n        let len;\r\n\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                console.log(\"dragged control point\")\r\n                console.log(\"(\" + iidx + \", \" + jidx + \")\")\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                            //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                       // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][0], control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 3) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                let p1 = [ control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1] ]\r\n                                let p2 = [ control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1] ]\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                let r1_idx = 0\r\n                                let dis1 = Number.MAX_VALUE\r\n                                let r2_idx = totLen / 5\r\n                                let dis2 = Number.MAX_VALUE\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n\r\n                                    let tmpdis1 = calDistance(p1[0], p1[1], tmp_p.x, tmp_p.y)\r\n                                    let tmpdis2 = calDistance(p2[0], p2[1], tmp_p.x, tmp_p.y)\r\n\r\n                                    if(tmpdis1 < dis1){\r\n                                        r1_idx = p\r\n                                        dis1 = tmpdis1\r\n                                    }\r\n\r\n                                    if(tmpdis2 < dis2){\r\n                                        r2_idx = p\r\n                                        dis2 = tmpdis2\r\n                                    }\r\n\r\n                                    //tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                for(let p = r1_idx; p <= r2_idx; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                    //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n                //    .remove()\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        g.append(\"path\")\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                }\r\n                // .style(\"stroke-width\", 0.5);\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    console.log(\"click!\")\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    reDraw(k,that,curdata){\r\n\r\n        colors = this.props.colorArray\r\n\r\n        let len = control_points[k].length;\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                console.log(\"dragged control point\")\r\n                console.log(\"(\" + iidx + \", \" + jidx + \")\")\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                        //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                        //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        d3.select(\"#path\"+k)\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                    // .style(\"stroke-width\", 0.5);\r\n                }\r\n\r\n\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    console.log(\"click!\")\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    drawOutline(points,color){\r\n\r\n        let SetAreas = new Array();\r\n\r\n        var lineFunction = d3.line()\r\n            .x(function(d) { return d[0]; })\r\n            .y(function(d) { return d[1]; })\r\n            .curve(d3.curveCardinalClosed);\r\n\r\n        let pointpath=lineFunction(points);\r\n\r\n        g.append('path')\r\n            .attr('d', pointpath)\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill',color)\r\n            .attr('fill-rule',\"evenodd\");\r\n    }\r\n\r\n    drawISOLines(lines, intervals,dx,dy,color) {\r\n\r\n        var marginBottomLabel = 0;\r\n\r\n\r\n\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            g.append(\"path\")\r\n                .style(\"fill\", \"none\")\r\n                .style(\"stroke\",color)\r\n                .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 1.0)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0]+dx;\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1]+dy;\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                    console.log(i)\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"black\")\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calOneISOLine(intervals,k){\r\n\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n            let data=this.catEnergyField[k].finalField\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n        return isoLines[0]\r\n    }\r\n\r\n    calISOLine(intervals, fieldData){\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n\r\n\r\n            let data=fieldData[k]\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n        return isoLineDict\r\n    }\r\n\r\n    BSplineInterpolate(points){\r\n        let tpoints=[]\r\n        let splinePoints=[]\r\n        let gap=5\r\n        for (let i=0;i<points.length;i++){\r\n            let remainLength=points.length-i\r\n\r\n            if(remainLength>gap){\r\n                if(i%gap==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n                if(i>0&&i%(3*gap)==0){\r\n                    var spline = new BSpline(tpoints,3)\r\n                    for(var t = 0.01;t<=1;t+=0.01){\r\n                        var p = spline.calcAt(t);\r\n                        splinePoints.push(p)\r\n                    }\r\n                    tpoints=[]\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n            else{\r\n                if(i%3==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        var spline = new BSpline(tpoints,3)\r\n        for(var t = 0.01;t<=1;t+=0.01){\r\n            var p = spline.calcAt(t);\r\n            splinePoints.push(p)\r\n        }\r\n\r\n\r\n        return splinePoints\r\n    }\r\n\r\n    normalizeKernel(kernel){\r\n        let sum=0\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                sum+=kernel[i][j]\r\n            }\r\n        }\r\n\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                kernel[i][j]=kernel[i][j]/sum\r\n            }\r\n        }\r\n        return kernel\r\n    }\r\n\r\n    getGaussianKernel(theta,kernelsize){\r\n        let scale=1\r\n        let kernel=[]\r\n        for (let i=0;i<kernelsize;i++){\r\n            kernel.push([])\r\n            for (let j=0;j<kernelsize;j++){\r\n                kernel[i].push(0)\r\n            }\r\n        }\r\n        let anchor=parseInt(kernelsize/2)/scale\r\n        let C=1/(Math.PI*2*theta*theta)\r\n\r\n        for (let i=0;i<kernelsize;i++){\r\n            for (let j=0;j<kernelsize;j++){\r\n                let ny=i/scale\r\n                let nx=j/scale\r\n                let y=Math.pow(ny-anchor,2)\r\n                let x=Math.pow(nx-anchor,2)\r\n                kernel[i][j]=C*Math.exp(-(x*x+y*y)/(2*theta*theta))\r\n            }\r\n        }\r\n\r\n        kernel=this.normalizeKernel(kernel)\r\n        return kernel\r\n    }\r\n\r\n    checkSingularPoint(k,x,y){\r\n        let delta=1\r\n        let field=this.catEnergyField[k].finalField\r\n        let isSingular=true\r\n        //right\r\n        if(x+delta<this.catEnergyField[k].width){\r\n            if(field[y][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left\r\n        if(x-delta>0){\r\n            if(field[y][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //up\r\n        if(y-delta>0){\r\n            if(field[y-delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //down\r\n        if(y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-top\r\n        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n            if(field[y-delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-bottom\r\n        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-top\r\n        if(x-delta>0&&y-delta>0){\r\n            if(field[y-delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-bottom\r\n        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n\r\n        return isSingular\r\n    }\r\n\r\n    fillCrossingEdge_Part(edges){\r\n\r\n\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<edges.length;i++){\r\n            let cat1=edges[i].cat\r\n            let start1=this.pointData[edges[i].start]\r\n            let end1=this.pointData[edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual && edges[i].virtrualNodes.length > 0){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:edges[i].virtrualNodes[0][0],y:edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:edges[i].virtrualNodes[v][0],y:edges[i].virtrualNodes[v][1]},{x:edges[i].virtrualNodes[v+1][0],y:edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:edges[i].virtrualNodes[vlength-1][0],y:edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=0;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual && this.edges[j].virtrualNodes.length > 0){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    fillCrossingEdge(){\r\n\r\n        //return\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat1=this.edges[i].cat\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:this.edges[i].virtrualNodes[0][0],y:this.edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<this.edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<this.edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:this.edges[i].virtrualNodes[v][0],y:this.edges[i].virtrualNodes[v][1]},{x:this.edges[i].virtrualNodes[v+1][0],y:this.edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=this.edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:this.edges[i].virtrualNodes[vlength-1][0],y:this.edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=i+1;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                // let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                    // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                    // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            for (var k2 in this.catEdgeDict) {\r\n                                let othercat = k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for(var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    smoothEnergyField(bounding){\r\n        let kernelsize = 3\r\n        let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n        let anchor = parseInt(kernelsize/2)\r\n        // console.log(kernel)\r\n        for (var k in this.catEnergyField){\r\n\r\n            let sx = bounding[k].minX;\r\n            let ex = bounding[k].maxX;\r\n            let sy = bounding[k].minY;\r\n            let ey = bounding[k].maxY;\r\n\r\n            let cur_width = ex - sx + 1;\r\n            let cur_height = ey - sy + 1;\r\n\r\n            let newField=[]\r\n            for (let y = 0;y < cur_height + 10;y ++){\r\n                newField.push(new Array(cur_width + 10).fill(0))\r\n            }\r\n\r\n            for (let y = sy; y <= ey; y ++){\r\n                for (let x = sx; x <= ex; x ++){\r\n\r\n                    let newvalue = 0\r\n                    for (let i = 0;i < kernelsize;i ++){\r\n                        for (let j = 0;j < kernelsize;j ++){\r\n                            let dy = i - anchor\r\n                            let dx = j - anchor\r\n                            let ny = y + dy\r\n                            let nx = x + dx\r\n                            if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                                newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                            }\r\n                        }\r\n                    }\r\n                    if(newvalue > 0){\r\n                        newField[y - sy][x - sx] = newvalue\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let y = sy; y <= ey; y ++){\r\n                for(let x = sx; x <= ex; x ++){\r\n                    //console.log(\"(\" + y + \", \" + x + \")\")\r\n                    //console.log(this.catEnergyField[k].finalField)\r\n                    this.catEnergyField[k].finalField[y][x] = newField[y - sy][x - sx]\r\n                }\r\n            }\r\n\r\n            //this.catEnergyField[k].finalField=newField\r\n        }\r\n    }\r\n\r\n    saveOutline(isoLineDict){\r\n        let res=[]\r\n        for (var k in isoLineDict){\r\n            for (let i=0;i<isoLineDict[k].length;i++){\r\n                let formatpoints=[]\r\n                for(let p=0;p<isoLineDict[k][i].length;p++){\r\n                    formatpoints.push({x:isoLineDict[k][i][p][0],y:isoLineDict[k][i][p][1]})\r\n                }\r\n                res.push({\r\n                    cat:k,\r\n                    id:i,\r\n                    isInterior:false,\r\n                    parentID:-1,\r\n                    points:formatpoints\r\n                })\r\n            }\r\n        }\r\n        console.log(JSON.stringify(res))\r\n    }\r\n\r\n    removeOverlaps(){\r\n\r\n        this.updateEnergyPoints()\r\n\r\n        //for(var k in this.catEnergyField){\r\n        //    this.drawEnergyField(k);\r\n        //}\r\n\r\n\r\n        //this.smoothEnergyField()\r\n\r\n        d3.select(\"svg\")\r\n            .selectAll(\"path\")\r\n            .remove()\r\n\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        /*\r\n        intervals=[0.01]\r\n        let isoDict=this.calISOLine(intervals)\r\n\r\n        //for (var k in isoDict){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {}\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    tmp_polygon[k].selectidx = tmp_polygon[k].length - 1;\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        //console.log(tmp_polygon)\r\n        for(var k in isoDict){\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                if(i == sidx){\r\n                    continue;\r\n                }\r\n                let flag = true;\r\n                for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                    flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx]);\r\n                    if(flag == false){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n                    if(tmp_polygon[k][i].length < 30){\r\n                        continue;\r\n                    }\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j += 10){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n            }\r\n        }\r\n\r\n        //console.log(\"hhhh\")\r\n        //console.log(isoDict)\r\n        /*\r\n        for (var k in isoDict){\r\n\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    //console.log(isoDict[k][i])\r\n                    if(!polygontest.hasOwnProperty(k)){\r\n                        polygontest[k] = [];\r\n                    }\r\n                    let tmppolygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        tmppolygon.push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    polygontest[k].push(tmppolygon)\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n\r\n        // re-cal the energy field for inner outline\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].tfinalField = []\r\n            for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                    let val = this.catEnergyField[k].finalField[y][x];\r\n                    let flag = false;\r\n                    for(let idx = 0; idx < polygontest[k].length; idx ++){\r\n                        flag = IsoInsideTest([x, y], polygontest[k][idx])\r\n                        if(flag){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        //console.log(\"test!!\")\r\n                        if(val > 0){\r\n                            this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                        }\r\n                        else{\r\n                            this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.catEnergyField[k].finalField[y][x] = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(this.catEnergyField[k].tfinalField,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n\r\n        for (var k in isoLineDict){\r\n            //console.log(isoLineDict[k])\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                if(isoLineDict[k][i].length < 30){\r\n                    continue;\r\n                }\r\n                let curlen = control_points[k].length;\r\n                control_points[k][curlen] = [];\r\n                for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                    control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let meandis = 0;\r\n                let sz = control_points[k][curlen].length;\r\n                for(let j = 0; j < sz; j ++){\r\n                    meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                        control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                }\r\n                meandis /= sz\r\n                control_points[k][curlen].meandis = meandis;\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        */\r\n\r\n        /*\r\n        for(var k in this.catEnergyField){\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            //this.drawEnergyField(k);\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n        */\r\n\r\n        //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n        //    .remove()\r\n\r\n        for(var k in this.catEnergyField){\r\n            // this.drawEnergyField(k);\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    onChangeEdgeWidth = value => {\r\n        edgeWidth = value\r\n        this.setState({\r\n            edgeWidth:value\r\n        })\r\n        this.changeEdgeWidth(this.selectedEdge,value)\r\n    };\r\n\r\n\r\n    onChangeNodeR0 = value => {\r\n        nodeR0 = value\r\n        this.setState({\r\n            nodeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeNodeR1 = value => {\r\n        nodeR1 = value\r\n        nodeR0=nodeR1-5\r\n        this.setState({\r\n            nodeR1: value,\r\n            nodeR0:nodeR1-5\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR0 = value => {\r\n        edgeR0 = value\r\n        this.setState({\r\n            edgeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR1 = value => {\r\n        edgeR1 = value\r\n        edgeR0=edgeR1-5\r\n        this.setState({\r\n            edgeR1: value,\r\n            edgeR0:edgeR0\r\n        });\r\n    };\r\n\r\n    onChangePixelGroup = value => {\r\n        pixelGroup = value\r\n        this.setState({\r\n            pixelGroup: value,\r\n        });\r\n    };\r\n\r\n    onChangeGap = value => {\r\n        gapBetween = value\r\n        this.setState({\r\n            gapBetween: value,\r\n        });\r\n    };\r\n\r\n    render(){\r\n        return(\r\n\r\n            <div id={\"Sliders\"}>\r\n                <br/>\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>nodeR0</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR0}\r\n                        value={typeof nodeR0 === 'number' ? nodeR0 : 10}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR0}\r\n                        onChange={this.onChangeNodeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Node Radius</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR1}\r\n                        value={typeof nodeR1 === 'number' ? nodeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR1}\r\n                        onChange={this.onChangeNodeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>edgeR0</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR0}\r\n                        value={typeof edgeR0 === 'number' ? edgeR0 : 15}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR0}\r\n                        onChange={this.onChangeEdgeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Global Edge Width</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR1}\r\n                        value={typeof edgeR1 === 'number' ? edgeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR1}\r\n                        onChange={this.onChangeEdgeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Pixel Group</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangePixelGroup}\r\n                            value={typeof pixelGroup === 'number' ? pixelGroup : 2}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={pixelGroup}\r\n                            onChange={this.onChangePixelGroup}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Gap Between Different Groups</h4>\r\n                        <Slider\r\n                            min={0}\r\n                            max={5}\r\n                            onChange={this.onChangeGap}\r\n                            value={typeof gapBetween === 'number' ? gapBetween : 1}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={0}\r\n                            max={5}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={gapBetween}\r\n                            onChange={this.onChangeGap}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Edge Width</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            value={this.state.edgeWidth}\r\n                        disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={this.state.edgeWidth}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                </Row>\r\n\r\n                <br/>\r\n                <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Draw Bubbles\r\n                </Button>\r\n\r\n                <Button onClick = {this.removeOverlaps.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Remove Overlaps\r\n                </Button>\r\n\r\n        </div>)\r\n\r\n    }\r\n}\r\n\r\nexport default AdaptiveIsovalue","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport * as d3 from \"d3\"\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport {Button, Switch} from 'antd';\r\nimport {PointToSegDist} from \"./util\"\r\n\r\nvar FileSaver = require('file-saver');\r\n//import Quadtree from '@timohausmann/quadtree-js'\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\n// var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\n// var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n// var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=10\r\nvar DBSCAN_EPS=40\r\nvar VirtrualNodeBuffer=50\r\n\r\n\r\nvar clustering = require('density-clustering');\r\nvar weightCross=1\r\nvar weightDistance=1\r\nvar weightMess=1\r\n\r\nvar maxCross=Number.MIN_VALUE\r\nvar DISTANCE_THRESHHOLD=Number.MAX_VALUE\r\n\r\nvar priority_queue = require('./priority_queue.js');\r\nvar svgid = \"#mainsvg\"\r\nvar opsvgid = \"#leftsvg\"\r\nvar svg;\r\nvar g;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\n\r\nvar subOldPoints = []\r\nvar addNewPoints = []\r\nvar subOldEdges = []\r\nvar addNewEdges = []\r\nvar editPoints = []\r\nvar editEdges = []\r\nvar preEdges = []\r\nvar tmpEditEdges = []\r\nvar prePoint\r\nvar preEdgeDict\r\nvar curEdgeDict\r\nvar editView = false\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//var Quadtree = require('./quadtree.js');\r\n\r\nclass HierarchicalCluster extends Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            read: false,\r\n            pointData:[],\r\n            edges:[],\r\n            hasinit:false,\r\n            hasEdit:false,\r\n            hascreated:false,\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        }\r\n        this.issplit=false\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedIndex=-1\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n    }\r\n\r\n    init(){\r\n        this.setState({\r\n            pointData: []\r\n        })\r\n        this.setState({\r\n            edges: []\r\n        })\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n\r\n    }\r\n\r\n    searchFather(x){\r\n        while(x!=this.f[x]){\r\n            this.f[x] = this.f[this.f[x]];\r\n            x = this.f[x];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    unionFather(x,y){\r\n        this.f[this.searchFather(y)] = this.searchFather(x);\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        // this.setState({\r\n        //     hasLoadData:this.props.hasLoadData\r\n        // })\r\n        //V1\r\n        //this.QTree = new Quadtree({\r\n        //    x: 0,\r\n        //    y: 0,\r\n        //    width: this.canvasWidth,\r\n        //    height: this.canvasHeight\r\n        //});\r\n        //this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n\r\n        d3.select(\"#leftsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        offsetX = minx-20;\r\n        offsetY = miny-20;\r\n        viewWidth = maxx-minx+40;\r\n        viewHeight = maxy-miny+40\r\n\r\n    }\r\n\r\n    calEPS(){\r\n        // POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        let dissum=0\r\n        let disnum=0\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let dis=this.calDistance(this.pointData[i],this.pointData[j])\r\n                dissum+=dis\r\n                disnum+=1\r\n                if(dis>maxDis){\r\n                    maxDis=dis\r\n                }\r\n            }\r\n        }\r\n        POINT_EDGE_EPS=maxDis*0.035\r\n        // DBSCAN_EPS=POINT_EDGE_EPS\r\n        this.maxDis=maxDis\r\n        /*                d3.select(svgid)\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",POINT_EDGE_EPS)\r\n                    .attr(\"cy\",POINT_EDGE_EPS)\r\n                    .attr(\"r\",POINT_EDGE_EPS)\r\n                    .attr(\"fill\",\"black\")*/\r\n\r\n        DISTANCE_THRESHHOLD=dissum/disnum-10\r\n        //console.log(POINT_EDGE_EPS)\r\n        //console.log(\"avreage distance: \"+dissum/disnum)\r\n        //console.log(\"max distance: \"+this.maxDis)\r\n\r\n\r\n    }\r\n\r\n    addNewPoints(point){\r\n\r\n        console.log(\"addNewPoints\")\r\n        point.x=parseFloat(point.x)\r\n        point.y=parseFloat(point.y)\r\n        point.id=this.pointData.length\r\n        point.cat=point.cat.toString()\r\n        let cats=point.cat.split(\",\")\r\n        let catarray=[]\r\n        if (cats.length>1){\r\n            point.multicat=true\r\n            for (let c=0;c<cats.length;c++){\r\n                catarray.push(cats[c])\r\n            }\r\n        }\r\n        else{\r\n            point.multicat=false\r\n            catarray.push(point.cat)\r\n        }\r\n        point.catArray=catarray\r\n\r\n        for (let c=0;c<point.catArray.length;c++){\r\n            let nowcat=point.catArray[c]\r\n            if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                this.catPointDict[nowcat]=[]\r\n            }\r\n            this.catPointDict[nowcat].push(point)\r\n        }\r\n\r\n        this.pointData.push(point)\r\n\r\n        let tmpp1 = clone(this.pointData[this.pointData.length - 1])\r\n        tmpp1.flag = true\r\n        tmpp1.id = this.pointData.length - 1\r\n        editPoints.push(tmpp1)\r\n\r\n        //this.centralizeData()\r\n\r\n        this.calEPS()\r\n\r\n        this.drawPointData()\r\n\r\n        this.optimizeMST(true)\r\n\r\n        this.setState({\r\n            pointData: this.pointData\r\n        })\r\n        this.setState({\r\n            edges: this.edges\r\n        })\r\n\r\n\r\n    }\r\n\r\n    getData(){\r\n\r\n        colors = this.props.colorArray\r\n        this.setState({\r\n            colorArray:colors\r\n        })\r\n\r\n        //let that=this\r\n        //fetch('/data/BubbleSetExample1.txt',{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n        //console.log(data)\r\n\r\n        // if(!this.props.hasLoadData){\r\n        //     return\r\n        // }\r\n\r\n        if(this.state.hasinit){\r\n            this.applyEdit()\r\n        }\r\n        else{\r\n            if(this.props.pointData){\r\n                this.init();\r\n\r\n                if(this.props.edges){\r\n                    this.edges=this.props.edges\r\n                }\r\n                console.log(this.edges.length)\r\n\r\n                // alert(\"Finish input and start creating spanning tree!\");\r\n                this.pointData=this.props.pointData\r\n                //this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                //console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n                    this.pointData[i].id=i\r\n                    this.pointData[i].cat=this.pointData[i].cat.toString()\r\n                    let cats=this.pointData[i].cat.split(\",\")\r\n                    let catarray=[]\r\n                    if (cats.length>1){\r\n                        this.pointData[i].multicat=true\r\n                        for (let c=0;c<cats.length;c++){\r\n                            catarray.push(cats[c])\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.pointData[i].multicat=false\r\n                        catarray.push(this.pointData[i].cat)\r\n                    }\r\n                    this.pointData[i].catArray=catarray\r\n                    for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                        let nowcat=this.pointData[i].catArray[c]\r\n                        if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                            this.catPointDict[nowcat]=[]\r\n                        }\r\n                        this.catPointDict[nowcat].push(this.pointData[i])\r\n                    }\r\n                }\r\n                console.log(this.catPointDict)\r\n                //console.log(this.pointData)\r\n                //console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                this.calEPS()\r\n                d3.select(svgid).selectAll(\"*\").remove();\r\n                this.drawPointData()\r\n                var beginTime = +new Date();\r\n                this.generateTreeWithHierarchical()\r\n                var endTime = +new Date();\r\n\r\n                console.log(\"Spanning tree: \"+(endTime-beginTime)+\"ms\");\r\n\r\n                // console.log(this.edges)\r\n                this.drawEdges()\r\n                this.countEdgeCrossingWithRouting()\r\n                this.props.hasCreate();\r\n\r\n                console.log(this.edges);\r\n                this.setState({\r\n                    pointData: this.pointData\r\n                })\r\n                this.setState({\r\n                    edges: this.edges\r\n                })\r\n                this.setState({\r\n                    hasinit:true\r\n                })\r\n                //})\r\n            }\r\n\r\n        }\r\n        //console.log(this.pointData)\r\n\r\n        return [this.pointData, this.edges, colors]\r\n\r\n    }\r\n\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    checkConnectBetweenAllClusterV2(){\r\n        for(let k in this.clusterDict){\r\n            let m = this.clustergraphInfo[k].edgesnum;\r\n            let n = this.clustergraphInfo[k].nodesnum;\r\n            if (m != n - 1){\r\n                return false;\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    checkConnectBetweenAllCluster(){\r\n        for(let k in this.clusterDict){\r\n            let start=this.clusterDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n            for (let i=1;i<this.clusterDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.clusterDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n\r\n    checkConnectBetweenTwoClusterV2(id1,id2){\r\n        return (this.searchFather(id1)==this.searchFather(id2));\r\n    }\r\n\r\n    checkConnectBetweenTwoCluster(id1,id2){\r\n        var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, id1);\r\n        if (!dfs.hasPathTo(id2)){\r\n            return false\r\n        }\r\n        else{\r\n            return true\r\n        }\r\n    }\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(svgid).append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for(let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n            that.edges[i].SVGElement=[]\r\n        }\r\n\r\n        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        if(d3.select(opsvgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(opsvgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        /*        function dragstartControlpoint(){\r\n                }\r\n                function draggedControlPoint(event){\r\n                    let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n                    that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n                    d3.select(this)\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                        })\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                        })\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n                }\r\n\r\n                var dragControlPoint = d3.drag()\r\n                    .on(\"start\",dragstartControlpoint)\r\n                    .on(\"drag\",draggedControlPoint)\r\n\r\n                function dragstartEdge(event){\r\n                    // console.log(\"start!\")\r\n                    let index=parseInt(d3.select(this).attr(\"index\"))\r\n                    let start=that.pointData[that.edges[index].start]\r\n                    let end=that.pointData[that.edges[index].end]\r\n\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n\r\n                    if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                        let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                        that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=segindex\r\n                    }\r\n                    else{\r\n                        that.edges[index].virtrual=true\r\n                        that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=0\r\n                    }\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .remove()\r\n\r\n                    let vpoints=that.edges[index].virtrualNodes\r\n                    let nowp=[start.x,start.y]\r\n                    let nextp=[]\r\n                    for(let i=0;i<vpoints.length;i++){\r\n                        nextp=vpoints[i]\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .append(\"line\")\r\n                            .attr(\"x1\",nowp[0])\r\n                            .attr(\"y1\",nowp[1])\r\n                            .attr(\"x2\",nextp[0])\r\n                            .attr(\"y2\",nextp[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"index\",index)\r\n                            .attr(\"isvirtrual\",true)\r\n                            .attr(\"segindex\",i)\r\n                            .on(\"mouseover\",function(d,i){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"red\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"black\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mousedown\",handleMouseDown)\r\n                            .call(dragEdge)\r\n\r\n                        nowp=nextp\r\n                    }\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .append(\"line\")\r\n                        .attr(\"x1\",nowp[0])\r\n                        .attr(\"y1\",nowp[1])\r\n                        .attr(\"x2\",end.x)\r\n                        .attr(\"y2\",end.y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",index)\r\n                        .attr(\"isvirtrual\",true)\r\n                        .attr(\"segindex\",vpoints.length)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"red\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mouseout\",function(){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"black\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mousedown\",handleMouseDown)\r\n\r\n                        .call(dragEdge)\r\n\r\n                    for (let v=0;v<vpoints.length;v++){\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .append(\"circle\")\r\n                            .attr(\"class\",\"controlPoints\")\r\n                            .attr(\"cx\",vpoints[v][0])\r\n                            .attr(\"cy\",vpoints[v][1])\r\n                            .attr(\"r\",5)\r\n                            .attr(\"fill\",\"red\")\r\n                            .attr(\"opacity\",0)\r\n                            .attr(\"edgeindex\",index)\r\n                            .attr(\"segindex\",v)\r\n                            // .attr(\"display\",\"none\")\r\n                            .on(\"mouseover\",function(){\r\n                                d3.select(this).attr(\"opacity\",1)\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                d3.select(this).attr(\"opacity\",0)\r\n                            })\r\n                            .call(dragControlPoint)\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n                function draggedEdge(event){\r\n                    // console.log(\"drag!\")\r\n                    if(that.draggedEdgeIndex==-1)\r\n                        return\r\n                    event.sourceEvent.stopPropagation();\r\n                    let edgeIndex=that.draggedEdgeIndex\r\n                    let segIndex=that.draggedEdgeSeg\r\n\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n\r\n                }\r\n\r\n                function dragendEdge(event){\r\n                    // console.log(\"end!\")\r\n                    that.draggedEdgeSeg=-1\r\n                    that.draggedEdgeIndex=-1\r\n                }\r\n\r\n                var dragEdge = d3.drag()\r\n                    .on(\"start\",dragstartEdge)\r\n                    .on(\"drag\",draggedEdge)\r\n                    .on(\"end\",dragendEdge)\r\n\r\n                function handleMouseDown(event){\r\n                    if(event.button==2){\r\n                        let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                            })\r\n                            .attr(\"edgeindex\",function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                            })\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                            })\r\n                            .attr(\"index\",function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))-1\r\n                            })\r\n                        that.edges.splice(deleteindex,1)\r\n\r\n                        for (let i=0;i<that.edges.length;i++){\r\n                            that.edges[i].id=i\r\n                        }\r\n                    }\r\n                }*/\r\n\r\n        d3.selectAll(\"line\").remove()\r\n\r\n        d3.selectAll(\".controlPoints\").remove()\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            /*            let start=this.edges[i].start\r\n                        let end=this.edges[i].end\r\n\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        let index=i\r\n                        if(this.edges[i].virtrual){\r\n                            let vpoints=this.edges[i].virtrualNodes\r\n                            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                            let vend\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                vend=vpoints[v]\r\n                                let newline=d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"line\")\r\n                                    .attr(\"x1\",vstart[0])\r\n                                    .attr(\"y1\",vstart[1])\r\n                                    .attr(\"x2\",vend[0])\r\n                                    .attr(\"y2\",vend[1])\r\n                                    .attr(\"stroke-width\",2)\r\n                                    .attr(\"stroke\",\"black\")\r\n                                    .attr(\"index\",i)\r\n                                    .attr(\"isvirtrual\",true)\r\n                                    .attr(\"segindex\",v)\r\n                                    .on(\"mouseover\",function(d,i){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"red\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"black\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                                    .call(dragEdge)\r\n                                vstart=vend\r\n                                if(v==0){\r\n                                    this.nodeStartDict[start].push(newline)\r\n                                }\r\n                            }\r\n                            vend=[this.pointData[end].x,this.pointData[end].y]\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",vstart[0])\r\n                                .attr(\"y1\",vstart[1])\r\n                                .attr(\"x2\",vend[0])\r\n                                .attr(\"y2\",vend[1])\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",true)\r\n                                .attr(\"segindex\",vpoints.length)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeEndDict[end].push(newline)\r\n                            // console.log()\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"circle\")\r\n                                    .attr(\"class\",\"controlPoints\")\r\n                                    .attr(\"cx\",vpoints[v][0])\r\n                                    .attr(\"cy\",vpoints[v][1])\r\n                                    .attr(\"r\",5)\r\n                                    .attr(\"edgeindex\",i)\r\n                                    .attr(\"segindex\",v)\r\n                                    .attr(\"fill\",\"red\")\r\n                                    .attr(\"opacity\",0)\r\n                                    // .attr(\"display\",\"none\")\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"opacity\",1)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"opacity\",0)\r\n                                    })\r\n                                    .call(dragControlPoint)\r\n\r\n                            }\r\n                        }\r\n                        else{\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",this.pointData[start].x)\r\n                                .attr(\"y1\",this.pointData[start].y)\r\n                                .attr(\"x2\",this.pointData[end].x)\r\n                                .attr(\"y2\",this.pointData[end].y)\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",false)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeStartDict[start].push(newline)\r\n                            this.nodeEndDict[end].push(newline)\r\n                        }*/\r\n\r\n            this.drawOneEdge(i)\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        // console.log(this.edges)\r\n        // d3.selectAll(\"line\").remove()\r\n        // let that=this\r\n        // for(let i=0;i<this.edges.length;i++){\r\n        //     let node1=this.edges[i].start\r\n        //     let node2=this.edges[i].end\r\n        //\r\n        //     d3.select(svgid).append(\"line\")\r\n        //         .attr(\"x1\",this.pointData[node1].x)\r\n        //         .attr(\"y1\",this.pointData[node1].y)\r\n        //         .attr(\"x2\",this.pointData[node2].x)\r\n        //         .attr(\"y2\",this.pointData[node2].y)\r\n        //         .attr(\"stroke-width\",2)\r\n        //         .attr(\"stroke\",\"black\")\r\n        //         .attr(\"index\",i)\r\n        //         .on(\"click\",function(){\r\n        //             let removeindex=d3.select(this).attr(\"index\")\r\n        //             that.edges[removeindex].isdelete=true\r\n        //             d3.select(this).remove()\r\n        //             console.log(that.edges)\r\n        //         })\r\n        // }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/manuallyDataEdge.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    optimizeMST(isedit){\r\n\r\n        this.clustergraphInfo={}\r\n        let newGraph=new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<newGraph.V;i++){\r\n            newGraph.node(i).label=this.pointData[i].cat\r\n        }\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let cat=this.edges[i].cat\r\n            newGraph.addEdge(start,end)\r\n            // this.clustergraphInfo[cat].edgesnum+=1\r\n        }\r\n\r\n        this.graph=newGraph\r\n        //find Connected Components\r\n        var cc = new jsgraphs.ConnectedComponents(newGraph);\r\n        console.log(cc.componentCount());\r\n\r\n\r\n\r\n        //create new clusterDict with connected components\r\n        let newClusterDict={}\r\n        for (let k in this.catPointDict){\r\n            newClusterDict[k]=[]\r\n        }\r\n        let clusterArr=[]\r\n        for (let i=0;i<cc.componentCount();i++){\r\n            clusterArr.push([])\r\n        }\r\n        for (var v = 0; v < newGraph.V; v++) {\r\n            let point=this.pointData[v]\r\n            let comid=cc.componentId(v)\r\n            clusterArr[comid].push(point)\r\n        }\r\n        for(let i=0;i<clusterArr.length;i++){\r\n            let cat=clusterArr[i][0].cat\r\n            newClusterDict[cat].push(clusterArr[i])\r\n        }\r\n        this.clusterDict=newClusterDict\r\n        // console.log(newClusterDict)\r\n\r\n        for (let k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n        }\r\n\r\n        clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n            }\r\n\r\n        }\r\n\r\n        this.clusterArr=clusterArr\r\n        // console.log(this.clusterArr)\r\n        let g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n\r\n        //update boundingbox of points\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n        if(!isedit){\r\n            let newEdges=this.recalculateSpanningTree()\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n\r\n            // this.drawEdges()\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdge(newEdges[i])\r\n                this.edges[newEdges[i]].new = true\r\n                //let tmpe = clone(this.edges[newEdges[i]])\r\n                //tmpe.id = newEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                //addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            this.countEdgeCrossing()\r\n            this.draggedIndex=-1\r\n            this.deletedEdge=[]\r\n            this.addedEdge=[]\r\n            this.setState({\r\n                pointData:this.pointData,\r\n                edges:this.edges\r\n            })\r\n        }\r\n        else{\r\n            let tempedges=[]\r\n            for (let i=0;i<this.edges.length;i++){\r\n                /*                tempedges.push(\r\n                                    {\r\n                                        start:this.edges[i].start,\r\n                                        end:this.edges[i].end,\r\n                                        weight:this.edges[i].weight,\r\n                                        cat:this.edges[i].cat,\r\n                                        dis:this.edges[i].dis,\r\n                                        virtrual:this.edges[i].virtrual,\r\n                                        virtrualNodes:this.edges[i].virtrualNodes,\r\n                                        isLocalTree:this.edges[i].isLocalTree\r\n                                    }\r\n                                )*/\r\n                tempedges.push(this.edges[i])\r\n            }\r\n\r\n            let newEdges=this.recalculateSpanningTreeAfterEdit(tempedges)\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n            // this.drawEdges()\r\n            d3.selectAll(\".deleteOpEdge\")\r\n                .remove()\r\n\r\n            tmpEditEdges = []\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdgeAfterEdit(tempedges,newEdges[i])\r\n                //console.log(\"newEdges:\")\r\n                //console.log(this.edges)\r\n                //console.log(tempedges)\r\n                //console.log(newEdges[i])\r\n                let tmpe = clone(tempedges[newEdges[i]])\r\n                tmpe.id = newEdges[i]\r\n                tmpe.flag = true\r\n                tmpEditEdges.push(tmpe)\r\n            }\r\n            this.tempEdges=tempedges\r\n            // console.log(this.edges.length,this.tempEdges.length)\r\n\r\n        }\r\n\r\n    }\r\n\r\n    sufaceRoutingAll(){\r\n        for (let ei=0;ei<this.edges.length;ei++){\r\n            let thisedge=this.edges[ei]\r\n            let startp=this.pointData[thisedge.start.id]\r\n            let endp=this.pointData[thisedge.end.id]\r\n            let pcat=this.pointData[thisedge.start.id].cat\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[ei].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[ei].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[ei].virtrualNodes=virtrualNodes\r\n        }\r\n\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        if(virtrualNodes.length==0){\r\n            edge.virtrual=false\r\n        }\r\n        return edge\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n\r\n        let crossnum=0\r\n        let start = this.pointData[index1]\r\n        let end = this.pointData[index2]\r\n        for(let e=0;e<this.edges.length;e++){\r\n            let e1=this.pointData[this.edges[e].start]\r\n            let e2=this.pointData[this.edges[e].end]\r\n            if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                crossnum+=1\r\n            }\r\n        }\r\n        //cal distance\r\n        let distance=this.calDistance(start, end)\r\n        //cal num of other points\r\n        let mess=this.calEdgeMess(start, end)\r\n        let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n        newedge.score = score\r\n\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function dragstartControlpoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag start control point!\")\r\n            //console.log(index)\r\n            editEdges = []\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(that.pointData[that.edges[index].start])\r\n            tmpe.endpoint = clone(that.pointData[that.edges[index].end])\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n        }\r\n        function draggedControlPoint(event){\r\n            let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n            that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n            that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n            let idx = \"#\" + d3.select(this).attr(\"id\")\r\n            //console.log(\"dragged control point\")\r\n            //console.log(idx)\r\n            d3.selectAll(idx)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                })\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                })\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n        }\r\n        function dragendControlPoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag end control point!\")\r\n            //console.log(index)\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.id = index\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var dragControlPoint = d3.drag()\r\n            .on(\"start\",dragstartControlpoint)\r\n            .on(\"drag\",draggedControlPoint)\r\n            .on(\"end\",dragendControlPoint)\r\n\r\n        function dragstartEdge(event){\r\n            console.log(\"drag start edge!\")\r\n            // console.log(\"start!\")\r\n            let index=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            let start=that.pointData[that.edges[index].start]\r\n            let end=that.pointData[that.edges[index].end]\r\n\r\n            editEdges = []\r\n//\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(start)\r\n            tmpe.endpoint = clone(end)\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n\r\n            if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=segindex\r\n            }\r\n            else{\r\n                that.edges[index].virtrual=true\r\n                that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=0\r\n            }\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .remove()\r\n\r\n            /*            for (let j=0;j<that.edges[index].SVGElement.length;j++){\r\n                            that.edges[index].SVGElement[j].remove()\r\n                        }*/\r\n\r\n            that.edges[index].SVGElement=[]\r\n\r\n            let vpoints=that.edges[index].virtrualNodes\r\n            let nowp=[start.x,start.y]\r\n            let nextp=[]\r\n            for(let i=0;i<vpoints.length;i++){\r\n                nextp=vpoints[i]\r\n                let newedge=d3.select(svgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n\r\n                d3.select(opsvgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n                that.edges[index].SVGElement.push(newedge)\r\n                nowp=nextp\r\n            }\r\n            let newline=d3.select(svgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n\r\n            that.edges[index].SVGElement.push(newline)\r\n\r\n\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function draggedEdge(event){\r\n            // console.log(\"drag!\")\r\n            if(that.draggedEdgeIndex==-1)\r\n                return\r\n            event.sourceEvent.stopPropagation();\r\n            let edgeIndex=that.draggedEdgeIndex\r\n            let segIndex=that.draggedEdgeSeg\r\n\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n\r\n            d3.selectAll(\".controlPoints\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n\r\n        }\r\n\r\n        function dragendEdge(event){\r\n            // console.log(\"end!\")\r\n            let i = that.draggedEdgeIndex\r\n            let tmpe = clone(that.edges[i])\r\n            tmpe.id = i\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n//\r\n//\r\n            editPoints = []\r\n            editEdges = []\r\n\r\n\r\n            that.draggedEdgeSeg=-1\r\n            that.draggedEdgeIndex=-1\r\n            //that.child.getData()\r\n        }\r\n\r\n        var dragEdge = d3.drag()\r\n            .on(\"start\",dragstartEdge)\r\n            .on(\"drag\",draggedEdge)\r\n            .on(\"end\",dragendEdge)\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                that.setState({\r\n                    hasEdit:true\r\n                })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n\r\n                let tmpe = clone(that.edges[deleteindex])\r\n                tmpe.startpoint = clone(that.pointData[start])\r\n                tmpe.endpoint = clone(that.pointData[end])\r\n                tmpe.flag = false\r\n                editEdges.push(tmpe)\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n                if(that.child.bubbleState()){\r\n                    //console.log(\"delete one edge\")\r\n                    //console.log(editEdges)\r\n                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                }\r\n\r\n\r\n                editPoints = []\r\n                editEdges = []\r\n\r\n                that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n\r\n                that.optimizeMST(true)\r\n\r\n                for (var k in that.catPointDict){\r\n                    that.findCircle(k)\r\n                }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n            //else if(event.button == 1){\r\n            //    that.child.handleEdgeWidth(event, this)\r\n            //}\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    applyEdit(){\r\n        this.edges=this.tempEdges\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n\r\n        this.drawEdges()\r\n        this.setState({\r\n            hasEdit:false,\r\n            edges:this.edges,\r\n            pointData:this.pointData\r\n        })\r\n\r\n        //console.log(\"applyEdit\")\r\n        //console.log(tmpEditEdges)\r\n        //console.log(this.edges)\r\n\r\n        //let tmprealEditEdges = []\r\n//\r\n        //for(let i = 0; i < this.edges.length;i ++){\r\n        //    for(let j = 0; j < tmpEditEdges.length; j ++){\r\n        //        if(this.edges[i].start == tmpEditEdges[j].start && this.edges[i].end == tmpEditEdges[j].end){\r\n        //            let tmpe = clone(this.edges[i])\r\n        //            tmpe.flag = true\r\n        //            tmpe.id = i\r\n        //            tmprealEditEdges.push(tmpe)\r\n        //            break;\r\n        //        }\r\n        //    }\r\n        //}\r\n\r\n        if(this.child.bubbleState()){\r\n            this.child.editReDraw([], tmpEditEdges, this.pointData, this.edges)\r\n        }\r\n\r\n        tmpEditEdges = []\r\n    }\r\n\r\n    drawOneEdgeAfterEdit(edges,index){\r\n\r\n        edges[index].SVGElement=[]\r\n        let oneEdge=edges[index]\r\n        let that=this\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                d3.selectAll(\".deleteOpEdge\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                    })\r\n                    .remove()\r\n                let start=edges[deleteindex].start\r\n                let end=edges[deleteindex].end\r\n                that.deletedEdge.push([start,end])\r\n\r\n                // that.deleteEdge(deleteindex)\r\n                that.optimizeMST(true)\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            // console.log()\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    checkCircle(k){\r\n        let catEdges=[]\r\n        let nodeDegree={}\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(this.edges[i].cat==k){\r\n                catEdges.push(this.edges[i])\r\n                let start=this.edges[i].start\r\n                let end=this.edges[i].end\r\n                if(!nodeDegree.hasOwnProperty(start)){\r\n                    nodeDegree[start]=[]\r\n                }\r\n                nodeDegree[start].push(i)\r\n                if(!nodeDegree.hasOwnProperty(end)){\r\n                    nodeDegree[end]=[]\r\n                }\r\n                nodeDegree[end].push(i)\r\n            }\r\n        }\r\n        let finish=false\r\n        while(!finish){\r\n            finish=true\r\n            for(var p in nodeDegree){\r\n                if(nodeDegree[p].length==1){\r\n                    finish=false\r\n                    let index=nodeDegree[p][0]\r\n                    let start=this.edges[index].start\r\n                    let end=this.edges[index].end\r\n                    for (let i=0;i<nodeDegree[start].length;i++){\r\n                        if(nodeDegree[start][i]==index){\r\n                            nodeDegree[start].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                    for (let i=0;i<nodeDegree[end].length;i++){\r\n                        if(nodeDegree[end][i]==index){\r\n                            nodeDegree[end].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let circleEdges=[]\r\n        for (var p in nodeDegree){\r\n            if(nodeDegree[p].length>0){\r\n                for (let i=0;i<nodeDegree[p].length;i++){\r\n                    let edgeindex=nodeDegree[p][i]\r\n                    let has=false\r\n                    for (let j=0;j<circleEdges.length;j++){\r\n                        if(circleEdges[j]==edgeindex){\r\n                            has=true\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!has){\r\n                        circleEdges.push(edgeindex)\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        // console.log(nodeDegree,circleEdges)\r\n        return circleEdges\r\n    }\r\n\r\n    findCircle(lastcat){\r\n        let that=this\r\n        let circleEdges=that.checkCircle(lastcat)\r\n        if(circleEdges.length>0){\r\n            let scores=[]\r\n            for (let i=0;i<circleEdges.length;i++){\r\n                let index=circleEdges[i]\r\n\r\n                let start=that.pointData[that.edges[index].start]\r\n                let end=that.pointData[that.edges[index].end]\r\n                let crossnum=0\r\n                if(that.isAdded(that.edges[index].start,that.edges[index].end)){\r\n                    scores.push(-1)\r\n                }\r\n                else{\r\n                    for (let e=0;e<that.edges.length;e++){\r\n                        let e1=that.pointData[that.edges[e].start]\r\n                        let e2=that.pointData[that.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&that.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //cal distance\r\n                    let distance=that.calDistance(start,end)\r\n                    //cal num of other points\r\n                    let mess=that.calEdgeMess(start,end)\r\n                    let score=weightCross*crossnum+weightDistance*distance/that.maxDis+weightMess*mess\r\n                    scores.push(score)\r\n                }\r\n\r\n                /*                                    d3.select(svgid)\r\n                                                        .select(\"#edgeGroup\")\r\n                                                        .selectAll(\"line\")\r\n                                                        .filter(function(){\r\n                                                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                                                        })\r\n                                                        .attr(\"stroke\",\"blue\")\r\n                                                        .on(\"mouseover\",function(){\r\n                                                            console.log(scores[i])\r\n                                                        })*/\r\n            }\r\n\r\n            let worstindex=-1\r\n            let worstscore=-100\r\n            for (let i=0;i<scores.length;i++){\r\n                if(scores[i]>worstscore){\r\n                    worstscore=scores[i]\r\n                    worstindex=i\r\n                }\r\n            }\r\n            let worstEdge=that.edges[circleEdges[worstindex]]\r\n\r\n            //let tmpe = clone(worstEdge)\r\n            //tmpe.startpoint = clone(worstEdge.start)\r\n            //tmpe.endpoint = clone(worstEdge.end)\r\n            //tmpe.flag = false\r\n            //tmpEditEdges.push(tmpe)\r\n\r\n\r\n            //console.log(\"WorstEdge: \")\r\n            //console.log(circleEdges)\r\n            //console.log(worstEdge)\r\n            //console.log(that.edges)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==worstEdge.id\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-width\",5)\r\n            // console.log(weightMess)\r\n\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        colors = this.props.colorArray\r\n        this.setState({\r\n            colorArray:colors\r\n        })\r\n\r\n        d3.selectAll(\"circle\").remove();\r\n        d3.selectAll(\"rect\").remove();\r\n        svg = d3.select(svgid);\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        var reroutingEPS=80\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            console.log(\"dragging points......\")\r\n            let svg=d3.select(svgid)\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            // console.log(POINT_EDGE_EPS,DBSCAN_EPS)\r\n            if(that.itemShape==\"circle\"){\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n            //let tmpp1 = clone(that.pointData[nodeindex])\r\n            //tmpp1.flag = false;\r\n            //editPoints.push(tmpp1)\r\n            //subOldPoints.push(tmpp1)\r\n\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n\r\n            //let tmpp = clone(that.pointData[nodeindex])\r\n            //tmpp.id = nodeindex\r\n            //tmpp.flag = true\r\n            //editPoints.push(tmpp)\r\n            //addNewPoints.push(tmpp)\r\n\r\n            let deleteEdges=[]\r\n            let reroutingEdges=[]\r\n            let thiscat=that.pointData[nodeindex].cat\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let startpoint=that.pointData[that.edges[i].start]\r\n                let endpoint=that.pointData[that.edges[i].end]\r\n                let pointedgedis=PointToSegDist(event.x,event.y,startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(that.edges[i].start==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(tmpp1)\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(that.edges[i].end==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(tmpp1)\r\n                    //tmpe.flag = false;\r\n                    ////subOldEdges.push(tmpe)\r\n                    //editEdges.push(tmpe)\r\n                }\r\n                else if((thiscat==that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2)){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n                else if(thiscat!=that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2){\r\n                    reroutingEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // console.log(deleteEdges)\r\n\r\n            for(let i=0;i<deleteEdges.length;i++){\r\n                that.deleteEdge(deleteEdges[i])\r\n                for(let j=i+1;j<deleteEdges.length;j++){\r\n                    if(deleteEdges[i]<deleteEdges[j]){\r\n                        deleteEdges[j]=deleteEdges[j]-1\r\n                    }\r\n                }\r\n                for(let j=i+1;j<reroutingEdges.length;j++){\r\n                    if(deleteEdges[i]<reroutingEdges[j]){\r\n                        reroutingEdges[j]=reroutingEdges[j]-1\r\n                    }\r\n                }\r\n            }\r\n\r\n            that.optimizeMST(false)\r\n\r\n            for (let i=0;i<reroutingEdges.length;i++){\r\n\r\n\r\n                let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                tmpe.startpoint = clone(that.pointData[tmpe.start])\r\n                tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                tmpe.flag = false\r\n                that.edges[reroutingEdges[i]].preEdge = clone(tmpe)\r\n                that.edges[reroutingEdges[i]].new = true\r\n                that.edges[reroutingEdges[i]].rerouting = true\r\n\r\n\r\n                that.surfaceRoutingEdge(that.edges[reroutingEdges[i]])\r\n                d3.selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n                d3.selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n\r\n                that.drawOneEdge(reroutingEdges[i])\r\n\r\n\r\n\r\n                //let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                //tmpe.id = reroutingEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                // addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            //that.child.getData()\r\n            //for(let idx1 = 0; idx1 < addNewPoints.length; idx1 ++){\r\n            //    for(let idx2 = 0; idx2 < that.edges.length; idx2 ++){\r\n            //        if(that.edges[idx2].start == addNewPoints[idx1].id || that.edges[idx2].end == addNewPoints[idx1].id){\r\n            //            let tmpe = clone(that.edges[idx2])\r\n            //            tmpe.id = idx2\r\n            //            addNewEdges.push(tmpe)\r\n            //            //console.log(\"flagflagflag\")\r\n            //        }\r\n            //    }\r\n            //}\r\n\r\n\r\n\r\n\r\n\r\n            // d3.select(this).attr(\"stroke\",\"none\")\r\n\r\n        }\r\n\r\n        function dragstart() {\r\n            console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            // that.draggedIndex=parseInt(d3.select(this).attr(\"index\"))\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n            that.draggedIndex=nodeindex\r\n\r\n            preEdgeDict = {}\r\n            preEdges = []\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                that.edges[i].new = false;\r\n                that.edges[i].rerouting = false;\r\n                that.edges[i].startpoint = clone(that.pointData[st])\r\n                that.edges[i].endpoint = clone(that.pointData[en])\r\n\r\n                if(!preEdgeDict.hasOwnProperty(st)){\r\n                    preEdgeDict[st] = {}\r\n                }\r\n                preEdgeDict[st][en] = i\r\n\r\n                preEdges.push(that.edges[i])\r\n            }\r\n\r\n            // add old point\r\n            let tmpp1 = clone(that.pointData[nodeindex])\r\n            prePoint = tmpp1\r\n            tmpp1.flag = false\r\n            editPoints.push(tmpp1)\r\n\r\n            //preEdges = clone(that.edges)\r\n\r\n            //delete linked edges\r\n            /*            let newedges=[]\r\n            let deleteindex=[]\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let start=that.edges[i].start\r\n                let end=that.edges[i].end\r\n                if(start==nodeindex||end==nodeindex){\r\n                    console.log(i)\r\n                    d3.select(svgid)\r\n                        .select(\"#edgeGroup\")\r\n                        .selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==i\r\n                        })\r\n                        // .attr(\"stroke\",\"red\")\r\n                        .remove()\r\n                    deleteindex.push(i)\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))==i\r\n                        })\r\n                        // .attr(\"opacity\",1)\r\n                        .remove()\r\n                }\r\n                else{\r\n                    newedges.push(that.edges[i])\r\n                }\r\n            }\r\n            let influencedEdges=[]\r\n            let influencedControlPoints=[]\r\n            for (let i=0;i<deleteindex.length;i++) {\r\n                let idx=deleteindex[i]\r\n                let inflines=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))>idx\r\n                    })\r\n                influencedEdges.push(inflines)\r\n\r\n                let infpoints=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))>idx\r\n                    })\r\n                influencedControlPoints.push(infpoints)\r\n            }\r\n                for (let i=0;i<influencedEdges.length;i++){\r\n                    let infedges=influencedEdges[i]\r\n                    infedges.attr(\"index\",function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                    })\r\n            }\r\n                for(let i=0;i<influencedControlPoints.length;i++){\r\n                    let infcpoints=influencedControlPoints[i]\r\n                    infcpoints.attr(\"edgeindex\",function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                        })\r\n                }\r\n\r\n            that.edges=newedges\r\n            for(let i=0;i<that.edges.length;i++){\r\n                that.edges[i].id=i\r\n            }*/\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        function dragend(){\r\n            console.log(\"end!\")\r\n            let nodeindex = parseInt(d3.select(this).attr(\"index\"))\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"none\")\r\n\r\n            // add new point\r\n            let tmpp = clone(that.pointData[nodeindex])\r\n            tmpp.id = nodeindex\r\n            tmpp.flag = true\r\n            editPoints.push(tmpp)\r\n\r\n            /*\r\n            // delete old edges\r\n            let thiscat = that.pointData[nodeindex].cat\r\n            let ex = that.pointData[nodeindex].x\r\n            let ey = that.pointData[nodeindex].y\r\n            //let updateidx = {}\r\n            for(let i = 0;i < preEdges.length; i ++){\r\n                let startpoint=that.pointData[preEdges[i].start]\r\n                let endpoint=that.pointData[preEdges[i].end]\r\n                let pointedgedis=PointToSegDist(ex, ey, startpoint.x, startpoint.y, endpoint.x, endpoint.y)\r\n                if(preEdges[i].start==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = clone(prePoint)\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(preEdges[i].end==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = clone(prePoint)\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if((thiscat == preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2)){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false;\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                    //    updateidx[preEdges[i].start] = {}\r\n                    //}\r\n//\r\n                    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n\r\n                }\r\n\r\n                //else if(thiscat != preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2){\r\n//\r\n                //    let tmpe = clone(preEdges[i])\r\n                //    tmpe.startpoint = that.pointData[tmpe.start]\r\n                //    tmpe.endpoint = that.pointData[tmpe.end]\r\n                //    tmpe.flag = false;\r\n                //    editEdges.push(tmpe)\r\n                //    //subOldEdges.push(tmpe)\r\n//\r\n                //    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                //    //    updateidx[preEdges[i].start] = {}\r\n                //    //}\r\n////\r\n                //    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n//\r\n                //}\r\n\r\n\r\n            }\r\n\r\n            // add new edges and rerouting edges\r\n            for(let i = 0;i < that.edges.length; i ++){\r\n\r\n                //if(that.edges[i].hasOwnProperty(\"new\")){\r\n                if(that.edges[i].new == true){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    if(that.edges[i].rerouting == true){\r\n                        let tmpe = clone(that.edges[i].preEdge)\r\n                        tmpe.flag = false\r\n                        editEdges.push(tmpe)\r\n                    }\r\n                }\r\n                //}\r\n\r\n\r\n                //let s = that.edges[i].start\r\n                //let e = that.edges[i].end\r\n                //let flag = false;\r\n                //if(s == nodeindex || e == nodeindex){\r\n                //    flag = true\r\n                //}\r\n//\r\n                //for(let st in updateidx){\r\n                //    for(let en in updateidx[st]){\r\n                //        if(s == st && e == en){\r\n                //            flag = true\r\n                //            break\r\n                //        }\r\n                //    }\r\n                //}\r\n//\r\n                //if(flag){\r\n                //    let tmpe = clone(that.edges[i])\r\n                //    tmpe.id = i\r\n                //    tmpe.flag = true\r\n                //    editEdges.push(tmpe)\r\n                //}\r\n\r\n\r\n            }\r\n\r\n             */\r\n\r\n            editEdges = []\r\n            curEdgeDict = {}\r\n\r\n            // Add New Edges\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                if(!curEdgeDict.hasOwnProperty(st)){\r\n                    curEdgeDict[st] = {}\r\n                }\r\n                curEdgeDict[st][en] = i\r\n                let vnodes1 = clone(that.edges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                // same flag\r\n                let flag = true\r\n                // exist flag\r\n                let flag1 = true\r\n                // judge st --> en\r\n                if(preEdgeDict.hasOwnProperty(st)){\r\n                    if(preEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag point?\r\n                        // startpoint\\endpoint\\control points\r\n                        let idx = preEdgeDict[st][en]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].startpoint\r\n                        let en2_p = preEdges[idx].endpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                //judge en --> st\r\n                if(preEdgeDict.hasOwnProperty(en)){\r\n                    if(preEdgeDict[en].hasOwnProperty(st)){\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag poing?\r\n                        flag1 = false\r\n                        let idx = preEdgeDict[en][st]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].endpoint\r\n                        let en2_p = preEdges[idx].startpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // Delete Old Edges\r\n            for(let i = 0; i < preEdges.length; i ++){\r\n                let st = preEdges[i].start\r\n                let en = preEdges[i].end\r\n                let vnodes1 = clone(preEdges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                let flag = true\r\n                let flag1 = true\r\n                if(curEdgeDict.hasOwnProperty(st)){\r\n                    if(curEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[st][en]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                if(curEdgeDict.hasOwnProperty(en)){\r\n                    if(curEdgeDict[en].hasOwnProperty(st)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[en][st]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",dragend)\r\n\r\n\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2 && !that.props.isedit){\r\n                console.log(\"click\")\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                    let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                    d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                        let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n\r\n                                let tmpe = clone(that.edges[that.edges.length - 1])\r\n                                tmpe.id = that.edges.length - 1\r\n                                tmpe.flag = true\r\n                                editEdges.push(tmpe)\r\n                                that.setState({\r\n                                    pointData: that.pointData\r\n                                })\r\n\r\n                                that.setState({\r\n                                    edges: that.edges\r\n                                })\r\n\r\n                                //console.log(that.edges)\r\n\r\n                                if(that.child.bubbleState()){\r\n                                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                                }\r\n\r\n                                editPoints = []\r\n                                editEdges = []\r\n\r\n\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n\r\n                            idx = \"#\" + d3.select(this).attr(\"id\")\r\n\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n                                .attr(\"id\",d3.select(this).attr(\"id\"))\r\n\r\n\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(event.button==2 && that.props.isedit){\r\n\r\n                let idx = parseInt(d3.select(event.path[0]).attr(\"index\"))\r\n\r\n                // delete node and edges\r\n                let catarray = that.pointData[idx].catArray\r\n                for(let c = 0; c < catarray.length; c ++){\r\n                    let nowcat = catarray[c]\r\n                    for(let j = 0; j < that.catPointDict[nowcat].length; j ++){\r\n                        if(that.catPointDict[nowcat][j].id == idx){\r\n                            that.catPointDict[nowcat].splice(j, 1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for(let i = that.edges.length - 1; i >= 0; i --){\r\n                    let st = that.edges[i].start\r\n                    let en = that.edges[i].end\r\n                    if(st == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                    else if(en == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                }\r\n\r\n                that.pointData.splice(idx, 1);\r\n\r\n                // modify svg index and data index\r\n                d3.selectAll(\"#edgeGroup\").remove()\r\n                d3.selectAll(\"#pointGroup\").remove()\r\n\r\n                for(let i = 0; i < that.pointData.length; i ++){\r\n                    if(that.pointData[i].id > idx){\r\n                        that.pointData[i].id -= 1\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < that.edges.length; i ++){\r\n                    if(that.edges[i].start > idx){\r\n                        that.edges[i].start -= 1\r\n                    }\r\n                    if(that.edges[i].end > idx){\r\n                        that.edges[i].end -= 1\r\n                    }\r\n                }\r\n\r\n                that.drawPointData()\r\n                that.drawEdges()\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n\r\n                console.log(\"delete pointdata!\")\r\n\r\n            }\r\n        }\r\n\r\n        let items=[]\r\n        d3.select(svgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        d3.select(opsvgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        // this.itemShape=\"circle\"\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    countEdgeCrossingWithRouting(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let lines1=[]\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vnodes=this.edges[i].virtrualNodes\r\n                lines1.push([start1.x,start1.y])\r\n                for (let p=0;p<vnodes.length;p++){\r\n                    lines1.push(vnodes[p])\r\n                }\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            else{\r\n                lines1.push([start1.x,start1.y])\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let lines2=[]\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat==start2.cat){\r\n                    continue\r\n                }\r\n                if(this.edges[j].virtrual){\r\n                    let vnodes=this.edges[j].virtrualNodes\r\n                    lines2.push([start2.x,start2.y])\r\n                    for (let p=0;p<vnodes.length;p++){\r\n                        lines2.push(vnodes[p])\r\n                    }\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                else{\r\n                    lines2.push([start2.x,start2.y])\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                for (let l1=0;l1<lines1.length-1;l1++){\r\n                    let p1={x:lines1[l1][0],y:lines1[l1][1]}\r\n                    let p2={x:lines1[l1+1][0],y:lines1[l1+1][1]}\r\n                    for (let l2=0;l2<lines2.length-1;l2++){\r\n                        let p3={x:lines2[l2][0],y:lines2[l2][1]}\r\n                        let p4={x:lines2[l2+1][0],y:lines2[l2+1][1]}\r\n                        if(this.checkEdgeCrossing(p1,p2,p3,p4)){\r\n                            count+=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n        console.log(\"num of edge crossing:\" +count)\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    createLocalTree(points){\r\n\r\n        //1. find center point\r\n        //2. generate tree\r\n        let midx=0\r\n        let midy=0\r\n        for (let i=0;i<points.length;i++){\r\n            midx+=points[i].x\r\n            midy+=points[i].y\r\n        }\r\n        midx=midx/points.length\r\n        midy=midy/points.length\r\n        let midnode={\r\n            x:midx,\r\n            y:midy\r\n        }\r\n        let minDis=Number.MAX_VALUE\r\n        let minindex=-1\r\n        for (let i=0;i<points.length;i++){\r\n            let dis=this.calDistance(midnode,points[i])\r\n            if(dis<minDis){\r\n                minDis=dis\r\n                minindex=i\r\n            }\r\n        }\r\n\r\n\r\n\r\n        for (let i=0;i<points.length;i++){\r\n            if(i!=minindex){\r\n                this.edges.push({\r\n                    start:points[minindex].id,\r\n                    end:points[i].id,\r\n                    virtrual:false,\r\n                    virtrualNodes:[],\r\n                    cat:points[i].cat,\r\n                    isLocalTree:true\r\n                })\r\n                this.graph.addEdge(points[minindex].id,points[i].id)\r\n            }\r\n        }\r\n\r\n\r\n\r\n        // console.log(this.edges)\r\n        /*        var g = new jsgraphs.Graph(this.pointData.length);\r\n                for (let i=0;i<g.V;i++){\r\n                    g.node(i).label=this.pointData[i].cat\r\n                }*/\r\n\r\n    }\r\n\r\n    initWithNoCluster(){\r\n        for(var k in this.catPointDict){\r\n            this.clusterDict[k]=[]\r\n            for (let i=0;i<this.catPointDict[k].length;i++){\r\n                this.clusterDict[k].push([this.catPointDict[k][i]])\r\n            }\r\n        }\r\n        console.log(this.clusterDict)\r\n    }\r\n\r\n    generateTreeWithHierarchical(){\r\n        // this.findCluster()\r\n        this.initWithNoCluster()\r\n        //merging clusters according to this.edges\r\n\r\n        let preAddedClusters=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            let cat=start.cat\r\n            let catclusters=this.clusterDict[cat]\r\n            let startclusterid=-1\r\n            let endclusterid=-1\r\n            for(let c=0;c<catclusters.length;c++){\r\n                for (let p=0;p<catclusters[c].length;p++){\r\n                    if(catclusters[c][p].id==start.id){\r\n                        startclusterid=c\r\n                    }\r\n                    if(catclusters[c][p].id==end.id){\r\n                        endclusterid=c\r\n                    }\r\n                    if(startclusterid!=-1&&endclusterid!=-1){\r\n                        break\r\n                    }\r\n                }\r\n                if(startclusterid!=-1&&endclusterid!=-1){\r\n                    break\r\n                }\r\n\r\n            }\r\n            if(startclusterid!=-1&&endclusterid!=-1&&startclusterid!=endclusterid){\r\n                // console.log(this.clusterDict[cat].length)\r\n\r\n                //merge two cluster\r\n                let merged=catclusters[startclusterid]\r\n                for(let p=0;p<catclusters[endclusterid].length;p++){\r\n                    merged.push(catclusters[endclusterid][p])\r\n                }\r\n                let newclusterdict=[]\r\n                for (let c=0;c<catclusters.length;c++){\r\n                    if(c!=startclusterid&&c!=endclusterid){\r\n                        newclusterdict.push(catclusters[c])\r\n                    }\r\n                }\r\n                newclusterdict.push(merged)\r\n                this.clusterDict[cat]=newclusterdict\r\n                preAddedClusters.push([cat,newclusterdict.length-1])\r\n                console.log(cat)\r\n            }\r\n\r\n        }\r\n\r\n        this.createGraphWithCluster()\r\n\r\n        for (var k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let iscontinue=false\r\n                for (let c=0;c<preAddedClusters.length;c++){\r\n                    let cat=preAddedClusters[c][0]\r\n                    let id=preAddedClusters[c][1]\r\n                    if(k==cat&&id==i){\r\n                        iscontinue=true\r\n                    }\r\n                }\r\n                if(iscontinue){\r\n                    continue\r\n                }\r\n                else{\r\n                    this.createLocalTree(this.clusterDict[k][i])\r\n                }\r\n            }\r\n        }\r\n        // console.log(this.clusterDict)\r\n        // console.log(this.edges.length)\r\n\r\n        this.drawEdges()\r\n        this.hierarchicalMergeV2()\r\n        // console.log(this.edges.length)\r\n    }\r\n\r\n    findCluster(){\r\n\r\n        for (var k in this.catPointDict){\r\n            // console.log(k)\r\n\r\n            var dbscan = new clustering.DBSCAN();\r\n            let dataset=[]\r\n            let pointDataSet=[]\r\n// parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster\r\n\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                // if(this.pointData[this.catPointDict[k][i].id].multicat){\r\n                //     let catarr=this.pointData[this.catPointDict[k][i].id].catArray\r\n                //     catarr=catarr.map((val)=> parseInt(val) )\r\n                //     let minCatIndex=Math.min.apply(null,catarr)\r\n                //     if(parseInt(k)==minCatIndex){\r\n                //         dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                //         pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                //     }\r\n                // }\r\n                // else{\r\n                dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                // }\r\n\r\n            }\r\n            // console.log(dataset)\r\n            // console.log(pointDataSet)\r\n\r\n            if(dataset.length>0){\r\n                this.clusterDict[k]=[]\r\n                this.noiseDict[k]=[]\r\n                var clusters = dbscan.run(dataset, DBSCAN_EPS, 2);\r\n                // console.log(clusters, dbscan.noise);\r\n                let point\r\n                for(let i=0;i<clusters.length;i++){\r\n                    let clusterPoints=[]\r\n                    for (let j=0;j<clusters[i].length;j++){\r\n                        clusterPoints.push(pointDataSet[clusters[i][j]])\r\n                        // console.log(point)\r\n                        /*                    let point=dataset[clusters[i][j]]\r\n                                            d3.select(svgid)\r\n                                                .append(\"circle\")\r\n                                                .attr(\"cx\",point[0])\r\n                                                .attr(\"cy\",point[1])\r\n                                                .attr(\"r\",10)\r\n                                                .attr(\"fill\",\"none\")\r\n                                                .attr(\"stroke\",\"red\")\r\n                                                .attr(\"stroke-width\",2)*/\r\n                    }\r\n                    // this.createLocalTree(clusterPoints)\r\n                    this.clusterDict[k].push(clusterPoints)\r\n                }\r\n                for (let i=0;i<dbscan.noise.length;i++){\r\n                    this.clusterDict[k].push([pointDataSet[dbscan.noise[i]]])\r\n                }\r\n            }\r\n\r\n        }\r\n        //console.log(this.clusterDict)\r\n        // console.log(this.noiseDict)\r\n    }\r\n\r\n    createGraph(){\r\n\r\n    }\r\n\r\n    createGraphWithCluster(){\r\n        let clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n\r\n\r\n            }\r\n\r\n        }\r\n        this.clusterArr=clusterArr\r\n        //console.log(this.clusterDict)\r\n        var g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n        console.log(g.V)\r\n\r\n        var g2 = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g2.V;i++){\r\n            g2.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g2\r\n        //console.log(g,g2)\r\n        for (let i=0;i<this.edges.length;i++){\r\n            this.graph.addEdge(this.edges[i].start,this.edges[i].end)\r\n        }\r\n\r\n    }\r\n\r\n    calClusterDistance(cluster1,cluster2){\r\n        let dissum=0\r\n        let num=0\r\n        let mindis=Number.MAX_VALUE\r\n        for(let i=0;i<cluster1.length;i++){\r\n            for (let j=0;j<cluster2.length;j++){\r\n                // dissum+=this.calDistance(cluster1[i],cluster2[j])\r\n                // num+=1\r\n                let dis=this.calDistance(cluster1[i],cluster2[j])\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                }\r\n            }\r\n        }\r\n        return mindis\r\n    }\r\n\r\n    sortEdgesGlobalWithCluster(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.clusterDict){\r\n            for(let i=0;i<this.clusterDict[k].length;i++){\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let dis=this.calClusterDistance(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    // let mess=this.calEdgeMess(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    disArray.push(dis)\r\n                    // messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    // tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                    tempedges.push([this.clusterDict[k][i].id,this.clusterDict[k][j].id,dis])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            // let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            // edges.push([start,end,weight,dis,mess])\r\n            edges.push([start,end,weight,dis])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    findLinkBetweenCluster(cluster1,cluster2){\r\n        let mindis=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                if(!this.checkNewEdge(start,end)){\r\n                    flag=true\r\n                    let dis=this.calDistance(start,end)\r\n                    if(dis<mindis){\r\n                        mindis=dis\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return [flag,minstart,minend,mindis]\r\n    }\r\n\r\n    /*    findOptimalLink(cluster1,cluster2){\r\n            //let crossedge = []\r\n            let minScore=Number.MAX_VALUE\r\n            let bestStart=null\r\n            let bestEnd=null\r\n\r\n            let minScoreWithDis=Number.MAX_VALUE\r\n            let bestStartWithDis=null\r\n            let bestEndWithDis=null\r\n\r\n            let hasBest=false\r\n            for (let i=0;i<cluster1.length;i++){\r\n                let start=cluster1[i]\r\n                for(let j=0;j<cluster2.length;j++){\r\n                    let end=cluster2[j]\r\n                    //cal cross num\r\n                    let crossnum=0\r\n                    for (let e=0;e<this.edges.length;e++){\r\n                        let e1=this.pointData[this.edges[e].start]\r\n                        let e2=this.pointData[this.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //let tmpcross = [];\r\n\r\n                    //let elements = this.QTree.retrieve({\r\n                    //    x: Math.min(start.x,end.x),\r\n                    //    y: Math.min(start.y,end.y),\r\n                    //    width: Math.abs(start.x-end.x),\r\n                    //    height: Math.abs(start.y-end.y)\r\n                    //});\r\n\r\n                    //for (let e = 0;e < elements.length;e ++){\r\n                    //    let e1 = this.pointData[elements[e].start];\r\n                    //    let e2 = this.pointData[elements[e].end];\r\n                    //    if(e1.cat != start.cat && e1.cat != end.cat && this.checkEdgeCrossing(start,end,e1,e2)){\r\n                    //        crossnum += 1\r\n                    //        //tmpcross.push({start:this.edges[e].start,end:this.edges[e].end})\r\n                    //        //tmpcross.push({start:this.edges[e].end,end:this.edges[e].start})\r\n                    //    }\r\n                    //}\r\n                    //crossnum = 5;\r\n\r\n                    //cal distance\r\n                    let distance=this.calDistance(start,end)\r\n\r\n\r\n                    //cal num of other points\r\n                    let mess=this.calEdgeMess(start,end)\r\n\r\n                    if(crossnum>maxCross){\r\n                        maxCross=crossnum\r\n                    }\r\n\r\n                    let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                    if(score<minScore){\r\n                        bestStart=start\r\n                        bestEnd=end\r\n                        minScore=score\r\n                        //crossedge = tmpcross\r\n                    }\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        if(score<minScoreWithDis){\r\n                            bestStartWithDis=start\r\n                            bestEndWithDis=end\r\n                            minScoreWithDis=score\r\n                            hasBest=true\r\n                            //crossedge = tmpcross\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            /!*      if(hasBest){\r\n                        // console.log(\"edge under threshhold\")\r\n                        return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                    }\r\n                    else{\r\n                        // console.log(\"no edge under threshhold\")\r\n                        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                    }*!/\r\n            return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n        }*/\r\n\r\n    findOptimalLink(cluster1,cluster2){\r\n        let minScore=Number.MAX_VALUE\r\n        let bestStart=null\r\n        let bestEnd=null\r\n\r\n        let minScoreWithDis=Number.MAX_VALUE\r\n        let bestStartWithDis=null\r\n        let bestEndWithDis=null\r\n\r\n        let hasBest=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n\r\n\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n\r\n                if(crossnum>maxCross){\r\n                    maxCross=crossnum\r\n                }\r\n\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                if(score<minScore){\r\n                    bestStart=start\r\n                    bestEnd=end\r\n                    minScore=score\r\n                }\r\n                if(distance<DISTANCE_THRESHHOLD){\r\n                    if(score<minScoreWithDis){\r\n                        bestStartWithDis=start\r\n                        bestEndWithDis=end\r\n                        minScoreWithDis=score\r\n                        hasBest=true\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /*        if(hasBest){\r\n                    // console.log(\"edge under threshhold\")\r\n                    return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                }\r\n                else{\r\n                    // console.log(\"no edge under threshhold\")\r\n                    return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                }*/\r\n        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n    }\r\n\r\n    /*    findMinScore(links){\r\n            let minScore=Number.MAX_VALUE\r\n            let minIndex=-1\r\n\r\n            let minScoreWithDistance=Number.MAX_VALUE\r\n            let minIndexWithDistance=-1\r\n            let hasBest=false\r\n            for(let i=0;i<links.length;i++){\r\n                if(links[i].score<minScore){\r\n                    minScore=links[i].score\r\n                    minIndex=i\r\n                }\r\n                if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                    minScoreWithDistance=links[i].score\r\n                    minIndexWithDistance=i\r\n                    hasBest=true\r\n                }\r\n            }\r\n            if(hasBest){\r\n                // console.log(\"yes\")\r\n                return links[minIndexWithDistance]\r\n            }\r\n            else{\r\n                // console.log(\"no\")\r\n                return links[minIndex]\r\n\r\n            }\r\n\r\n            // return links[minIndex]\r\n\r\n        }*/\r\n\r\n    findMinScoreTest(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=links.length-1;i>=0;i--) {\r\n            let id1 = links[i].clusterid1\r\n            let id2 = links[i].clusterid2\r\n            if(this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                continue;\r\n            }\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findMinScore(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=0;i<links.length;i++){\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isAdded(start,end){\r\n        for (let i=0;i<this.addedEdge.length;i++){\r\n            if(this.addedEdge[i][0]==start&&this.addedEdge[i][1]==end||this.addedEdge[i][0]==end&&this.addedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isDeleted(start,end){\r\n        for (let i=0;i<this.deletedEdge.length;i++){\r\n            if(this.deletedEdge[i][0]==start&&this.deletedEdge[i][1]==end||this.deletedEdge[i][0]==end&&this.deletedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    addLinksTest(id1,id2,k,cluster1,cluster2,e){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                let crossnum=0\r\n                let distance=this.calDistance(start,end)\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n                e.push(tmp)\r\n                this.idx++;\r\n            }\r\n        }\r\n    }\r\n\r\n    addLinks(id1,id2,k,cluster1,cluster2,e1,e2){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n\r\n                if(this.isDeleted(start.id,end.id)){\r\n                    tmp.score=Number.MAX_VALUE\r\n                    e2._d[this.idx] = tmp;\r\n                    e2.enq(this.idx);\r\n                    this.idx++;\r\n\r\n                }\r\n                else if(this.isAdded(start.id,end.id)){\r\n                    tmp.score=-1\r\n                    e1._d[this.idx] = tmp;\r\n                    e1.enq(this.idx);\r\n                    this.idx++;\r\n                }\r\n                else{\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        //V1\r\n                        //tmp.pid = e1._elements.length;\r\n\r\n                        e1._d[this.idx] = tmp;\r\n                        e1.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                    else{\r\n                        //V1\r\n                        //tmp.pid = e2._elements.length;\r\n\r\n                        e2._d[this.idx] = tmp;\r\n                        e2.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                }\r\n                //let nodetmp = {\r\n                //    x:Math.min(start.x,end.x),\r\n                //    y:Math.min(start.y,end.y),\r\n                //    width:Math.abs(start.x - end.x),\r\n                //    height:Math.abs(start.y - end.y),\r\n                //    idx:this.idx\r\n                //}\r\n                //this.edgesdict.push(nodetmp);\r\n                //this.QTree.insert(this.edgesdict[this.idx]);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    findBestLink(e){\r\n        let minScore = Number.MAX_VALUE;\r\n        let tmp;\r\n        for(let i = e.length - 1;i >= 0;i --){\r\n            let id1 = e[i].clusterid1;\r\n            let id2 = e[i].clusterid2;\r\n            if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                if(minScore > e[i].score){\r\n                    tmp = e[i];\r\n                    minScore = e[i].score;\r\n                }\r\n            }\r\n            else{\r\n                e.splice(i, 1);\r\n            }\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    recalculateSpanningTreeAfterEdit(edges){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                edges[edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        edges[edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<edges.length;i++){\r\n                                let start1=this.pointData[edges[i].start]\r\n                                let end1=this.pointData[edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            edges[edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    recalculateSpanningTree(){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(this.edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    hierarchicalMergeV2(){\r\n\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllClusterV2()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            this.drawEdges()\r\n            console.log()\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n/*                        d3.selectAll(\"line\")\r\n                            .remove()\r\n                        // .attr(\"stroke\",\"black\")\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",startp[0])\r\n                            .attr(\"y1\",startp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",endp[0])\r\n                            .attr(\"y1\",endp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")*/\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",endp[0])\r\n                    .attr(\"y1\",endp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n            this.drawOneEdge(this.edges.length-1)\r\n            console.log()\r\n        }\r\n        //console.log(maxCross)\r\n    }\r\n\r\n    hierarchicalMerge(){\r\n        // console.log(this.calDistance(this.pointData[120],this.pointData[171]))\r\n        // console.log(this.calDistance(this.pointData[47],this.pointData[188]))\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            let optimalLinks=[]\r\n            for (var k in this.clusterDict){\r\n                for (let i=0;i<this.clusterDict[k].length;i++){\r\n                    let id1=this.clusterDict[k][i].id\r\n                    for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                        let id2=this.clusterDict[k][j].id\r\n                        if(!this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                            let link=this.findOptimalLink(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                            optimalLinks.push({\r\n                                clusterid1:id1,\r\n                                clusterid2:id2,\r\n                                start:link[0],\r\n                                end:link[1],\r\n                                score:link[2],\r\n                                distance:link[3],\r\n                                cat:k\r\n                            })\r\n                        }\r\n                        else{\r\n                            continue\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            let bestLink=this.findMinScore(optimalLinks)\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2)\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n\r\n            // this.drawEdges()\r\n\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        //     // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n        }\r\n        console.log(maxCross)\r\n    }\r\n\r\n    mergeCluster(){\r\n        //average distance as distance between clusters\r\n        //find an optimal link with least crossing\r\n\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithCluster()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            // let mess=sortedEdges[i][4]\r\n\r\n\r\n\r\n            if(this.clusterArr[start].cat!=this.clusterArr[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n\r\n                let link=this.findLinkBetweenCluster(this.clusterArr[start].points,this.clusterArr[end].points)\r\n\r\n                if(link[0]){\r\n                    this.clustergraph.addEdge(start,end)\r\n                    this.graph.addEdge(link[1].id,link[2].id)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:link[1].id,\r\n                        end:link[2].id,\r\n                        weight:link[3],\r\n                        dis:link[3],\r\n                        // mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        // mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n        // this.drawEdges()\r\n\r\n        while(!this.checkConnectBetweenCluster()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.findOptimalLink(this.clusterArr[start].points,this.clusterArr[end].points)\r\n                    removeEdggeList[i].weight=scores[3]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push({\r\n                        clusterstart:start,\r\n                        clusterend:end,\r\n                        start:scores[0].id,\r\n                        end:scores[1].id,\r\n                        weight:scores[2],\r\n                        crossnum:scores[2]\r\n                    })\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.clustergraph.addEdge(tempEdgeList[maxindex].clusterstart,tempEdgeList[maxindex].clusterend)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                // dis:tempEdgeList[maxindex].dis,\r\n                // mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // this.drawEdges()\r\n            console.log()\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n\r\n    }\r\n\r\n    editBackbone(){\r\n\r\n        editView = !editView\r\n\r\n        if(editView){\r\n            d3.select(\"svg\")\r\n                .selectAll(\".dataPoint\")\r\n                .remove()\r\n//\r\n            d3.select(\"svg\")\r\n                .selectAll(\"line\")\r\n                .remove()\r\n\r\n            //offsetX = 20;\r\n            //offsetY = 20;\r\n            //viewWidth = 40;\r\n            //viewHeight = 40\r\n//\r\n            //this.child.setViewBox(offsetX, offsetY, viewWidth, viewHeight)\r\n            //d3.select(\"#mainsvg\")\r\n            //    .attr(\"viewBox\",offsetX+\" \"+offsetY+\" \"+viewWidth+\" \"+viewHeight)\r\n\r\n            /*\r\n            let tx,ty,s\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                for(let i = 0; i < infostr.length; i ++){\r\n                    if(infostr[i] == '('){\r\n                        i ++\r\n                        while(infostr[i] != ','){\r\n                            tx += infostr[i ++]\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            ty += infostr[i ++]\r\n                        }\r\n                        while(infostr[i] != '('){\r\n                            i ++\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            s += infostr[i ++]\r\n                        }\r\n                        break\r\n                    }\r\n                }\r\n                tx = parseFloat(tx)\r\n                ty = parseFloat(ty)\r\n                s = parseFloat(s)\r\n            }\r\n\r\n             */\r\n\r\n\r\n            // d3.select(svgid).selectAll(\"*\").remove();\r\n            this.drawPointData()\r\n            this.drawEdges()\r\n\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                d3.selectAll('g').attr(\"transform\", infostr);\r\n            }\r\n\r\n            this.props.handleManually(false)\r\n            //this.child.getData()\r\n        }\r\n        else{\r\n            d3.selectAll(\"#edgeGroup\")\r\n                .remove()\r\n            d3.selectAll(\"#pointGroup\")\r\n                .remove()\r\n            this.child.afterEditReDraw()\r\n            //d3.selectAll(\"\")\r\n        }\r\n    }\r\n\r\n    editMST(){\r\n\r\n        this.issplit = !this.issplit;\r\n\r\n        if(this.issplit == true){\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n                .attr(\"style\",\"border:1px solid #000000\")\r\n\r\n            svgid = \"#leftsvg\"\r\n            opsvgid = '#mainsvg'\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n\r\n            this.drawPointData()\r\n\r\n            this.drawEdges()\r\n\r\n            this.props.handleManually(false)\r\n\r\n            //this.setState({\r\n            //    pointData: this.pointData\r\n            //})\r\n            //this.setState({\r\n            //    edges: this.edges\r\n            //})\r\n            //this.setState({\r\n            //    hasinit:true\r\n            //})\r\n//\r\n            //this.child.getData()\r\n\r\n        }\r\n        else{\r\n\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n            d3.selectAll(\"#edgeGroup\")\r\n                .remove()\r\n            d3.selectAll(\"#pointGroup\")\r\n                .remove()\r\n            this.child.afterEditReDraw()\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",1200 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",0)\r\n                .attr(\"height\",0)\r\n                .attr(\"style\",\"border:0px solid #000000\")\r\n\r\n\r\n\r\n            svgid = \"#mainsvg\"\r\n            opsvgid = '#leftsvg'\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleCreated(){\r\n        this.setState({\r\n            hascreated:true\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    saveSVG(){\r\n\r\n    }\r\n\r\n    saveData(){\r\n        let data\r\n        if(!this.state.hasinit){\r\n            data=this.props.pointData\r\n        }\r\n        else{\r\n            data=this.pointData\r\n        }\r\n        let content = JSON.stringify(data);\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"data.json\");\r\n\r\n    }\r\n\r\n    render(){\r\n        //return (\r\n        //    <div id={\"svgcontainer\"}>\r\n        //        <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n        //        </svg>\r\n        //        <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n        //        <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n        //    </div>)\r\n        return (\r\n            <div>\r\n                <div>\r\n                    {/*<Button onClick={this.saveData.bind(this)}>Save Data</Button>*/}\r\n                    {/*<Button onClick={this.saveSVG}>Save SVG</Button>*/}\r\n\r\n                </div>\r\n                <div style={{marginTop: 20 * ScreenHeight / BeforeHeight}}>\r\n                        <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData&&!this.state.hasinit||this.state.hasEdit? false:true}>\r\n                        {\r\n                            this.state.hasinit? \"Apply Changes\":\"Create Backbone\"\r\n                        }\r\n                    </Button>\r\n                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Switch checkedChildren=\"Edit Backbone\" unCheckedChildren=\"Edit Backbone\"  onClick={this.editBackbone.bind(this)}  disabled={this.state.hascreated? false:true}/>\r\n                    </div>\r\n\r\n                <AdaptiveIsovalue pointData={this.state.pointData} hasLoadData={this.props.hasLoadData} edges={this.state.edges} handleCreated={this.handleCreated.bind(this)} createMST={this.getData.bind(this)} onRef={this.onRef} colorArray={this.props.colorArray}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default HierarchicalCluster","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport * as d3 from \"d3\"\r\nimport \"./scale-canvas\"\r\nimport scaleCanvas from \"./scale-canvas\";\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass BMOAlgo extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.itemShape=\"rectangle\"\r\n        this.catPointDict={}\r\n        this.context=null\r\n        this.canvasWidth=1500\r\n        this.canvasHeight=1200\r\n        this.canvasRatio=1\r\n    }\r\n\r\n    componentDidMount() {\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n\r\n\r\n                this.init()\r\n                this.centralizeData()\r\n                this.drawPointData()\r\n                this.loadEdgeData()\r\n                    .then(res=>res.json())\r\n                    .then(data=>{\r\n                        console.log(data)\r\n                        this.edges=data\r\n                        for (let i=0;i<this.edges.length;i++){\r\n                            this.edges[i].start=parseInt(this.edges[i].start)\r\n                            this.edges[i].end=parseInt(this.edges[i].end)\r\n\r\n                        }\r\n                        this.drawEdges()\r\n                        this.getPixelImage()\r\n\r\n                    })\r\n\r\n            })\r\n\r\n    }\r\n\r\n    getPixelImage(){\r\n        console.log(this.canvasRatio)\r\n\r\n        // this.context.strokeStyle=\"red\"\r\n        // this.context.lineWidth=2\r\n        // this.context.rect(imageX,imageY,imageWidth,imageHeight)\r\n        // this.context.stroke()\r\n\r\n        // console.log(imageWidth,imageHeight)\r\n        let imageData=this.context.getImageData(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n        this.context.clearRect(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n        // let data=imageData.data\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n\r\n\r\n\r\n        for (let i=0;i<imageData.data.length;i+=4){\r\n            // if(imageData.data[i]>0||imageData.data[i+1]>0||imageData.data[i+2]>0){\r\n                if(imageData.data[i+3]>0){\r\n\r\n                    // console.log(imageData.data[i],imageData.data[i+1],imageData.data[i+2])\r\n                // console.log(i)\r\n                // imageData.data[i]=255\r\n                // imageData.data[i+1]=0\r\n                // imageData.data[i+2]=0\r\n                let index=i/4\r\n                let x=index%imageData.width\r\n                let y=parseInt(index/imageData.width)\r\n                // imageData.data[i+3]=0\r\n                if(y<miny){\r\n                    miny=y\r\n                }\r\n            if(y>maxy){\r\n                maxy=y\r\n            }\r\n            if(x<minx){\r\n                minx=x\r\n            }\r\n            if(x>maxx){\r\n                maxx=x\r\n            }\r\n            }\r\n        }\r\n        // this.context.strokeStyle=\"red\"\r\n        // this.context.lineWidth=2\r\n        // this.context.rect(minx,miny,maxx-minx,maxy-miny)\r\n        // this.context.stroke()\r\n\r\n        this.context.putImageData(imageData,0,0)\r\n\r\n        console.log(imageData)\r\n\r\n        let width=maxx-minx\r\n        let height=maxy-miny\r\n        let newImageData=[]\r\n        for(let i=miny;i<maxy+1;i++){\r\n            let oneline=[]\r\n\r\n            for (let j=minx;j<maxx+1;j++){\r\n                let index=i*imageData.width+j\r\n                if(imageData.data[index*4+3]>0){\r\n                    oneline.push(1)\r\n                }\r\n                else{\r\n                    oneline.push(0)\r\n                }\r\n            }\r\n            newImageData.push(oneline)\r\n        }\r\n        console.log(newImageData)\r\n\r\n        fetch('http://localhost:3001/processImage',{\r\n            method:'post',//改成post\r\n            mode: 'cors',//跨域\r\n            headers: {//请求头\r\n                'Content-Type': 'application/x-www-form-urlencoded'\r\n            },\r\n            body:'image='+JSON.stringify(newImageData)//向服务器发送的数据\r\n        })\r\n            .then(res=>res.text())\r\n            .then(data=>{\r\n                console.log(data)\r\n\r\n            })\r\n        \r\n        // this.context.clearRect(0,0,this.canvasWidth,this.canvasHeight)\r\n        // this.context.clearRect(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,width,color){\r\n        this.context.lineWidth = width;          //设置线宽状态\r\n        this.context.strokeStyle = color ;  //设置线的颜色状态\r\n        this.context.moveTo (x1,y1);       //设置起点状态\r\n        this.context.lineTo (x2,y2);       //设置末端状态\r\n\r\n        this.context.stroke();\r\n    }\r\n\r\n    drawEdges(){\r\n        // d3.selectAll(\"line\").remove()\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            this.drawLine(this.pointData[start].x,this.pointData[start].y,this.pointData[end].x,this.pointData[end].y,2,\"black\")\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    loadEdgeData(){\r\n        let that=this\r\n        return fetch('/data/BubbleSetEdge1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n\r\n    }\r\n\r\n    init(){\r\n        this.context=document.getElementById(\"maincanvas\").getContext(\"2d\")\r\n        this.canvasRatio=scaleCanvas(document.getElementById(\"maincanvas\"),this.context,this.canvasWidth,this.canvasHeight)\r\n        // console.log(this.context)\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n                let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }\r\n        this.maxX=maxx+move[0]\r\n        this.minX=minx+move[0]\r\n        this.maxY=maxy+move[1]\r\n        this.minY=miny+move[1]\r\n        // this.drawRect(this.minX,this.minY,this.maxX-this.minX,this.maxY-this.minY,\"red\")\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n    }\r\n\r\n    drawPointData(){\r\n        for(let i=0;i<this.pointData.length;i++){\r\n            this.drawPoint(this.pointData[i].x,this.pointData[i].y,this.pointData[i].radius,colors[this.pointData[i].cat])\r\n        }\r\n    }\r\n\r\n\r\n    drawPoint(x,y,r,color){\r\n\r\n        this.context.beginPath()\r\n        this.context.fillStyle=color\r\n        this.context.arc(x, y, r, 0, Math.PI * 2, false);\r\n        this.context.fill()\r\n        this.context.closePath()\r\n    }\r\n\r\n    drawRect(x,y,w,h,color){\r\n        this.context.lineWidth=2\r\n        this.context.strokeStyle=color\r\n        this.context.rect(x-w/2,y-h/2,w,h)\r\n        this.context.stroke()\r\n    }\r\n\r\n    deletePoint(e){\r\n        e.stopPropagation()\r\n        let el=e.target\r\n        let index=d3.select(el).attr(\"index\")\r\n        this.points[index]=-1\r\n        d3.select(el).remove()\r\n        console.log(index)\r\n        d3.selectAll(\"text\")\r\n            .filter(function(d,i){\r\n                return d3.select(this).attr(\"index\")==index\r\n            })\r\n            .remove()\r\n        // console.log(this.points)\r\n    }\r\n\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <canvas id={\"maincanvas\"} width={\"1500\"} height={\"1200\"} >\r\n                </canvas>\r\n                {/*<button onClick={this.addCategory.bind(this)}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"800px\"}}>Add Category</button>*/}\r\n                {/*<input ref={(input)=>this.input=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"750px\"}}></input>*/}\r\n                {/*<button onClick={this.switchCategory.bind(this)}  style={{width:200,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"750px\",marginLeft:10}}>Change Category</button>*/}\r\n                {/*<button onClick={this.savePoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"700px\",marginLeft:10}}>Save</button>*/}\r\n                {/*<button onClick={this.loadPoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"700px\",marginLeft:10}}>Load</button>*/}\r\n                {/*<input ref={(input)=>this.input2=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"650px\"}}></input>*/}\r\n                {/*<button onClick={this.changeWidthHeight.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"650px\",marginLeft:10}}>Change Width and Height</button>*/}\r\n                {/*<label ref={(jsonoutput)=>this.jsonoutput=jsonoutput} style={{width:300,height:200,fontSize:\"10px\",position:\"absolute\",left:\"1550px\",bottom:\"300px\",marginLeft:10,overflow:\"scroll\"}}>*/}\r\n\r\n                {/*</label>*/}\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default BMOAlgo","import React, {Component} from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nclass AlgorithmEntry extends Component{\r\n\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[]\r\n    }\r\n\r\n    // eslint-disable-next-line\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    finishInput(){\r\n        if(this.props.pointData){\r\n            alert(\"Finish input and start creating spanning tree!\");\r\n            console.log(this.props.pointData);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <button onClick = {this.finishInput.bind(this)}>\r\n                Create MST\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport default AlgorithmEntry;","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport {drag} from \"d3\";\r\nimport AlgorithmEntry from \"./AlgorithmEntry\";\r\nimport './index.css';\r\nimport HierarchicalCluster from \"./HierarchicalCluster\";\r\nimport { Layout } from 'antd';\r\nimport { Button } from 'antd';\r\nimport { Select } from 'antd';\r\nimport { Menu } from 'antd';\r\nimport { Dropdown} from 'antd';\r\nimport { DownOutlined } from '@ant-design/icons';\r\nimport { Table, Radio, Divider } from 'antd';\r\nimport { Tag, Space } from 'antd'\r\nimport { Switch } from 'antd';\r\nimport { CloseOutlined, CheckOutlined } from '@ant-design/icons';\r\nimport { Pagination } from 'antd';\r\nimport {calDistance} from \"./util\";\r\nconst svgsaver=require(\"save-svg-as-png\")\r\n\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\nconst { Option } = Select;\r\nconst { Header, Footer, Sider, Content } = Layout;\r\n\r\n\r\n\r\nconst columns = [\r\n    {\r\n        title: 'Group',\r\n        dataIndex: 'name',\r\n        render: (text) => <a>{text}</a>,\r\n    },\r\n    {\r\n        title: 'Color',\r\n        key: 'tags',\r\n        dataIndex: 'tags',\r\n        render: tags => (\r\n            <>\r\n                {tags.map(tag => {\r\n                    let color = tag\r\n                    return (\r\n                        <Tag color={color} key={tag} >\r\n                            {tag}\r\n                        </Tag>\r\n                    );\r\n                })}\r\n            </>\r\n        ),\r\n    }\r\n];\r\n\r\nvar keynum = 1\r\nvar GroupDict = {}\r\nGroupDict['Group 0'] = 1\r\nvar cur_set = 0;\r\nvar FileSaver = require('file-saver');\r\n\r\n\r\nvar svgid=\"#mainsvg\"\r\nconst rowSelection = {\r\n    onChange: (selectedRowKeys, selectedRows) => {\r\n        cur_set = selectedRowKeys;\r\n        //console.log(`selectedRowKeys: ${selectedRowKeys}`, 'selectedRows: ', selectedRows);\r\n    },\r\n    getCheckboxProps: (record) => ({\r\n        disabled: record.name === 'Disabled User',\r\n        // Column configuration not to be checked\r\n        name: record.name,\r\n    }),\r\n};\r\n// var colorArray=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar colorArray=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colorArray=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colorArray=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar is_input = false;\r\nvar g;\r\nvar svg;\r\n\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nclass IndexUI extends Component{\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            updateview: false,\r\n            is_input:false,\r\n            GroupData:[{key:'0',name:'Group 0',tags:[]}],\r\n            pointData:[],\r\n            edges:[],\r\n            hasLoadData:false,\r\n            dataFile:[],\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        }\r\n        this.shape = \"circle\";\r\n        this.cur_idx = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.offsetY = 0;\r\n        this.offsetX = 0;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.selValue = ''\r\n        this.maxX=0\r\n        this.maxY=0\r\n        this.minX=0\r\n        this.minY=0\r\n        this.pointData = [];\r\n        this.edges=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.itemBBox=[]\r\n        this.hasCreateMST=false\r\n\r\n\r\n        this.menu = (\r\n            <Menu>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.savePNG.bind(this)}>\r\n                        PNG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveSVG.bind(this)}>\r\n                        SVG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveData.bind(this)}>\r\n                        JSON\r\n                    </a>\r\n                </Menu.Item>\r\n            </Menu>\r\n        );\r\n\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        var box=document.getElementById('mainsvg');\r\n        this.width = box.getBoundingClientRect().width;\r\n        this.height = box.getBoundingClientRect().height;\r\n        //console.log([this.width,this.height])\r\n\r\n        svg = d3.select('svg');\r\n\r\n        g = d3.select('svg').append(\"g\")\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        //svg.on('mousedown',this.handleMousedown.bind(this));\r\n        svg.call(d3.zoom()\r\n            .extent([[0, 0], [this.width, this.height]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        fetch('/data/datalist.json',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    dataFile:data\r\n                })\r\n            })\r\n\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        this.offsetX = minx - 20;\r\n        this.offsetY = miny - 20;\r\n        this.scaleX = (maxx-minx+40)/this.width;\r\n        this.scaleY = (maxy-miny+40)/this.height;\r\n\r\n        svg = d3.select('svg');\r\n        svg.call(d3.zoom()\r\n            .extent([[this.offsetX, this.offsetY], [this.scaleX, this.scaleY]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //console.log([this.offsetX,this.offsetY,this.scaleX,this.scaleY])\r\n\r\n    }\r\n\r\n    handleMousedown(event){\r\n        //left click\r\n        if(event.button === 0 && is_input){\r\n\r\n            //console.log(\"IndexUI Click!\")\r\n            //console.log(g)\r\n\r\n            //let x = event.offsetX;\r\n            //let y = event.offsetY;\r\n            //console.log([x,y])\r\n            let cx = d3.pointer(event)[0]\r\n            let cy = d3.pointer(event)[1]\r\n            let attributes = g._groups[0][0].attributes\r\n            if(attributes.transform != undefined){\r\n                let val = attributes.transform.value\r\n                let offsetX = \"\";\r\n                let offsetY = \"\";\r\n                let Scale = \"\";\r\n                for(let j = 9; j < val.length; j ++){\r\n                    if(val[j]=='('){\r\n                        j++;\r\n                        if(offsetX==\"\"){\r\n                            while(val[j]!=','){\r\n                                offsetX+=val[j++];\r\n                            }\r\n                            j++;\r\n                            while(val[j]!=')'){\r\n                                offsetY+=val[j++];\r\n                            }\r\n                        }\r\n                        else{\r\n                            while(val[j]!=')'){\r\n                                Scale+=val[j++];\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                offsetX = parseFloat(offsetX)\r\n                offsetY = parseFloat(offsetY)\r\n                Scale = parseFloat(Scale)\r\n                //console.log(\"(\" + offsetX + \", \" + offsetY + \", \" + Scale +\")\")\r\n                cx = (cx - offsetX) / Scale\r\n                cy = (cy - offsetY) / Scale\r\n            }\r\n\r\n\r\n            if(this.shape === 'circle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('circle')\r\n                    .attr('r', 10)\r\n                    .attr('cx', cx)\r\n                    .attr('cy', cy)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('rect')\r\n                    .attr('x', cx - 5)\r\n                    .attr('y', cy - 5)\r\n                    .attr('width', 10)\r\n                    .attr('height', 10)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            let tmp = {};\r\n            tmp.radius = 10;\r\n            tmp.width = 10;\r\n            tmp.height = 10;\r\n            tmp.x = cx;\r\n            tmp.y = cy;\r\n            tmp.cat = cur_set;\r\n            tmp.id = this.cur_idx++;\r\n            tmp.shape = this.shape\r\n\r\n            if(this.hasCreateMST == true){\r\n                this.child.addNewPoints(tmp)\r\n            }\r\n            else{\r\n                this.pointData.push(tmp);\r\n            }\r\n\r\n            this.setState({pointData:this.pointData})\r\n            console.log(this.pointData)\r\n        }\r\n    }\r\n\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        return edge\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                // that.setState({\r\n                //     hasEdit:true\r\n                // })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n                // that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n                // that.optimizeMST(true)\r\n\r\n                // for (var k in that.catPointDict){\r\n                //     that.findCircle(k)\r\n                // }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=g\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                    g\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this).attr(\"opacity\",0)\r\n                    })\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    handleDeleteNode(e){\r\n        if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                this.pointData.splice(this.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n\r\n    }\r\n\r\n    drawInit(){\r\n\r\n        this.centralizeData();\r\n        let data = this.pointData;\r\n        console.log(data)\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            let svg=d3.select(\"svg\")\r\n            let nodeindex=parseInt(d3.select(this).attr(\"idx\"))\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n            if(that.shape==\"circle\"){\r\n                d3.select(this)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                d3.select(this)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            d3.select(this).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",function(){\r\n                d3.select(this).attr(\"stroke\",\"none\")\r\n            })\r\n\r\n        function handleMouseDown(event){\r\n\r\n        }\r\n\r\n        function handleDeleteNode(e){\r\n            if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                that.pointData.splice(that.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n            else if(e.button==2 && !is_input){\r\n                console.log(\"click\")\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                // that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                // that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            // that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        var GroupCat = {}\r\n        for(let i = 0;i < data.length;i ++){\r\n\r\n            let curcat = -1;\r\n            let tmpcat = data[i].cat.toString()\r\n            let cats = tmpcat.split(\",\")\r\n            if (cats.length > 1){\r\n                for (let c = 0;c < cats.length;c ++){\r\n                    GroupCat[parseInt(cats[c])] = 1\r\n                    //GroupDict['Group '+ cats[c].toString()] = 1\r\n                    curcat = Math.max(parseInt(cats[c]), curcat);\r\n                }\r\n            }\r\n            else{\r\n                GroupCat[parseInt(tmpcat)] = 1\r\n                //GroupDict['Group '+ tmpcat.toString()] = 1\r\n                curcat = Math.max(parseInt(tmpcat), curcat);\r\n            }\r\n\r\n            cur_set = Math.max(curcat,cur_set);\r\n\r\n            if(this.shape === 'circle'){\r\n                g.append('circle')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('r', data[i].radius)\r\n                    .attr('cx', data[i].x)\r\n                    .attr('cy', data[i].y)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx',i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                g.append('rect')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('x', data[i].x - 0.5 * data[i].width)\r\n                    .attr('y', data[i].y - 0.5 * data[i].height)\r\n                    .attr('width', data[i].width)\r\n                    .attr('height', data[i].height)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx', i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n\r\n        }\r\n\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n/*        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }*/\r\n\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        keynum = 0\r\n\r\n        GroupDict = {}\r\n        for(var c in GroupCat){\r\n            GroupDict['Group '+ c.toString()] = 1\r\n        }\r\n\r\n        for(var k in GroupDict){\r\n            console.log(k)\r\n            if(keynum == 0){\r\n                tmpGroupData[0].tags = [colorArray[parseInt(keynum)]]\r\n            }\r\n            else{\r\n                tmpGroupData.push({\r\n                    key:keynum.toString(),\r\n                    name:k,\r\n                    tags:[colorArray[parseInt(keynum)]]\r\n                })\r\n            }\r\n            keynum++;\r\n        }\r\n\r\n        this.setState({GroupData:tmpGroupData})\r\n\r\n        console.log(\"GroupData!!!\")\r\n        console.log(GroupDict)\r\n        console.log(this.state.GroupData)\r\n\r\n        this.cur_idx = data.length\r\n        cur_set = keynum;\r\n\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 40)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 814)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n\r\n    }\r\n\r\n    addNewSet(){\r\n        keynum = 0\r\n        for(var k in GroupDict){\r\n            keynum ++;\r\n        }\r\n        //cur_set = keynum;\r\n        GroupDict['Group '+ keynum.toString()] = 1\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        tmpGroupData.push({\r\n            key:keynum.toString(),\r\n            name:'Group '+ keynum.toString(),\r\n            tags:[colorArray[parseInt(keynum.toString())]]\r\n        })\r\n        keynum ++;\r\n        this.setState({GroupData:tmpGroupData})\r\n        alert(\"Succellfully add new set \" + (keynum-1)  + \" !\");\r\n    }\r\n\r\n    scaleData(){\r\n\r\n        let minX = Number.MAX_VALUE\r\n        let minY = Number.MAX_VALUE\r\n        let maxX = Number.MIN_VALUE\r\n        let maxY = Number.MIN_VALUE\r\n        let scale_ratio_x = 1\r\n        let scale_ratio_y = 1\r\n        let transform_dx = 0\r\n        let transform_dy = 0\r\n\r\n        if(this.pointData.length <= 0){\r\n            return\r\n        }\r\n\r\n        if(this.pointData[0].shape == \"rectangle\"){\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].width / 2\r\n                let x2 = this.pointData[i].x + this.pointData[i].width / 2\r\n                let y1 = this.pointData[i].y - this.pointData[i].height / 2\r\n                let y2 = this.pointData[i].y + this.pointData[i].height / 2\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n        else{\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].radius\r\n                let x2 = this.pointData[i].x + this.pointData[i].radius\r\n                let y1 = this.pointData[i].y - this.pointData[i].radius\r\n                let y2 = this.pointData[i].y + this.pointData[i].radius\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n\r\n\r\n        let cur_width = maxX - minX\r\n        let cur_height = maxY - minY\r\n\r\n        // let svgwidth1 = 1200\r\n        // let svgheight1 = 1200\r\n\r\n        let svgwidth1 = 1500\r\n        let svgheight1 = 1500\r\n\r\n        //let svgwidth2 = 2000\r\n        //let svgheight2 = 2000\r\n\r\n        //if(cur_width > svgwidth1){\r\n            scale_ratio_x = svgwidth1 / cur_width\r\n        //}\r\n\r\n        //if(cur_height > svgheight1){\r\n            scale_ratio_y = svgheight1 / cur_height\r\n        //}\r\n\r\n        let ratio = Math.min(scale_ratio_x, scale_ratio_y)\r\n\r\n        transform_dx = 0 - minX\r\n        transform_dy = 0 - minY\r\n\r\n        //let ddx = (svgwidth2 / 2)  - ( (minX + transform_dx) * ratio + (maxX + transform_dx) * ratio ) / 2\r\n        //let ddy = (svgheight2 / 2) - ( (minY + transform_dy) * ratio + (maxY + transform_dy) * ratio ) / 2\r\n\r\n        for(let i = 0; i < this.pointData.length; i ++){\r\n\r\n            this.pointData[i].x = (this.pointData[i].x + transform_dx) * ratio\r\n            this.pointData[i].y = (this.pointData[i].y + transform_dy) * ratio\r\n            this.pointData[i].radius *= ratio\r\n            this.pointData[i].width *= ratio\r\n            this.pointData[i].height *= ratio\r\n            //this.pointData[i].shape = \"rectangle\"\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleUpload(){\r\n\r\n        let filename = this.selValue\r\n\r\n        if(filename == \"Manhattan.txt\"){\r\n            colorArray = ['#f16b22','#7e519f','#713e3a']\r\n        }\r\n        else if(filename == \"simpleScatterplot.json\"){\r\n            colorArray = ['#d35d6d','#0885c2','#4aa15f']\r\n        }\r\n\r\n        this.setState({\r\n            colorArray:colorArray\r\n        })\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    hasLoadData:true\r\n                })\r\n                this.pointData = data;\r\n                //for(let i = 0; i < this.pointData.length; i ++){\r\n                //    this.pointData[i].shape = \"rectangle\"\r\n                //}\r\n                //this.scaleData()\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    // this.pointData[i].width=this.pointData[i].width*1.5\r\n                    // this.pointData[i].height=this.pointData[i].height*1.5\r\n                    this.pointData[i].radius=10\r\n\r\n                }\r\n                //this.setState({\r\n                //    upload: true\r\n                //})\r\n\r\n                this.setState({pointData:this.pointData})\r\n                this.shape = data[0].shape;\r\n\r\n\r\n                this.drawInit();\r\n                this.setState({\r\n                    edges:this.edges\r\n                })\r\n            })\r\n\r\n    }\r\n\r\n    changeSel(e){\r\n        this.selValue = e;\r\n    }\r\n\r\n    handleInput(){\r\n        is_input = !is_input;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    hasCreate(){\r\n        this.hasCreateMST = true;\r\n    }\r\n    saveData(){\r\n        this.child.saveData()\r\n    }\r\n    savePNG(){\r\n        svgsaver.saveSvgAsPng(document.getElementById(\"mainsvg\"), \"result.png\");\r\n    }\r\n    saveSVG(){\r\n        let svg=d3.select(\"#mainsvg\")\r\n        let width=svg.attr(\"width\")\r\n        let height=svg.attr(\"height\")\r\n        let viewbox=svg.attr(\"viewBox\")\r\n        let svgstr=svg.html()\r\n        let xmlns=\"http://www.w3.org/2000/svg\"\r\n        svgstr=\"<svg xmlns=\\\"\"+xmlns+\"\\\" width=\\\"\"+width+\"\\\" height=\\\"\"+height+\"\\\" viewBox=\\\"\"+viewbox+\"\\\" >\\n\"+svgstr+\"\\n</svg>\"\r\n        let content = svgstr;\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"result.svg\");\r\n        // console.log(svgstr)\r\n    }\r\n\r\n    handleManually(flag){\r\n        is_input = flag;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    render(){\r\n        let options=this.state.dataFile.map((d)=>{return <option value={d}>{d}</option> })\r\n        console.log(\"Ratio\")\r\n        console.log(ScreenHeight/BeforeHeight)\r\n        console.log(ScreenWidth/BeforeWidth)\r\n        let p1 = 20 * ScreenHeight / BeforeHeight\r\n        let p2 = 50 * ScreenWidth / BeforeWidth\r\n        let p3 = 20 * ScreenHeight / BeforeHeight\r\n        let p4 = 20 * ScreenWidth / BeforeWidth\r\n        let p5 = 25 * ScreenHeight / BeforeHeight\r\n        let pad1 = p1.toString() + \"px \" + p2.toString() + \"px \" + p3.toString() + \"px \" + p4.toString() + \"px\"\r\n        let pad2 = p5.toString() + \"px \" + p4.toString() + \"px\"\r\n        return (\r\n            <>\r\n                <Layout>\r\n                    <Header style={{background: 'rgb(255, 255, 255, 0.1)',textAlign: 'center', fontFamily:\"Segoe UI\",fontWeight:\"bold\",fontSize: '25px', color:\"black\"}}>AceBubble</Header>\r\n                    <Layout>\r\n                        <Content theme={'light'} style={{ padding: pad1, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\" style={{float: \"right\"}}>\r\n                                <svg id=\"mainsvg\" width={1200 * ScreenWidth / BeforeWidth} height={750 * ScreenHeight / BeforeHeight} style={{border:\"1px solid #000000\"}}></svg>\r\n                            </div>\r\n                            <div className=\"left\" style={{float: \"left\"}}>\r\n                                <svg id=\"leftsvg\" width={0} height={0}></svg>\r\n                            </div>\r\n                        </Content>\r\n                        <Sider theme={'light'} width={600 * ScreenWidth / BeforeWidth} className=\"site-layout-background\" style={{ padding: pad2, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\">\r\n                                <Select showSearch style={{ width: 320 * ScreenWidth / BeforeWidth }} placeholder=\"Select an example data..\" onChange={this.changeSel.bind(this)}>\r\n                                    {options}\r\n{/*                                    <Option value='BubbleSetExample1.txt'>example1</Option>\r\n                                    <Option value='BubbleSetExample2.txt'>example2</Option>\r\n                                    <Option value='BubbleSetExample3.txt'>Manually Made Data</Option>\r\n                                    <Option value='test.txt'>test</Option>\r\n                                    <Option value='test(1).txt'>test(1).txt</Option>\r\n                                        <Option value='co2_gdppercapita.txt'>co2_gdppercapita.txt</Option>\r\n                                    <Option value='life_children.txt'>life_children.txt</Option>\r\n                                    <Option value='co2_income.txt'>co2_income.txt</Option>\r\n                                    <Option value='life_income.txt'>life_income.txt</Option>*/}\r\n\r\n\r\n\r\n\r\n\r\n                                </Select>\r\n                                <Button onClick={this.handleUpload.bind(this)}>Load Example Data</Button>\r\n                                <br/>\r\n                                <br/>\r\n                                <p>\r\n                                    <Dropdown overlay={this.menu} arrow>\r\n                                        <Button>Save As <DownOutlined /></Button>\r\n                                    </Dropdown>\r\n                                </p>\r\n\r\n                                <div style={{width:\"80%\"}}>\r\n                                    <Table pagination={{disabled:true, position: ['none', 'none'] }}\r\n                                           scroll={{ y: 200 * ScreenHeight / BeforeHeight }}\r\n                                           columns={columns}\r\n                                           dataSource={this.state.GroupData}\r\n                                    />\r\n                                </div>\r\n                                <br/>\r\n                                <HierarchicalCluster pointData={this.state.pointData} hasLoadData={this.state.hasLoadData} isedit={this.state.is_input} edges={this.state.edges} hasCreate={this.hasCreate.bind(this)} handleManually={this.handleManually.bind(this)} onRef={this.onRef} colorArray = {this.state.colorArray}/>\r\n                            </div>\r\n                        </Sider>\r\n                    </Layout>\r\n                    <Footer style={{background: 'rgb(255, 255, 255, 0.1)', textAlign: 'center' ,fontSize: '16px'}}>AceBubble ©2021</Footer>\r\n                </Layout>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default IndexUI;","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport MainSvg from \"./MainSvg\"\r\nimport DataHacker from \"./dataHacker\"\r\nimport CSVData from \"./CSVData\"\r\nimport GapMinderNew from \"./GapMinderNew\";\r\nimport ManuallyTree from \"./ManuallyTree\";\r\nimport Example1 from\"./Example1\"\r\nimport LocalCluster from\"./LocalCluster\"\r\nimport HierarchicalCluster from \"./HierarchicalCluster\";\r\nimport BMOAlgo from \"./BMOAlgo\";\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport IndexUI from \"./IndexUI\";\r\n\r\nclass BubbleDemo extends  Component{\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    render(){\r\n        // return(<MainSvg></MainSvg>)\r\n        // return(<DataHacker></DataHacker>)\r\n        // return(<CSVData></CSVData>)\r\n        // return(<GapMinderNew ></GapMinderNew>)\r\n        // return(<ManuallyTree ></ManuallyTree>)\r\n        // return(<LocalCluster ></LocalCluster>)\r\n         //return(<HierarchicalCluster ></HierarchicalCluster>)\r\n        //return(<AdaptiveIsovalue ></AdaptiveIsovalue>)\r\n\r\n        return(<IndexUI></IndexUI>)\r\n\r\n        // return(<Example1 ></Example1>)\r\n\r\n    }\r\n}\r\n\r\nexport default BubbleDemo","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport './index.css';\r\nimport {\r\n    drawPolygon,\r\n    drawCircle,\r\n    drawLine,\r\n    calDistance,\r\n    calCommonTanPoint,\r\n    getDegreeTwoVec,\r\n    crossMul,\r\n    calTanPoint, drawArc, rotatePoint\r\n} from \"./util\";\r\nimport * as turf from '@turf/turf'\r\n\r\n\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\nvar d3Voronoi = require(\"d3-voronoi\")\r\nvar jsgraphs = require('js-graph-algorithms');\r\n// var colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\nvar colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar re=20\r\nvar bt=5\r\nvar tanPointsNum=0\r\n\r\nvar cd=1\r\nvar calpha=1\r\nvar ci=100\r\n\r\nvar deltaDeg=10/180*Math.PI\r\n\r\n\r\nclass KelpDiagram extends Component{\r\n    constructor(){\r\n        super()\r\n        this.pointData = [];\r\n        this.itemShape=\"circle\"\r\n        this.maxX=Number.MIN_VALUE\r\n        this.minX=Number.MAX_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.itemBBox=[]\r\n        this.catPointDict={}\r\n        this.voronoiPolygons=[]\r\n        this.elementSpace=[]\r\n        this.elementPoly=[]\r\n        this.pathString=[]\r\n        this.VI=[]\r\n        this.tanGraphEdges=[]\r\n        this.tanGraphPoints=[]\r\n        this.edges=[]\r\n        this.newVI=[]\r\n        // this.graph=null\r\n    }\r\n\r\n    componentDidMount() {\r\n        // let filename=\"newExample1.txt\"\r\n        let filename=\"BubbleSetExample1.txt\"\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.pointData = data;\r\n                this.itemShape = data[0].shape;\r\n                this.centralizeData()\r\n                this.drawPointData()\r\n                console.time(\"total time\")\r\n                this.calVoronoiDiagram()\r\n                this.calElementSpace()\r\n                this.approxArcWithPolygon()\r\n                this.drawSpacePathWithPolygon()\r\n                this.calTanGraphWithPolygon()\r\n                console.log(this.tanGraphPoints)\r\n                console.log(this.tanGraphEdges)\r\n                // this.calSpacePath()\r\n                // this.calTangentGraph()\r\n                // this.splitCircularEdge()\r\n                this.calShortestPath()\r\n                console.timeEnd(\"total time\")\r\n\r\n\r\n                // this.drawSplitEdge()\r\n                // this.drawTanPoint()\r\n                // this.drawTangentEdges()\r\n                // this.createGraph()\r\n\r\n            })\r\n    }\r\n\r\n    addCircularEdge(tanPoints){\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for (let i=0;i<tanPoints.length;i++){\r\n            let points=tanPoints[i]\r\n            for(let e=0;e<this.elementSpace[i].length;e++){\r\n                let eseg=this.elementSpace[i][e]\r\n                if(eseg.type==\"arc\"){\r\n                    let onpoints=[]\r\n                    let dearray=[]\r\n                    for(let p=0;p<points.length;p++){\r\n                        if(this.isPointOnArc([points[p].x,points[p].y],eseg)){\r\n                            onpoints.push(points[p])\r\n                        }\r\n                    }\r\n                    //sort the points according to degree\r\n\r\n                    let startpoint=this.tanGraphPoints[eseg.startid]\r\n                    let endpoint=this.tanGraphPoints[eseg.endid]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n\r\n                    for (let p=0;p<onpoints.length;p++){\r\n                        let pointvec=[onpoints[p].x-eseg.center[0],onpoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n\r\n                    dearray.push({\r\n                        index:p,\r\n                        degree:degree\r\n                    })\r\n                    }\r\n                    dearray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<dearray.length;d++){\r\n                        nextd=onpoints[dearray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n/*                    if(this.tanGraphEdges.length>=60036){\r\n                        console.log()\r\n                    }*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n    findApproxPointOnArc(point,arc){\r\n        let polypoints=arc.polysegment\r\n        let startpoint=arc.start\r\n        let center=arc.center\r\n        let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let degree=getDegreeTwoVec(startvec,pointvec)\r\n        let crossmul1=crossMul(startvec,pointvec)\r\n        if(crossmul1>0){\r\n            degree=2*Math.PI-degree\r\n        }\r\n        if(degree<0.000001){\r\n            return 0\r\n        }\r\n        let index=parseInt(degree/deltaDeg)\r\n\r\n/*        if(index>polypoints.length-1){\r\n            d3.select(\"svg\").selectAll(\"circle\").remove()\r\n            drawCircle(point[0],point[1],5,\"red\",\"none\")\r\n            drawCircle(polypoints[polypoints.length-1][0],polypoints[polypoints.length-1][1],5,\"blue\",\"none\")\r\n            drawCircle(polypoints[0][0],polypoints[0][1],5,\"black\",\"none\")\r\n\r\n        }*/\r\n\r\n        return index\r\n    }\r\n\r\n    isExist(p,points){\r\n        for(let i=0;i<points.length;i++){\r\n            if(p[0]==points[i].x&&p[1]==points[i].y){\r\n                return points[i].id\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n\r\n    calTanGraphWithPolygon(){\r\n        let tempTanEdges=[]\r\n        let tempTanPoints=[]\r\n        let pointsOnSameArc=[]\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            pointsOnSameArc.push([])\r\n        }\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            tempTanPoints.push(this.newVI[i])\r\n        }\r\n        console.log(this.catPointDict)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    let arc1\r\n                    let arc2\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    arc1=eleSpace1[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                        arc1=eleSpace1[0]\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    arc2=eleSpace2[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        arc2=eleSpace2[0]\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        let polyindex1=this.findApproxPointOnArc(linestart,arc1)\r\n                        let tanpoint1=arc1.polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        // drawCircle(tanpoint1[0],tanpoint1[1],2,\"green\",\"none\")\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex2=this.findApproxPointOnArc(lineend,arc2)\r\n\r\n                        let tanpoint2=arc2.polysegment[polyindex2]\r\n                        // drawCircle(tanpoint2[0],tanpoint2[1],2,\"green\",\"none\")\r\n\r\n                        let existindex2=this.isExist(tanpoint2,tempTanPoints)\r\n                        if(existindex2==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint2[0],\r\n                                y:tanpoint2[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex2=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:existindex1,\r\n                            endid:existindex2,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],[this.tanGraphPoints[existindex2].x,this.tanGraphPoints[existindex2].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                if(this.pointData[i].cat==this.pointData[j].cat){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n                }\r\n\r\n                if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                    //p to q\r\n                    let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    if(eleSpace2.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace2[0])\r\n                        let tanpoint0=eleSpace2[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace2[0])\r\n                        let tanpoint1=eleSpace2[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:existindex0,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:existindex1,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints.length;p++){\r\n                            for (let e=0;e<eleSpace2.length;e++){\r\n                                if(eleSpace2[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])\r\n                                        let tanpoint=eleSpace2[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:index2,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index1,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    //q to p\r\n                    let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                    tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                    if(eleSpace1.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints2[0].x,tanPoints2[0].y],eleSpace1[0])\r\n                        let tanpoint0=eleSpace1[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints2[1].x,tanPoints2[1].y],eleSpace1[0])\r\n                        let tanpoint1=eleSpace1[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                        }\r\n\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:existindex0,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:existindex1,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints2.length;p++){\r\n                            for (let e=0;e<eleSpace1.length;e++){\r\n                                if(eleSpace1[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])\r\n                                        let tanpoint=eleSpace1[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:index1,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index2,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.newVI[i].dataindex[0]\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].cat\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n                this.tanGraphEdges.push({\r\n                    type:\"line\",\r\n                    startid:this.newVI[i].id,\r\n                    endid:this.pointData[p].id,\r\n                    // startpoint:[points[j].x,points[j].y],\r\n                    // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                })\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace[0])\r\n                        let tanpoint0=eleSpace[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace[0])\r\n                        let tanpoint1=eleSpace[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex0,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex1,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[t].x,tanPoints[t].y],eleSpace[e])\r\n                                        let tanpoint=eleSpace[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:p,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:this.newVI[i].id,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        this.addCircularEdge(pointsOnSameArc)\r\n    }\r\n\r\n\r\n\r\n    above(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) > 0\r\n    }\r\n\r\n    below(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) < 0\r\n    }\r\n\r\n    isLeft(  P0,  P1,  P2 )\r\n{\r\n    return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);\r\n}\r\n\r\n    RLtangent_PolyPolyC(V,   W) {\r\n        let  ix1, ix2;      // search indices for polygons 1 and 2\r\n\r\n        // first get the initial vertex on each polygon\r\n        // ix1 = this.Rtangent_PointPolyC(W[0], V);   // right tangent from W[0] to V\r\n        ix1=this.tangent_PointPoly(W[0],V)[1]\r\n        // ix2 = this.Ltangent_PointPolyC(V[ix1], W); // left tangent from V[ix1] to W\r\n\r\n        ix2=this.tangent_PointPoly(V[ix1],W)[0]\r\n\r\n        // ping-pong linear search until it stabilizes\r\n        let done = false                    // flag when done\r\n        while (done == false) {\r\n            done = true;                     // assume done until...\r\n            while (this.isLeft(W[(ix2+W.length)%W.length], V[ix1], V[ix1+1]) <= 0){\r\n                ++ix1;                       // get Rtangent from W[ix2] to V\r\n            }\r\n\r\n            while (this.isLeft(V[ix1], W[(ix2+W.length)%W.length], W[(ix2-1+W.length)%W.length]) >= 0){\r\n                --ix2;                       // get Ltangent from V[ix1] to W\r\n                done = false;                // not done if had to adjust this\r\n            }\r\n        }\r\n        let t1 = ix1;\r\n        let t2 = ix2;\r\n        if(t1<0){\r\n            t1=t1+V.length\r\n        }\r\n        if(t2<0){\r\n            t2=t2+W.length\r\n        }\r\n\r\n        return[t1,t2]\r\n    }\r\n\r\n\r\n\r\n    drawSpacePathWithPolygon(){\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let espace=this.elementPoly[i]\r\n            let nowp=espace[0]\r\n            let nextp\r\n            for (let e=1;e<espace.length;e++){\r\n                nextp=espace[e]\r\n                drawLine([nowp.x,nowp.y],[nextp.x,nextp.y],\"red\",2)\r\n                nowp=nextp\r\n            }\r\n        }\r\n    }\r\n\r\n    approxArcWithPolygon(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            for (let e=0;e<espace.length;e++){\r\n\r\n                let center=espace[e].center\r\n                let radius=espace[e].radius\r\n                if(espace[e].type==\"arc\"){\r\n                    let startpoint=espace[e].start\r\n                    let endpoint=espace[e].end\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    let endvec=[endpoint[0]-center[0],endpoint[1]-center[1]]\r\n                    // let vecstart=[espace[e].]\r\n                    let degree=getDegreeTwoVec(startvec,endvec)\r\n\r\n                    let crossmul1=crossMul(startvec,endvec)\r\n                    if(crossmul1>0){\r\n                        degree=2*Math.PI-degree\r\n                    }\r\n\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n\r\n                    polySegs.push(startpoint)\r\n                    while(d<degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n                else if(espace[e].type==\"circle\"){\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    let endpoint=startpoint\r\n                    espace[e].start=startpoint\r\n                    espace[e].end=endpoint\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n                    let degree=Math.PI*2\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n                    polySegs.push(startpoint)\r\n                    while(d<=degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            let newespace=[]\r\n            for (let e=0;e<espace.length;e++){\r\n                if(espace[e].type==\"line\"){\r\n                    newespace.push(espace[e])\r\n                }\r\n                else{\r\n                    //arc segments\r\n                    let nowp=espace[e].polysegment[0]\r\n                    for (let s=1;s<espace[e].polysegment.length;s++){\r\n                        let nextp=espace[e].polysegment[s]\r\n                        newespace.push({\r\n                            type:\"line\",\r\n                            center:espace[e].center,\r\n                            radius:re,\r\n                            start:nowp,\r\n                            end:nextp\r\n                        })\r\n                        nowp=nextp\r\n                    }\r\n                }\r\n            }\r\n            this.elementPoly.push(newespace)\r\n        }\r\n\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let eseg=this.elementPoly[i]\r\n            let newsegs=[]\r\n            newsegs.push({\r\n                x:eseg[0].start[0],\r\n                y:eseg[0].start[1],\r\n                degree:0\r\n            })\r\n            for (let e=0;e<eseg.length;e++){\r\n                let point=eseg[e].end\r\n                newsegs.push({\r\n                    x:point[0],\r\n                    y:point[1],\r\n                    degree:0\r\n                })\r\n            }\r\n            this.elementPoly[i]=newsegs\r\n        }\r\n\r\n        console.log(this.elementPoly)\r\n\r\n    }\r\n\r\n    calVoronoiDiagram(){\r\n        let that=this\r\n        let diagram=d3Voronoi.voronoi()\r\n            .extent([[that.minX-50,that.minY-50],[that.maxX+50,that.maxY+50]])\r\n            .x(function(d){\r\n                return d.x\r\n            })\r\n            .y(function(d){\r\n                return d.y\r\n            })\r\n        let polygons=diagram.polygons(this.pointData)\r\n        this.voronoiPolygons=polygons\r\n        //Polygons are also counterclockwise\r\n/*        for (let i=0;i<polygons.length;i++){\r\n            drawPolygon(polygons[i],0,0,\"red\")\r\n        }*/\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            drawCircle(this.pointData[i].x,this.pointData[i].y,re,\"none\",\"black\")\r\n        }*/\r\n\r\n        console.log(polygons)\r\n\r\n    }\r\n\r\n    calElementSpace(){\r\n        for (let i=0;i<this.voronoiPolygons.length;i++){\r\n         let polypoints=this.voronoiPolygons[i]\r\n            let pointnum=polypoints.length\r\n            let data=polypoints.data\r\n            let id=polypoints.data.id\r\n            let eleSpace=[]\r\n            let insideLines=[]\r\n            let circle=ShapeInfo.circle({cx: data.x, cy: data.y, r: re})\r\n            let vi=[]\r\n         for (let p=0;p<polypoints.length;p++){\r\n             let thisp=polypoints[p]\r\n             let nextp=polypoints[(p+1)%pointnum]\r\n             // drawLine(thisp,nextp,\"blue\")\r\n             //check intersection between line and circle\r\n             let inside=IntersectionQuery.pointInCircle( {x:thisp[0],y:thisp[1]}, {x:data.x,y:data.y} ,  re)\r\n             if(inside){\r\n                 let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                 if(inside2){\r\n                     insideLines.push([thisp,nextp])\r\n                 }\r\n         else{\r\n             let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                    let point=intersections.points[0]\r\n                     vi.push([point.x,point.y])\r\n                     insideLines.push([thisp,[point.x,point.y]])\r\n                 }\r\n             }\r\n        else{\r\n                 let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                 if(inside2){\r\n                     let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                     let point=intersections.points[0]\r\n                     vi.push([point.x,point.y])\r\n                     insideLines.push([[point.x,point.y],nextp])\r\n                 }\r\n        else{\r\n                     let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                     if(intersections.status==\"Intersection\"){\r\n                         let points=intersections.points\r\n                         let dis1=calDistance(thisp[0],thisp[1],points[0].x,points[0].y)\r\n                         let dis2=calDistance(thisp[0],thisp[1],points[1].x,points[1].y)\r\n                         if(dis1<dis2){\r\n                             insideLines.push([[points[0].x,points[0].y],[points[1].x,points[1].y]])\r\n                             vi.push([points[0].x,points[0].y])\r\n                             vi.push([points[1].x,points[1].y])\r\n                         }\r\n                     else{\r\n                             insideLines.push([[points[1].x,points[1].y],[points[0].x,points[0].y]])\r\n                             vi.push([points[1].x,points[1].y])\r\n                             vi.push([points[0].x,points[0].y])\r\n                         }\r\n                     }\r\n                     else{\r\n                         //no intersection with the circle\r\n                     }\r\n\r\n                 }\r\n             }\r\n         }\r\n\r\n         this.VI.push(vi)\r\n        if(insideLines.length>0){\r\n            for (let l=0;l<insideLines.length;l++){\r\n                // drawLine(insideLines[l][0],insideLines[l][1],\"blue\")\r\n                eleSpace.push({\r\n                    type:\"line\",\r\n                    start:insideLines[l][0],\r\n                    end:insideLines[l][1],\r\n                    center:[data.x,data.y],\r\n                    radius:re\r\n                })\r\n                let point1=insideLines[l][1]\r\n                let point2=insideLines[(l+1)%insideLines.length][0]\r\n                if(point1[0]==point2[0]&&point1[1]==point2[1]){\r\n\r\n                }\r\n                else{\r\n                    //insert an arc\r\n                    eleSpace.push({\r\n                        type:\"arc\",\r\n                        start:point1,\r\n                        end:point2,\r\n                        center:[data.x,data.y],\r\n                        radius:re\r\n                    })\r\n                }\r\n\r\n            }\r\n        }\r\n        else{\r\n            eleSpace.push({\r\n                type:\"circle\",\r\n                start:[],\r\n                end:[],\r\n                center:[data.x,data.y],\r\n                radius:re\r\n            })\r\n        }\r\n        this.elementSpace.push(eleSpace)\r\n        }\r\n        console.log(this.elementSpace)\r\n    }\r\n\r\n    calSpacePath(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let pathstr=\"\"\r\n            let segs=this.elementSpace[i]\r\n            if(i==5){\r\n                console.log()\r\n            }\r\n            for (let s=0;s<segs.length;s++){\r\n                let type=segs[s].type\r\n                let center=segs[s].center\r\n                let startp=segs[s].start\r\n                let endp=segs[s].end\r\n                let radius=re\r\n\r\n                if(type==\"circle\"){\r\n                    // drawCircle(segs[s].center[0],segs[s].center[1],segs[s].radius,\"none\",\"black\")\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    pathstr+=\"M \"+startpoint[0]+\",\"+startpoint[1]+\" a \"+radius+\",\"+radius+\" 0 1,0 \"+2*radius+\",0\"\r\n                    pathstr+=\" a \"+radius+\",\"+radius+\" 0 1,0 \"+-1*2*radius+\",0\"\r\n                }\r\n                else if(type==\"arc\"){\r\n                    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                    let largearcflag=0\r\n                    let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                    let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n/*                    if(i==5){\r\n                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                        drawLine(vec1[0],vec1[1],\"red\")\r\n                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                    }*/\r\n\r\n                    let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                    if(crossmul>0){\r\n                        largearcflag=1\r\n                    }\r\n                    else if(crossmul<=0){\r\n                        largearcflag=0\r\n                    }\r\n\r\n                    pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n\r\n\r\n                }\r\n                else if(type==\"line\"){\r\n                    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                    pathstr+=\"L \"+endp[0]+\",\"+endp[1]\r\n                }\r\n            }\r\n            d3.select(\"svg\")\r\n                .append(\"path\")\r\n                .attr(\"id\",\"elespace\"+i)\r\n                .attr(\"d\",pathstr)\r\n                .attr(\"fill\",\"none\")\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"stroke-width\",\"2\")\r\n            this.pathString.push(pathstr)\r\n        }\r\n    }\r\n\r\n    initVI(){\r\n        // console.log(this.VI)\r\n        let newVI=[]\r\n        for (let i=0;i<this.VI.length;i++){\r\n            for (let j=0;j<this.VI[i].length;j++){\r\n                let vpoint=this.VI[i][j]\r\n                let has=false\r\n                for (let v=0;v<newVI.length;v++){\r\n                    if(vpoint[0]==newVI[v].x&&vpoint[1]==newVI[v].y){\r\n                        has=true\r\n                        break\r\n                    }\r\n                }\r\n                if(!has){\r\n                    let vipoint={\r\n                        type:\"vi\",\r\n                        x:vpoint[0],\r\n                        y:vpoint[1],\r\n                        dataindex:[i,j],\r\n                        id:tanPointsNum\r\n                    }\r\n                    tanPointsNum+=1\r\n                    newVI.push(vipoint)\r\n                    this.tanGraphPoints.push(vipoint)\r\n                }\r\n            }\r\n\r\n        }\r\n        this.newVI=newVI\r\n        for(let i=0;i<newVI.length;i++){\r\n            for (let e=0;e<this.elementSpace.length;e++){\r\n                let espace=this.elementSpace[e]\r\n                for (let s=0;s<espace.length;s++){\r\n                    let eseg=espace[s]\r\n                    if(eseg.type==\"arc\"){\r\n                        let start=eseg.start\r\n                        let end=eseg.end\r\n                        if(start[0]==newVI[i].x&&start[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].startid=newVI[i].id\r\n                        }\r\n                        if(end[0]==newVI[i].x&&end[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].endid=newVI[i].id\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(this.newVI)\r\n    }\r\n\r\n    isPointOnArc(point,arc){\r\n        let start=arc.start\r\n        let end=arc.end\r\n        let center=arc.center\r\n        let startvec=[start[0]-center[0],start[1]-center[1]]\r\n        let endvec=[end[0]-center[0],end[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let startEndDeg=getDegreeTwoVec(startvec,endvec)\r\n        let pointStartDeg=getDegreeTwoVec(startvec,pointvec)\r\n\r\n        let crossmul1=crossMul(startvec,endvec)\r\n\r\n        if(crossmul1>0){\r\n            startEndDeg=2*Math.PI-startEndDeg\r\n        }\r\n\r\n        let crossmul2=crossMul(startvec,pointvec)\r\n\r\n        if(crossmul2>0){\r\n            pointStartDeg=2*Math.PI-pointStartDeg\r\n        }\r\n\r\n        if(pointStartDeg<=startEndDeg){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    calTangentGraph(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        console.log(this.catPointDict)\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        /*                            if(index1==80){\r\n                                                        drawLine(linestart,lineend,\"red\",2)\r\n                                                    }*/\r\n                        let startpoint={\r\n                            type:\"tanpoint\",\r\n                            x:linestart[0],\r\n                            y:linestart[1],\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        this.tanGraphPoints.push(startpoint)\r\n                        tanPointsNum+=1\r\n                        let endpoint={\r\n                            type:\"tanpoint\",\r\n                            x:lineend[0],\r\n                            y:lineend[1],\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        this.tanGraphPoints.push(endpoint)\r\n                        tanPointsNum+=1\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:startpoint.id,\r\n                            endid:endpoint.id,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                if(this.pointData[i].cat==this.pointData[j].cat){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n                }\r\n\r\n                if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                    //p to q\r\n                    let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    if(eleSpace2.length==1){\r\n                        let point0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[0].x,\r\n                            y:tanPoints[0].y,\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(point0)\r\n                        let point1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[1].x,\r\n                            y:tanPoints[1].y,\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(point1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:point0.id,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:point1.id,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints.length;p++){\r\n                            for (let e=0;e<eleSpace2.length;e++){\r\n                                if(eleSpace2[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                        let tanpoint={\r\n                                            type:\"tanpoint\",\r\n                                            x:tanPoints[p].x,\r\n                                            y:tanPoints[p].y,\r\n                                            dataindex:index2,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index1,\r\n                                            endid:tanpoint.id,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //q to p\r\n                    let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                    tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                    if(eleSpace1.length==1){\r\n                        let tanpoint0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints2[0].x,\r\n                            y:tanPoints2[0].y,\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint0)\r\n                        let tanpoint1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints2[1].x,\r\n                            y:tanPoints2[1].y,\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:tanpoint0.id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[0].x,tanPoints2[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:tanpoint1.id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[1].x,tanPoints2[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints2.length;p++){\r\n                            for (let e=0;e<eleSpace1.length;e++){\r\n                                if(eleSpace1[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                        let tanpoint={\r\n                                            type:\"tanpoint\",\r\n                                            x:tanPoints2[p].x,\r\n                                            y:tanPoints2[p].y,\r\n                                            dataindex:index1,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index2,\r\n                                            endid:tanpoint.id,\r\n                                            // startpoint:[points[j].x,points[j].y],\r\n                                            // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.newVI[i].dataindex[0]\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].cat\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n                this.tanGraphEdges.push({\r\n                    type:\"line\",\r\n                    startid:this.newVI[i].id,\r\n                    endid:this.pointData[p].id,\r\n                    // startpoint:[points[j].x,points[j].y],\r\n                    // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                })\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let tanpoint0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[0].x,\r\n                            y:tanPoints[0].y,\r\n                            dataindex:p,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint0)\r\n                        let tanpoint1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[1].x,\r\n                            y:tanPoints[1].y,\r\n                            dataindex:p,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:tanpoint0.id,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:tanpoint1.id,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n                                        let tanpoint={\r\n                                            type: \"tanpoint\",\r\n                                            x: tanPoints[t].x,\r\n                                            y: tanPoints[t].y,\r\n                                            dataindex: p,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n\r\n                                        this.tanGraphEdges.push({\r\n                                            type: \"line\",\r\n                                            startid: this.newVI[i].id,\r\n                                            endid: tanpoint.id,\r\n                                            // startpoint: vp,\r\n                                            // endpoint: [tanPoints[p].x, tanPoints[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(this.tanGraphPoints)\r\n\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            let points=this.VI[i]\r\n            for (let p=0;p<points.length;p++){\r\n                this.tanGraphEdges.push({\r\n                    startid:i,\r\n                    endid:i,\r\n                    startpoint:points[p],\r\n                    endpoint:[this.pointData[i].x,this.pointData[i].y]\r\n                })\r\n            }\r\n        }*/\r\n\r\n\r\n\r\n    }\r\n\r\n    splitCircularEdge(){\r\n        let viMap=[]\r\n        let tanPointMap=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            viMap.push([])\r\n            tanPointMap.push([])\r\n        }\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let id=this.newVI[i].dataindex[0]\r\n            viMap[id].push(this.newVI[i])\r\n        }\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].type==\"tanpoint\"){\r\n                let index=this.tanGraphPoints[i].dataindex\r\n                tanPointMap[index].push(this.tanGraphPoints[i])\r\n            }\r\n        }\r\n\r\n/*        for (let i=0;i<tanPointMap.length;i++){\r\n            if(i==91){\r\n                for (let j=0;j<tanPointMap[i].length;j++){\r\n                    drawCircle(tanPointMap[i][j].x,tanPointMap[i][j].y,2,\"red\",\"none\")\r\n                }\r\n            }\r\n        }*/\r\n\r\n\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            let elespace=this.elementSpace[i]\r\n            let vis=viMap[i]\r\n            let tanpoints=tanPointMap[i]\r\n            for(let e=0;e<elespace.length;e++){\r\n                let eseg=elespace[e]\r\n                if(eseg.type==\"arc\"){\r\n                    //split this eseg\r\n                    let startindex=-1\r\n                    let endindex=-1\r\n                    let startpoint\r\n                    let endpoint\r\n                    let onPoints=[]\r\n                    for (let v=0;v<vis.length;v++){\r\n                        if(vis[v].x==eseg.start[0]&&vis[v].y==eseg.start[1]){\r\n                            startindex=vis[v].id\r\n                            startpoint=this.tanGraphPoints[startindex]\r\n                        }\r\n                        if(vis[v].x==eseg.end[0]&&vis[v].y==eseg.end[1]){\r\n                            endindex=vis[v].id\r\n                            endpoint=this.tanGraphPoints[endindex]\r\n                        }\r\n                    }\r\n                    for (let t=0;t<tanpoints.length;t++){\r\n                        if(this.isPointOnArc([tanpoints[t].x,tanpoints[t].y],eseg)){\r\n                            onPoints.push(tanpoints[t])\r\n                        }\r\n                    }\r\n                    // console.log(startindex,endindex,onPoints)\r\n/*                    if(i==91){\r\n                        drawCircle(startpoint.x,startpoint.y,5,\"red\",\"none\")\r\n                        drawCircle(endpoint.x,endpoint.y,5,\"green\",\"none\")\r\n                        for (let o=0;o<onPoints.length;o++){\r\n                            drawCircle(onPoints[o].x,onPoints[o].y,2,\"blue\",\"none\")\r\n                        }\r\n\r\n                    }*/\r\n\r\n                    let deArray=[]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n                    let endvec=[endpoint.x-eseg.center[0],endpoint.y-eseg.center[1]]\r\n                    for (let p=0;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                        index:p,\r\n                        degree:degree\r\n                    })\r\n\r\n                    }\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n                else if(eseg.type==\"circle\"){\r\n                    let onPoints=tanpoints\r\n                    let startvec=[onPoints[0].x-eseg.center[0],onPoints[0].y-eseg.center[1]]\r\n                    let deArray=[]\r\n                    for (let p=1;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=onPoints[0]\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6002){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:onPoints[0].id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n        console.log(this.tanGraphEdges)\r\n/*        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].dataindex==91){\r\n                drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"green\",\"none\")\r\n            }\r\n        }*/\r\n    }\r\n\r\n    drawSplitEdge(){\r\n        for(let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].type==\"arc\"){\r\n                let pathstr=\"\"\r\n                let startid=this.tanGraphEdges[i].startid\r\n                let endid=this.tanGraphEdges[i].endid\r\n                let startp=[this.tanGraphPoints[startid].x,this.tanGraphPoints[startid].y]\r\n                let endp=[this.tanGraphPoints[endid].x,this.tanGraphPoints[endid].y]\r\n                let center=this.tanGraphEdges[i].center\r\n                let radius=this.tanGraphEdges[i].radius\r\n\r\n                // drawCircle(startp[0],startp[1],2,\"red\",\"none\")\r\n                // drawCircle(endp[0],endp[1],2,\"red\",\"none\")\r\n\r\n                pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                let largearcflag=0\r\n                let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n                /*                    if(i==5){\r\n                                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                                        drawLine(vec1[0],vec1[1],\"red\")\r\n                                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                                    }*/\r\n\r\n                let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                if(crossmul>0){\r\n                    largearcflag=1\r\n                }\r\n                else if(crossmul<=0){\r\n                    largearcflag=0\r\n                }\r\n\r\n                pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n                d3.select(\"svg\")\r\n                    .append(\"path\")\r\n                    .attr(\"d\",pathstr)\r\n                    .attr(\"fill\",\"none\")\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"stroke-width\",\"1\")\r\n            }\r\n        }\r\n    }\r\n\r\n    calScoreForAll(){\r\n        //cal distance,alpha and crossing num\r\n        console.time(\"cal score\")\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            let startdataid=startpoint.dataindex\r\n            let enddataid=endpoint.dataindex\r\n            let center=this.tanGraphEdges[i].center\r\n            if(this.tanGraphEdges[i].type==\"line\"){\r\n                let cat\r\n                if(startpoint.type==\"vi\"){\r\n                    cat=this.pointData[startpoint.dataindex[0]].cat\r\n                }\r\n                else{\r\n                    cat=this.pointData[startpoint.dataindex].cat\r\n                }\r\n                // console.log(cat)\r\n                let dis=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                this.tanGraphEdges[i].distance=dis\r\n                this.tanGraphEdges[i].crossnum=0\r\n                this.tanGraphEdges[i].alpha=0\r\n                //cal intersection with elespacepath\r\n                let crossnum=0\r\n                for (let e=0;e<this.pathString.length;e++){\r\n                    let cat2=this.pointData[e].cat\r\n                    if(cat!=cat2&&e!=startdataid&&e!=enddataid){\r\n                        const path = ShapeInfo.path(this.pathString[e]);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(path, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n\r\n                }\r\n                this.tanGraphEdges[i].crossnum=crossnum\r\n            }\r\n\r\n            else{\r\n                //arc edges\r\n                let startvec=[startpoint.x-center[0],startpoint.y-center[1]]\r\n                let endvec=[endpoint.x-center[0],endpoint.y-center[1]]\r\n                let degree=getDegreeTwoVec(startvec,endvec)\r\n                let littledegree=degree\r\n                let crossmul1=crossMul(startvec,endvec)\r\n                if(crossmul1>0){\r\n                    degree=2*Math.PI-degree\r\n                }\r\n                let arcLength=degree*re\r\n                this.tanGraphEdges[i].distance=arcLength\r\n                this.tanGraphEdges[i].crossnum=0\r\n/*                if(degree>Math.PI){\r\n                    this.tanGraphEdges[i].alpha=degree-Math.PI\r\n                }\r\n                else{\r\n                    this.tanGraphEdges[i].alpha=Math.PI-degree\r\n                }*/\r\n                this.tanGraphEdges[i].alpha=littledegree\r\n\r\n                drawArc([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],center,re)\r\n                // console.log()\r\n\r\n            }\r\n\r\n            this.tanGraphEdges[i].cl=cd*this.tanGraphEdges[i].distance+calpha*this.tanGraphEdges[i].alpha+ci*this.tanGraphEdges[i].crossnum\r\n\r\n\r\n        }\r\n        console.timeEnd(\"cal score\")\r\n    }\r\n\r\n    calScoreForAllWithPoly(){\r\n        //cal distance,alpha and crossing num\r\n        console.time(\"cal score\")\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n\r\n            let center=this.tanGraphEdges[i].center\r\n\r\n                let cat\r\n                if(startpoint.type==\"vi\"){\r\n                    cat=this.pointData[startpoint.dataindex[0]].cat\r\n                }\r\n                else{\r\n                    cat=this.pointData[startpoint.dataindex].cat\r\n                }\r\n                // console.log(cat)\r\n                let dis=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                this.tanGraphEdges[i].distance=dis\r\n                this.tanGraphEdges[i].crossnum=0\r\n                this.tanGraphEdges[i].alpha=0\r\n                //cal intersection with elespacepath\r\n                let crossnum=0\r\n                for (let p=0;p<this.elementPoly.length;p++){\r\n                    let cat2=this.pointData[p].cat\r\n                    if(cat!=cat2&&p!=startpoint.dataindex&&p!=endpoint.dataindex) {\r\n                        let polyPoints=[]\r\n                        for (let e=0;e<this.elementPoly[p].length;e++){\r\n                            polyPoints.push({\r\n                                x:this.elementPoly[p][e].x,\r\n                                y:this.elementPoly[p][e].y\r\n                            })\r\n                        }\r\n                        const poly = ShapeInfo.polygon(polyPoints);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(poly, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    }\r\n/*                for (let e=0;e<this.pathString.length;e++){\r\n                    let cat2=this.pointData[e].cat\r\n                    if(cat!=cat2&&e!=startdataid&&e!=enddataid){\r\n                        const path = ShapeInfo.path(this.pathString[e]);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(path, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n\r\n                }*/\r\n                this.tanGraphEdges[i].crossnum=crossnum\r\n\r\n\r\n            this.tanGraphEdges[i].cl=cd*this.tanGraphEdges[i].distance+calpha*this.tanGraphEdges[i].alpha+ci*this.tanGraphEdges[i].crossnum\r\n\r\n\r\n        }\r\n        console.timeEnd(\"cal score\")\r\n    }\r\n\r\n    normalizeEdgeLength(){\r\n        let maxDis=-1\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].distance>maxDis){\r\n                maxDis=this.tanGraphEdges[i].distance\r\n            }\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            this.tanGraphEdges[i].distance=this.tanGraphEdges[i].distance/maxDis\r\n        }\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calPathLength(path){\r\n        let length=0\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let startid=e.from()\r\n            let endid=e.to()\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            length+=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n        }\r\n        return length\r\n    }\r\n\r\n    isSamePath(path1,path2){\r\n        if(path1.length!=path2.length){\r\n            return false\r\n        }\r\n        for (let i=0;i<path1.length;i++){\r\n            let start1=path1[i].from()\r\n            let end1=path1[i].to()\r\n            let start2=path2[i].from()\r\n            let end2=path2[i].to()\r\n            if(start1==start2&&end1==end2||start1==end2&&start2==end1){\r\n\r\n            }\r\n        else{\r\n            return false\r\n            }\r\n\r\n        }\r\n        return true\r\n    }\r\n\r\n    calShortestPath(){\r\n        console.log(this.elementPoly)\r\n\r\n        this.calScoreForAllWithPoly()\r\n\r\n        this.normalizeEdgeLength()\r\n        //cal edge dict\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            edgeDict[startid].push(this.tanGraphEdges[i])\r\n            edgeDict[endid].push(this.tanGraphEdges[i])\r\n        }\r\n\r\n        //create graph\r\n        var g = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length);\r\n\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let score=this.tanGraphEdges[i].cl\r\n            g.addEdge(new jsgraphs.Edge(startid, endid, score));\r\n            g.addEdge(new jsgraphs.Edge(endid, startid, score));\r\n            g.edge(startid,endid).label=i\r\n            g.edge(endid,startid).label=i\r\n\r\n        }\r\n        // this.graph=g\r\n\r\n        var GL= new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length);\r\n\r\n        let dpq={}\r\n        for (var k in this.catPointDict){\r\n            let points=this.catPointDict[k]\r\n            for (let i=0;i<points.length;i++){\r\n                let p1=points[i]\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let p2=points[j]\r\n                    if(!dpq.hasOwnProperty(p1.id)){\r\n                        dpq[p1.id]={}\r\n                    }\r\n                    dpq[p1.id][p2.id]=-1\r\n\r\n                    if(!dpq.hasOwnProperty(p2.id)){\r\n                        dpq[p2.id]={}\r\n                    }\r\n                    dpq[p2.id][p1.id]=-1\r\n                }\r\n            }\r\n        }\r\n\r\n        let paths=[]\r\n\r\n\r\n        while(true){\r\n            let bestscore=-1\r\n            let bestindex1=-1\r\n            let bestindex2=-1\r\n            let minpath=[]\r\n            let hasInfinite=false\r\n\r\n            //find the best link\r\n            for (var k in this.catPointDict){\r\n                let points=this.catPointDict[k]\r\n                for (let i=0;i<points.length;i++){\r\n                    let p1=points[i]\r\n                    var dijkstra = new jsgraphs.Dijkstra(g,p1.id);\r\n\r\n                    for (let j=i+1;j<points.length;j++){\r\n                        let p2=points[j]\r\n\r\n                        //calculate cl and find maximum bpq\r\n                        let path=dijkstra.pathTo(p2.id)\r\n                        let cl=dijkstra.distanceTo(p2.id)\r\n                        let bpq\r\n                        if(dpq[p1.id][p2.id]==-1){\r\n                            if(!hasInfinite){\r\n                                let hasAdded=false\r\n                                for(let p=0;p<paths.length;p++){\r\n                                    if(this.isSamePath(path,paths[p])){\r\n                                        hasAdded=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(!hasAdded){\r\n                                    hasInfinite=true\r\n                                    bestindex1=p1.id\r\n                                    bestindex2=p2.id\r\n                                    bestscore=cl\r\n                                    minpath=path\r\n                                }\r\n                            }\r\n                            else{\r\n                                if(bestscore>cl){\r\n                                    let hasAdded=false\r\n                                    for(let p=0;p<paths.length;p++){\r\n                                        if(this.isSamePath(path,paths[p])){\r\n                                            hasAdded=true\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                    if(!hasAdded) {\r\n                                        bestindex1=p1.id\r\n                                        bestindex2=p2.id\r\n                                        bestscore=cl\r\n                                        minpath=path\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(hasInfinite){\r\n                                continue\r\n                            }\r\n                            else{\r\n                                bpq=dpq[p1.id][p2.id]/cl\r\n                                if(bpq>bestscore){\r\n                                    let hasAdded=false\r\n                                    for(let p=0;p<paths.length;p++){\r\n                                        if(this.isSamePath(path,paths[p])){\r\n                                            hasAdded=true\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                    if(!hasAdded) {\r\n                                        bestscore=bpq\r\n                                        bestindex1=p1.id\r\n                                        bestindex2=p2.id\r\n                                        minpath=path\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(bestscore<=bt){\r\n                break\r\n            }\r\n            else{\r\n                //add this path and update crossnum and dpq\r\n\r\n                this.drawPath(minpath)\r\n                paths.push(minpath)\r\n\r\n                for (let i=0;i<minpath.length;i++){\r\n                    let e=minpath[i]\r\n                    let start=e.from()\r\n                    let end=e.to()\r\n                    let startpoint=this.tanGraphPoints[start]\r\n                    let endpoint=this.tanGraphPoints[end]\r\n\r\n                    if(GL.edge(start,end)==null){\r\n                        GL.addEdge(new jsgraphs.Edge(start, end, calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)) )\r\n                        GL.addEdge(new jsgraphs.Edge(end, start, calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)) )\r\n                    }\r\n\r\n                    //update crossnum\r\n                    for (let p=0;p<this.tanGraphEdges.length;p++){\r\n                        if(this.tanGraphEdges[p].type==\"line\"){\r\n                            let cat\r\n                            if(startpoint.type==\"vi\"){\r\n                                cat=this.pointData[startpoint.dataindex[0]].cat\r\n                            }\r\n                            else{\r\n                                cat=this.pointData[startpoint.dataindex].cat\r\n                            }\r\n\r\n                                let start2=this.tanGraphEdges[p].startid\r\n                                let end2=this.tanGraphEdges[p].endid\r\n                                let startpoint2=this.tanGraphPoints[start2]\r\n                                let endpoint2=this.tanGraphPoints[end2]\r\n\r\n                                let cat2\r\n\r\n                                if(startpoint2.type==\"vi\"){\r\n                                    cat2=this.pointData[startpoint2.dataindex[0]].cat\r\n                                }\r\n                                else{\r\n                                    cat2=this.pointData[startpoint2.dataindex].cat\r\n                                }\r\n                                if(cat!=cat2){\r\n                                    if(this.checkEdgeCrossing(startpoint,endpoint,startpoint2,endpoint2)){\r\n                                        this.tanGraphEdges[p].crossnum+=1\r\n                                        this.tanGraphEdges[p].cl+=ci\r\n                                        let startid=this.tanGraphEdges[p].startid\r\n                                        let endid=this.tanGraphEdges[p].endid\r\n                                        g.edge(startid,endid).weight=this.tanGraphEdges[p].cl\r\n                                        g.edge(endid,startid).weight=this.tanGraphEdges[p].cl\r\n                                    }\r\n                                }\r\n\r\n\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                for(let id1=0;id1<this.pointData.length;id1++){\r\n                    let datapoint=this.pointData[id1]\r\n                    var dijkstraGL = new jsgraphs.Dijkstra(GL,datapoint.id);\r\n\r\n                    for (let id2=id1+1;id2<this.pointData.length;id2++){\r\n                        let datapoint2=this.pointData[id2]\r\n/*                        if(id1==10&&id2==15){\r\n                            console.log(GL.adj(15))\r\n                            console.log(GL.adj(16))\r\n                            console.log(dijkstraGL.hasPathTo(15))\r\n                            console.log()\r\n                        }*/\r\n                        if(dijkstraGL.hasPathTo(datapoint2.id)){\r\n                            let newd=dijkstraGL.distanceTo(datapoint2.id)\r\n                            if(dpq[id1][id2]==-1){\r\n                                dpq[id1][id2]=newd\r\n                                dpq[id2][id1]=newd\r\n                            }\r\n                            else{\r\n                                if(dpq[id1][id2]>newd){\r\n                                    dpq[id1][id2]=newd\r\n                                    dpq[id2][id1]=newd\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n        }\r\n\r\n        console.log(paths)\r\n\r\n    }\r\n\r\n    drawPath(path){\r\n        let that=this\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let start=e.from()\r\n            let end=e.to()\r\n            let startpoint=this.tanGraphPoints[start]\r\n            let endpoint=this.tanGraphPoints[end]\r\n\r\n                // drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"red\",2)\r\n                d3.select(\"svg\").append(\"line\")\r\n                    .attr(\"x1\",startpoint.x)\r\n                    .attr(\"y1\",startpoint.y)\r\n                    .attr(\"x2\",endpoint.x)\r\n                    .attr(\"y2\",endpoint.y)\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"black\")\r\n\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n\r\n        }\r\n    }\r\n\r\n\r\n\r\n    createGraph(){\r\n        //create full graph\r\n        let connectG={}\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let e=0;e<this.tanGraphEdges.length;e++){\r\n            let edge=this.tanGraphEdges[e]\r\n            let distance=calDistance(edge.startpoint[0],edge.startpoint[1],edge.endpoint[0],edge.endpoint[1])\r\n            edgeDict[edge.startid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n            edgeDict[edge.endid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n        }\r\n\r\n\r\n        console.log(edgeDict)\r\n        for (var k in this.catPointDict){\r\n            connectG[k]=[]\r\n            let points=this.catPointDict[k]\r\n            for(let i=0;i<points.length;i++){\r\n                let id1=points[i].id\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let id2=points[j].id\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawTanPoint(){\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"red\",\"none\")\r\n        }\r\n    }\r\n\r\n    drawTangentEdges(){\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            if(startpoint.dataindex==25||endpoint.dataindex==25)\r\n                drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"blue\",1)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData.id=i\r\n        }\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-40)+\" \"+(miny-40)+\" \"+(maxx-minx+80)+\" \"+(maxy-miny+80))\r\n\r\n\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        let offsetX = minx-20;\r\n        let offsetY = miny-20;\r\n        let viewWidth = maxx-minx+40;\r\n        let viewHeight = maxy-miny+40\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id=i\r\n            this.pointData[i].cat=this.pointData[i].cat.toString()\r\n            let cats=this.pointData[i].cat.split(\",\")\r\n            let catarray=[]\r\n            if (cats.length>1){\r\n                this.pointData[i].multicat=true\r\n                for (let c=0;c<cats.length;c++){\r\n                    catarray.push(cats[c])\r\n                }\r\n            }\r\n            else{\r\n                this.pointData[i].multicat=false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray=catarray\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n            }\r\n        }\r\n\r\n        // console.log(this.catPointDict)\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={900} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default KelpDiagram","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport './index.css';\r\nimport {\r\n    drawPolygon,\r\n    drawCircle,\r\n    drawLine,\r\n    calDistance,\r\n    calCommonTanPoint,\r\n    getDegreeTwoVec,\r\n    crossMul,\r\n    calTanPoint, drawArc, rotatePoint, clone\r\n} from \"./util\";\r\nimport * as turf from '@turf/turf'\r\n\r\n\r\nconst {ShapeInfo, Intersection, Point2D, IntersectionQuery} = require(\"kld-intersections\");\r\n\r\nvar d3Voronoi = require(\"d3-voronoi\")\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar triangulate = require(\"delaunay-triangulate\")\r\nvar AreaCal = require('2d-polygon-area');\r\nvar FileSaver = require('file-saver');\r\n// var colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar tanPointsNum = 0\r\nvar deltaDeg = 10 / 180 * Math.PI\r\nvar re = 15\r\nvar parameter_C = 0\r\nvar parameter_t = 3\r\nvar parameter_A = -1\r\nvar EdgeWidth = 10\r\nconst eps = 1e-10\r\nvar neighbors = {}\r\n\r\nvar lineFunction = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    //.curve(d3.curveCatmullRom);\r\n\r\n\r\nclass KelpFusion extends Component{\r\n    constructor(){\r\n        super()\r\n        this.pointData = [];\r\n        this.itemShape=\"circle\"\r\n        this.maxX=Number.MIN_VALUE\r\n        this.minX=Number.MAX_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.itemBBox=[]\r\n        this.catPointDict={}\r\n        this.voronoiPolygons=[]\r\n        this.elementSpace=[]\r\n        this.elementPoly=[]\r\n        //this.pathString=[]\r\n        this.VI=[]\r\n        this.tanGraphEdges=[]\r\n        this.tanGraphPoints=[]\r\n        this.edges=[]\r\n        this.newVI=[]\r\n        this.initGraph = {}\r\n        this.initPoints = {}\r\n        this.initEdges = {}\r\n        this.SPGEdges = {}\r\n        this.SPG = {}\r\n        this.catPointMap = {}\r\n        this.catInitEdges = {}\r\n        this.rGEdges = {}\r\n        this.rG = {}\r\n        this.tanPointMap = {}\r\n        this.visited = []\r\n        this.fa = []\r\n        this.circles = {}\r\n        this.polygons = {}\r\n        this.SPGAdjList = {}\r\n        // this.graph=null\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        let file_list = [\r\n            \"co2_gdppercapita\",\r\n            \"co2_income\",\r\n            \"life_children\",\r\n            \"life_income\",\r\n            \"Bronx\",\r\n            \"Brooklyn\",\r\n            \"Citywide\",\r\n            \"Manhattan\",\r\n            \"life_fertility\",\r\n            \"Staten Island\",\r\n            \"ex1\",\r\n            \"ex2\",\r\n            \"ex3\",\r\n            \"ex4\",\r\n            \"ex5\",\r\n            \"ex6\",\r\n            \"ex7\",\r\n            \"ex8\",\r\n            \"ex9\",\r\n            \"ex10\",\r\n            \"ex11\",\r\n            \"ex12\",\r\n            \"ex13\",\r\n            \"ex14\",\r\n            \"ex15\",\r\n            \"ex16\",\r\n            \"ex17\",\r\n            \"ex18\",\r\n            \"ex19\",\r\n            \"ex20\"\r\n        ];\r\n\r\n\r\n        //let fi = file_list[5]\r\n        let fi = \"ex13\"\r\n        let filename =  fi + \".txt\"\r\n        let flag = false\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n\r\n                console.time(\"running time\")\r\n                this.pointData = data;\r\n                this.itemShape = data[0].shape;\r\n                this.centralizeData()\r\n                //this.drawPointData()\r\n                console.log(filename)\r\n\r\n                /*\r\n                if(flag){\r\n                    let content = JSON.stringify(this.catPointDict)\r\n                    let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n                    FileSaver.saveAs(blob, fi + \".json\");\r\n                }\r\n                else{\r\n                    this.drawLineSets(fi)\r\n                }\r\n                 */\r\n\r\n                console.log(\"pointData!\")\r\n                console.log(this.pointData)\r\n                console.time(\"total time\")\r\n\r\n                this.calVoronoiDiagram()\r\n                this.calElementSpace()\r\n                this.approxArcWithPolygon()\r\n                this.drawSpacePathWithPolygon()\r\n\r\n                for(let k in this.catPointDict){\r\n                    this.rGEdges[k] = []\r\n                }\r\n\r\n                this.calTanGraphWithPolygon()\r\n\r\n                // Add point and edges on the element polygon\r\n                let preLen = this.tanGraphPoints.length\r\n                this.tanPointMap = {}\r\n                for(let k in this.catPointDict){\r\n                    this.catPointMap[k] = {}\r\n                }\r\n                let addIdx = {}\r\n\r\n                for(let i = 0; i < preLen; i ++){\r\n\r\n                    if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n\r\n                        this.tanPointMap[this.tanGraphPoints[i].dataindex] = i\r\n\r\n                        let idx = this.tanGraphPoints[i].dataindex\r\n                        for (let c = 0; c < this.pointData[idx].catArray.length; c ++){\r\n                            let nowcat = this.pointData[idx].catArray[c]\r\n                            if(!this.catPointMap[nowcat].hasOwnProperty(idx)){\r\n                                this.catPointMap[nowcat][idx] = 1\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                for(let i = 0; i < this.elementPoly.length; i ++){\r\n                    addIdx[i] = []\r\n                    for(let j = 0; j < this.elementPoly[i].length ; j ++){\r\n                        let idx = this.tanGraphPoints.length\r\n                        addIdx[i].push(idx)\r\n                        this.tanGraphPoints.push({\r\n                            type:\"addpoint\",\r\n                            x:this.elementPoly[i][j].x,\r\n                            y:this.elementPoly[i][j].y,\r\n                            dataindex:i,\r\n                            id:idx\r\n                        })\r\n                    }\r\n                    for(let j = 0; j < addIdx[i].length; j ++){\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:addIdx[i][j],\r\n                            endid:addIdx[i][(j + 1) % addIdx[i].length]\r\n                        })\r\n\r\n                        for(let k in this.catPointDict){\r\n                            this.rGEdges[k].push({\r\n                                type:\"line\",\r\n                                startid:addIdx[i][j],\r\n                                endid:addIdx[i][(j + 1) % addIdx[i].length]\r\n                            })\r\n                        }\r\n\r\n                        //TODO : Bug Fix\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:addIdx[i][j],\r\n                            endid:this.tanPointMap[i]\r\n                        })\r\n\r\n                        let cat_array = this.pointData[i].catArray\r\n                        for(let c = 0; c < cat_array.length; c ++){\r\n                            let nowcat = cat_array[c]\r\n                            this.rGEdges[nowcat].push({\r\n                                type:\"line\",\r\n                                startid:addIdx[i][j],\r\n                                endid:this.tanPointMap[i]\r\n                            })\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < preLen; i ++){\r\n                    if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n                        continue\r\n                    }\r\n                    let idx\r\n                    if(this.tanGraphPoints[i].type == \"vi\"){\r\n                        idx = this.tanGraphPoints[i].dataindex\r\n                    }\r\n                    else{\r\n                        idx = [this.tanGraphPoints[i].dataindex]\r\n                    }\r\n                    let x1 = this.tanGraphPoints[i].x\r\n                    let y1 = this.tanGraphPoints[i].y\r\n                    for(let j = 0; j < idx.length; j ++){\r\n                        let pointID = idx[j]\r\n                        let selectIdx = -1\r\n                        let minDis = Number.MAX_VALUE\r\n                        for(let p = 0; p < addIdx[pointID].length; p ++){\r\n                            let x2 = this.tanGraphPoints[addIdx[pointID][p]].x\r\n                            let y2 = this.tanGraphPoints[addIdx[pointID][p]].y\r\n                            let tmpDis = calDistance(x1, y1, x2, y2)\r\n                            if(tmpDis < minDis){\r\n                                minDis = tmpDis\r\n                                selectIdx = addIdx[pointID][p]\r\n                            }\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:i,\r\n                            endid:selectIdx\r\n                        })\r\n                        for(let k in this.catPointDict){\r\n                            this.rGEdges[k].push({\r\n                                type:\"line\",\r\n                                startid:i,\r\n                                endid:selectIdx\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //console.log(\"rGEdges\")\r\n                //console.log(this.rGEdges)\r\n\r\n                //for(let cur_k in this.catPointDict){\r\n                //    let cur_k = \"0\"\r\n                //    for(let i = 0; i < this.rGEdges[cur_k].length; i ++){\r\n                //        let startid = this.rGEdges[cur_k][i].startid\r\n                //        let endid = this.rGEdges[cur_k][i].endid\r\n                //        let startpoint = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                //        let endpoint = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n//\r\n                //        let idx1 = this.tanGraphPoints[startid].dataindex\r\n                //        if(this.tanGraphPoints[startid].type != \"vi\"){\r\n                //            idx1 = [idx1]\r\n                //        }\r\n//\r\n                //        let idx2 = this.tanGraphPoints[endid].dataindex\r\n                //        if(this.tanGraphPoints[endid].type != \"vi\"){\r\n                //            idx2 = [idx2]\r\n                //        }\r\n//\r\n                //        let cat1 = this.pointData[idx1[0]].cat\r\n                //        let cat2 = this.pointData[idx2[0]].cat\r\n//\r\n                //        //if(cat1 == cat2 && cat1 == \"2\" && this.tanGraphPoints[endid].type == \"datapoint\" &&this.tanGraphPoints[endid].type == \"datapoint\")\r\n                //            //drawLine(startpoint, endpoint, 'black', 1)\r\n                //    }\r\n               // }\r\n\r\n                //for(let i = 0; i < this.tanGraphEdges.length; i ++){\r\n                //    let startid = this.tanGraphEdges[i].startid\r\n                //    let endid = this.tanGraphEdges[i].endid\r\n                //    let startpoint = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                //    let endpoint = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                //    //drawLine(startpoint, endpoint, 'black', 1)\r\n                //}\r\n\r\n\r\n                //this.drawTanPoint()\r\n                //this.drawTangentEdges()\r\n                //console.log(\"tanGraph!\")\r\n                //console.log(this.tanGraphPoints)\r\n                //console.log(this.tanGraphEdges)\r\n                //console.log(this.elementPoly)\r\n                //console.log(this.elementSpace)\r\n\r\n                //for(let i = 0; i < this.tanGraphPoints.length ; i ++){\r\n                //    d3.select('svg').append(\"circle\")\r\n                //        .attr(\"cx\",this.tanGraphPoints[i].x)\r\n                //        .attr(\"cy\",this.tanGraphPoints[i].y)\r\n                //        .attr(\"r\",1)\r\n                //        .attr(\"fill\",\"black\")\r\n                //}\r\n\r\n                //for(let i = 0; i < )\r\n\r\n\r\n                this.createInitGraph()\r\n                this.createSPG()\r\n\r\n                console.timeEnd(\"total time\")\r\n\r\n                //this.calCrossEdges()\r\n\r\n                console.timeEnd(\"running time\")\r\n\r\n                this.findAllCircles()\r\n                this.findPolygons()\r\n                this.judgePolygons()\r\n                this.drawKelpFusion()\r\n                this.drawPointData()\r\n                this.saveSVG(fi)\r\n\r\n                //console.log(this.elementSpace)\r\n\r\n               //console.log(\"element space\")\r\n               //console.log(this.elementSpace)\r\n               //console.log(\"element ploygon\")\r\n               //console.log(this.elementPoly)\r\n\r\n\r\n\r\n            })\r\n\r\n\r\n    }\r\n\r\n    saveSVG(filename){\r\n        let svg=d3.select(\"#mainsvg\")\r\n        let width=svg.attr(\"width\")\r\n        let height=svg.attr(\"height\")\r\n        let viewbox=svg.attr(\"viewBox\")\r\n        let svgstr=svg.html()\r\n        let xmlns=\"http://www.w3.org/2000/svg\"\r\n        svgstr=\"<svg xmlns=\\\"\"+xmlns+\"\\\" width=\\\"\"+width+\"\\\" height=\\\"\"+height+\"\\\" viewBox=\\\"\"+viewbox+\"\\\" >\\n\"+svgstr+\"\\n</svg>\"\r\n        let content = svgstr;\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n        FileSaver.saveAs(blob, filename + \".svg\");\r\n        // console.log(svgstr)\r\n    }\r\n\r\n    drawLineSets(fi){\r\n        let filename1 = fi + \".txt\"\r\n        let filename2 = fi + \"_cross.txt\"\r\n        fetch('/data/line_data/'+filename1,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                let path = data\r\n                console.log(path)\r\n                for(let k in this.catPointDict){\r\n                    d3.select(\"svg\").append(\"path\")\r\n                        .attr('d',lineFunction(path[k]))\r\n                        .attr(\"id\",\"path\" + k)\r\n                        .attr(\"fill\",'none')\r\n                        .style('stroke', colors[parseInt(k)])\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n\r\n                this.saveSVG(fi)\r\n\r\n                /*\r\n                fetch('/data/line_data/'+filename2,{\r\n                    method:'GET',\r\n                    headers:{\r\n                        'Content-Type':'application/json;charset=UTF-8'\r\n                    },\r\n                    mode:'cors',\r\n                    cache:'default'\r\n                })\r\n                    .then(res=>res.json())\r\n                    .then(data=>{\r\n                        let cross_edge = data\r\n                        for(let k in cross_edge){\r\n                            let tmpPath = d3.select(\"#path\" + k).node()\r\n                            let totLen = tmpPath.getTotalLength()\r\n                            for(let p = 0; p < cross_edge[k].length; p ++){\r\n                                let st = [cross_edge[k][p][0], cross_edge[k][p][1]]\r\n                                let en = [cross_edge[k][p][2], cross_edge[k][p][3]]\r\n                                //drawLine(st, en, \"red\", 4)\r\n                                let idx1 = -1\r\n                                let idx2 = -1\r\n                                let mindis1 = Number.MAX_VALUE\r\n                                let mindis2 = Number.MAX_VALUE\r\n                                for(let l = 0; l < totLen / 5; l ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * l)\r\n                                    let dis1 = calDistance(st[0], st[1], tmp_p.x, tmp_p.y)\r\n                                    let dis2 = calDistance(en[0], en[1], tmp_p.x, tmp_p.y)\r\n                                    if(dis1 < mindis1){\r\n                                        mindis1 = dis1\r\n                                        idx1 = l\r\n                                    }\r\n                                    if(dis2 < mindis2){\r\n                                        mindis2 = dis2\r\n                                        idx2 = l\r\n                                    }\r\n                                }\r\n                                let tmp_lines = []\r\n                                for(let l = idx1; l <= idx2; l ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * l)\r\n                                    tmp_lines.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr('d',lineFunction(tmp_lines))\r\n                                    .attr(\"fill\",'none')\r\n                                    .style('stroke', \"red\")\r\n                                    .style(\"stroke-width\", 4);\r\n                            }\r\n                        }\r\n\r\n                        this.saveSVG(fi)\r\n\r\n                    })\r\n                 */\r\n            })\r\n    }\r\n\r\n    addCircularEdge(tanPoints){\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for (let i=0;i<tanPoints.length;i++){\r\n            let points=tanPoints[i]\r\n            for(let e=0;e<this.elementSpace[i].length;e++){\r\n                let eseg=this.elementSpace[i][e]\r\n                if(eseg.type==\"arc\"){\r\n                    let onpoints=[]\r\n                    let dearray=[]\r\n                    for(let p=0;p<points.length;p++){\r\n                        if(this.isPointOnArc([points[p].x,points[p].y],eseg)){\r\n                            onpoints.push(points[p])\r\n                        }\r\n                    }\r\n                    //sort the points according to degree\r\n\r\n                    let startpoint=this.tanGraphPoints[eseg.startid]\r\n                    let endpoint=this.tanGraphPoints[eseg.endid]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n\r\n                    for (let p=0;p<onpoints.length;p++){\r\n                        let pointvec=[onpoints[p].x-eseg.center[0],onpoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n\r\n                        dearray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n                    dearray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<dearray.length;d++){\r\n                        nextd=onpoints[dearray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push({\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:nextd.id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            })\r\n                        }\r\n\r\n\r\n\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:endpoint.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                    }\r\n\r\n                    /*                    if(this.tanGraphEdges.length>=60036){\r\n                                            console.log()\r\n                                        }*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    findApproxPointOnArc(point,arc){\r\n        let polypoints=arc.polysegment\r\n        let startpoint=arc.start\r\n        let center=arc.center\r\n        let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let degree=getDegreeTwoVec(startvec,pointvec)\r\n        let crossmul1=crossMul(startvec,pointvec)\r\n        if(crossmul1>0){\r\n            degree=2*Math.PI-degree\r\n        }\r\n        if(degree<0.000001){\r\n            return 0\r\n        }\r\n        let index=parseInt(degree/deltaDeg)\r\n\r\n        /*        if(index>polypoints.length-1){\r\n                    d3.select(\"svg\").selectAll(\"circle\").remove()\r\n                    drawCircle(point[0],point[1],5,\"red\",\"none\")\r\n                    drawCircle(polypoints[polypoints.length-1][0],polypoints[polypoints.length-1][1],5,\"blue\",\"none\")\r\n                    drawCircle(polypoints[0][0],polypoints[0][1],5,\"black\",\"none\")\r\n\r\n                }*/\r\n\r\n        return index\r\n    }\r\n\r\n    isExist(p,points){\r\n        for(let i=0;i<points.length;i++){\r\n            if(p[0]==points[i].x&&p[1]==points[i].y){\r\n                return points[i].id\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n    calTanGraphWithPolygon(){\r\n        let tempTanEdges=[]\r\n        let tempTanPoints=[]\r\n        let pointsOnSameArc=[]\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            pointsOnSameArc.push([])\r\n        }\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            tempTanPoints.push(this.newVI[i])\r\n        }\r\n        //console.log(this.catPointDict)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    let arc1\r\n                    let arc2\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    arc1=eleSpace1[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                        arc1=eleSpace1[0]\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    arc2=eleSpace2[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        arc2=eleSpace2[0]\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        let polyindex1=this.findApproxPointOnArc(linestart,arc1)\r\n                        let tanpoint1=arc1.polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        // drawCircle(tanpoint1[0],tanpoint1[1],2,\"green\",\"none\")\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex2=this.findApproxPointOnArc(lineend,arc2)\r\n\r\n                        let tanpoint2=arc2.polysegment[polyindex2]\r\n                        // drawCircle(tanpoint2[0],tanpoint2[1],2,\"green\",\"none\")\r\n\r\n                        let existindex2=this.isExist(tanpoint2,tempTanPoints)\r\n                        if(existindex2==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint2[0],\r\n                                y:tanpoint2[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex2=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:existindex1,\r\n                            endid:existindex2,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push({\r\n                                type:\"line\",\r\n                                startid:existindex1,\r\n                                endid:existindex2,\r\n                                // startpoint:linestart,\r\n                                // endpoint:lineend\r\n                            })\r\n                        }\r\n\r\n                        // drawLine([this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],[this.tanGraphPoints[existindex2].x,this.tanGraphPoints[existindex2].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                let sameflag = false\r\n                let addcat = []\r\n                for(let p = 0; p < this.pointData[i].catArray.length; p ++){\r\n                    for(let q = 0; q < this.pointData[j].catArray.length; q ++){\r\n                        if(this.pointData[i].catArray[p] == this.pointData[j].catArray[q]){\r\n                            sameflag = true\r\n                            addcat.push(this.pointData[i].catArray[p])\r\n                        }\r\n                    }\r\n                }\r\n                //if(sameflag){\r\n                if(true){\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n\r\n                    for(let p = 0; p < addcat.length; p ++){\r\n                        this.rGEdges[addcat[p]].push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:index2,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[points[j].x,points[j].y]\r\n                        })\r\n                    }\r\n\r\n\r\n                    if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                        //p to q\r\n                        let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                        tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                        if(eleSpace2.length==1){\r\n                            let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace2[0])\r\n                            let tanpoint0=eleSpace2[0].polysegment[polyindex0]\r\n                            let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                            if(existindex0==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint0[0],\r\n                                    y:tanpoint0[1],\r\n                                    dataindex:index2,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex0=tanpoint.id\r\n                                pointsOnSameArc[index2].push(tanpoint)\r\n                            }\r\n\r\n                            let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace2[0])\r\n                            let tanpoint1=eleSpace2[0].polysegment[polyindex1]\r\n                            let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                            if(existindex1==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint1[0],\r\n                                    y:tanpoint1[1],\r\n                                    dataindex:index2,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex1=tanpoint.id\r\n                                pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                            }\r\n\r\n\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index1,\r\n                                endid:existindex0,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                            })\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index1,\r\n                                endid:existindex1,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                            })\r\n\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index1,\r\n                                    endid:existindex0,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                })\r\n                            }\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index1,\r\n                                    endid:existindex1,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                })\r\n                            }\r\n\r\n\r\n                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                            // console.log()\r\n\r\n                        }\r\n                        else{\r\n\r\n                            for (let p=0;p<tanPoints.length;p++){\r\n                                for (let e=0;e<eleSpace2.length;e++){\r\n                                    if(eleSpace2[e].type==\"arc\"){\r\n                                        if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                            let polyindex=this.findApproxPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])\r\n                                            let tanpoint=eleSpace2[e].polysegment[polyindex]\r\n                                            let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                            if(existindex==-1){\r\n                                                let tanpointp={\r\n                                                    type:\"tanpoint\",\r\n                                                    x:tanpoint[0],\r\n                                                    y:tanpoint[1],\r\n                                                    dataindex:index2,\r\n                                                    id:tanPointsNum\r\n                                                }\r\n                                                this.tanGraphPoints.push(tanpointp)\r\n                                                tempTanPoints.push(tanpointp)\r\n                                                tanPointsNum+=1\r\n                                                existindex=tanpointp.id\r\n                                                pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                                            }\r\n                                            this.tanGraphEdges.push({\r\n                                                type:\"line\",\r\n                                                startid:index1,\r\n                                                endid:existindex,\r\n                                                // startpoint:[points[i].x,points[i].y],\r\n                                                // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                            })\r\n\r\n                                            for(let cat_k in this.catPointDict){\r\n                                                this.rGEdges[cat_k].push({\r\n                                                    type:\"line\",\r\n                                                    startid:index1,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                })\r\n                                            }\r\n                                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                            // console.log()\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        //q to p\r\n                        let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                        tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                        if(eleSpace1.length==1){\r\n                            let polyindex0=this.findApproxPointOnArc([tanPoints2[0].x,tanPoints2[0].y],eleSpace1[0])\r\n                            let tanpoint0=eleSpace1[0].polysegment[polyindex0]\r\n                            let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                            if(existindex0==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint0[0],\r\n                                    y:tanpoint0[1],\r\n                                    dataindex:index1,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex0=tanpoint.id\r\n                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                            }\r\n\r\n                            let polyindex1=this.findApproxPointOnArc([tanPoints2[1].x,tanPoints2[1].y],eleSpace1[0])\r\n                            let tanpoint1=eleSpace1[0].polysegment[polyindex1]\r\n                            let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                            if(existindex1==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint1[0],\r\n                                    y:tanpoint1[1],\r\n                                    dataindex:index1,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex1=tanpoint.id\r\n                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                            }\r\n\r\n\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index2,\r\n                                endid:existindex0,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                            })\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index2,\r\n                                endid:existindex1,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                            })\r\n\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index2,\r\n                                    endid:existindex0,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                })\r\n                            }\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index2,\r\n                                    endid:existindex1,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                })\r\n                            }\r\n\r\n                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                            // console.log()\r\n                        }\r\n                        else{\r\n                            for (let p=0;p<tanPoints2.length;p++){\r\n                                for (let e=0;e<eleSpace1.length;e++){\r\n                                    if(eleSpace1[e].type==\"arc\"){\r\n                                        if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                            let polyindex=this.findApproxPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])\r\n                                            let tanpoint=eleSpace1[e].polysegment[polyindex]\r\n                                            let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                            if(existindex==-1){\r\n                                                let tanpointp={\r\n                                                    type:\"tanpoint\",\r\n                                                    x:tanpoint[0],\r\n                                                    y:tanpoint[1],\r\n                                                    dataindex:index1,\r\n                                                    id:tanPointsNum\r\n                                                }\r\n                                                this.tanGraphPoints.push(tanpointp)\r\n                                                tempTanPoints.push(tanpointp)\r\n                                                tanPointsNum+=1\r\n                                                existindex=tanpointp.id\r\n                                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                                            }\r\n                                            this.tanGraphEdges.push({\r\n                                                type:\"line\",\r\n                                                startid:index2,\r\n                                                endid:existindex,\r\n                                                // startpoint:[points[i].x,points[i].y],\r\n                                                // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                            })\r\n\r\n                                            for(let cat_k in this.catPointDict){\r\n                                                this.rGEdges[cat_k].push({\r\n                                                    type:\"line\",\r\n                                                    startid:index2,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                })\r\n                                            }\r\n\r\n\r\n                                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                            // console.log()\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.pointData[this.newVI[i].dataindex[0]].catArray\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].catArray\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n\r\n                let sameflag = false\r\n                let addcat = []\r\n                for(let id1 = 0; id1 < cat1.length; id1 ++){\r\n                    for(let id2 = 0; id2 < cat2.length; id2 ++){\r\n                        if(cat1[id1] == cat2[id2]){\r\n                            sameflag = true\r\n                            addcat.push(cat1[id1])\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //if(sameflag){\r\n                if(true){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:this.newVI[i].id,\r\n                        endid:this.pointData[p].id,\r\n                        // startpoint:[points[j].x,points[j].y],\r\n                        // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                    })\r\n\r\n                    for(let cur_idx = 0; cur_idx < addcat.length; cur_idx ++){\r\n                        this.rGEdges[addcat[cur_idx]].push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:this.pointData[p].id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                        })\r\n                    }\r\n\r\n                }\r\n\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace[0])\r\n                        let tanpoint0=eleSpace[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace[0])\r\n                        let tanpoint1=eleSpace[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex0,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex1,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"line\",\r\n                                    startid:this.newVI[i].id,\r\n                                    endid:existindex0,\r\n                                    // startpoint:vp,\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                }\r\n                            )\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"line\",\r\n                                    startid:this.newVI[i].id,\r\n                                    endid:existindex1,\r\n                                    // startpoint:vp,\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                }\r\n                            )\r\n                        }\r\n\r\n\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[t].x,tanPoints[t].y],eleSpace[e])\r\n                                        let tanpoint=eleSpace[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:p,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:this.newVI[i].id,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n\r\n                                        for(let cat_k in this.catPointDict){\r\n                                            this.rGEdges[cat_k].push(\r\n                                                {\r\n                                                    type:\"line\",\r\n                                                    startid:this.newVI[i].id,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                }\r\n                                            )\r\n                                        }\r\n\r\n\r\n                                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        this.addCircularEdge(pointsOnSameArc)\r\n    }\r\n\r\n    above(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) > 0\r\n    }\r\n\r\n    below(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) < 0\r\n    }\r\n\r\n    isLeft(P0, P1, P2) {\r\n        return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);\r\n    }\r\n\r\n    RLtangent_PolyPolyC(V, W) {\r\n        let  ix1, ix2;      // search indices for polygons 1 and 2\r\n\r\n        // first get the initial vertex on each polygon\r\n        // ix1 = this.Rtangent_PointPolyC(W[0], V);   // right tangent from W[0] to V\r\n        ix1=this.tangent_PointPoly(W[0],V)[1]\r\n        // ix2 = this.Ltangent_PointPolyC(V[ix1], W); // left tangent from V[ix1] to W\r\n\r\n        ix2=this.tangent_PointPoly(V[ix1],W)[0]\r\n\r\n        // ping-pong linear search until it stabilizes\r\n        let done = false                    // flag when done\r\n        while (done == false) {\r\n            done = true;                     // assume done until...\r\n            while (this.isLeft(W[(ix2+W.length)%W.length], V[ix1], V[ix1+1]) <= 0){\r\n                ++ix1;                       // get Rtangent from W[ix2] to V\r\n            }\r\n\r\n            while (this.isLeft(V[ix1], W[(ix2+W.length)%W.length], W[(ix2-1+W.length)%W.length]) >= 0){\r\n                --ix2;                       // get Ltangent from V[ix1] to W\r\n                done = false;                // not done if had to adjust this\r\n            }\r\n        }\r\n        let t1 = ix1;\r\n        let t2 = ix2;\r\n        if(t1<0){\r\n            t1=t1+V.length\r\n        }\r\n        if(t2<0){\r\n            t2=t2+W.length\r\n        }\r\n\r\n        return[t1,t2]\r\n    }\r\n\r\n    drawSpacePathWithPolygon(){\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let espace=this.elementPoly[i]\r\n            let nowp=espace[0]\r\n            let nextp\r\n            for (let e=1;e<espace.length;e++){\r\n                nextp=espace[e]\r\n                drawLine([nowp.x,nowp.y],[nextp.x,nextp.y],\"black\",1)\r\n                nowp=nextp\r\n            }\r\n        }\r\n    }\r\n\r\n    approxArcWithPolygon(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            for (let e=0;e<espace.length;e++){\r\n\r\n                let center=espace[e].center\r\n                let radius=espace[e].radius\r\n                if(espace[e].type==\"arc\"){\r\n                    let startpoint=espace[e].start\r\n                    let endpoint=espace[e].end\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    let endvec=[endpoint[0]-center[0],endpoint[1]-center[1]]\r\n                    // let vecstart=[espace[e].]\r\n                    let degree=getDegreeTwoVec(startvec,endvec)\r\n\r\n                    let crossmul1=crossMul(startvec,endvec)\r\n                    if(crossmul1>0){\r\n                        degree=2*Math.PI-degree\r\n                    }\r\n\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n\r\n                    polySegs.push(startpoint)\r\n                    while(d<degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n                else if(espace[e].type==\"circle\"){\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    let endpoint=startpoint\r\n                    espace[e].start=startpoint\r\n                    espace[e].end=endpoint\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n                    let degree=Math.PI*2\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n                    polySegs.push(startpoint)\r\n                    while(d<=degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            let newespace=[]\r\n            for (let e=0;e<espace.length;e++){\r\n                if(espace[e].type==\"line\"){\r\n                    newespace.push(espace[e])\r\n                }\r\n                else{\r\n                    //arc segments\r\n                    let nowp=espace[e].polysegment[0]\r\n                    for (let s=1;s<espace[e].polysegment.length;s++){\r\n                        let nextp=espace[e].polysegment[s]\r\n                        newespace.push({\r\n                            type:\"line\",\r\n                            center:espace[e].center,\r\n                            radius:re,\r\n                            start:nowp,\r\n                            end:nextp\r\n                        })\r\n                        nowp=nextp\r\n                    }\r\n                }\r\n            }\r\n            this.elementPoly.push(newespace)\r\n        }\r\n\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let eseg=this.elementPoly[i]\r\n            let newsegs=[]\r\n            newsegs.push({\r\n                x:eseg[0].start[0],\r\n                y:eseg[0].start[1],\r\n                degree:0\r\n            })\r\n            for (let e=0;e<eseg.length;e++){\r\n                let point=eseg[e].end\r\n                newsegs.push({\r\n                    x:point[0],\r\n                    y:point[1],\r\n                    degree:0\r\n                })\r\n            }\r\n            this.elementPoly[i]=newsegs\r\n        }\r\n\r\n        console.log(this.elementPoly)\r\n\r\n    }\r\n\r\n    calVoronoiDiagram(){\r\n        let that=this\r\n        let diagram=d3Voronoi.voronoi()\r\n            .extent([[that.minX-50,that.minY-50],[that.maxX+50,that.maxY+50]])\r\n            .x(function(d){\r\n                return d.x\r\n            })\r\n            .y(function(d){\r\n                return d.y\r\n            })\r\n        let polygons=diagram.polygons(this.pointData)\r\n        this.voronoiPolygons=polygons\r\n        //Polygons are also counterclockwise\r\n        /*        for (let i=0;i<polygons.length;i++){\r\n                    drawPolygon(polygons[i],0,0,\"red\")\r\n                }*/\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    drawCircle(this.pointData[i].x,this.pointData[i].y,re,\"none\",\"black\")\r\n                }*/\r\n\r\n        console.log(polygons)\r\n\r\n    }\r\n\r\n    calElementSpace(){\r\n        for (let i=0;i<this.voronoiPolygons.length;i++){\r\n            let polypoints=this.voronoiPolygons[i]\r\n            let pointnum=polypoints.length\r\n            let data=polypoints.data\r\n            let id=polypoints.data.id\r\n            let eleSpace=[]\r\n            let insideLines=[]\r\n            let circle=ShapeInfo.circle({cx: data.x, cy: data.y, r: re})\r\n            let vi=[]\r\n            for (let p=0;p<polypoints.length;p++){\r\n                let thisp=polypoints[p]\r\n                let nextp=polypoints[(p+1)%pointnum]\r\n                // drawLine(thisp,nextp,\"blue\")\r\n                //check intersection between line and circle\r\n                let inside=IntersectionQuery.pointInCircle( {x:thisp[0],y:thisp[1]}, {x:data.x,y:data.y} ,  re)\r\n                if(inside){\r\n                    let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                    if(inside2){\r\n                        insideLines.push([thisp,nextp])\r\n                    }\r\n                    else{\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        let point=intersections.points[0]\r\n                        vi.push([point.x,point.y])\r\n                        insideLines.push([thisp,[point.x,point.y]])\r\n                    }\r\n                }\r\n                else{\r\n                    let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                    if(inside2){\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        let point=intersections.points[0]\r\n                        vi.push([point.x,point.y])\r\n                        insideLines.push([[point.x,point.y],nextp])\r\n                    }\r\n                    else{\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            let points=intersections.points\r\n                            let dis1=calDistance(thisp[0],thisp[1],points[0].x,points[0].y)\r\n                            let dis2=calDistance(thisp[0],thisp[1],points[1].x,points[1].y)\r\n                            if(dis1<dis2){\r\n                                insideLines.push([[points[0].x,points[0].y],[points[1].x,points[1].y]])\r\n                                vi.push([points[0].x,points[0].y])\r\n                                vi.push([points[1].x,points[1].y])\r\n                            }\r\n                            else{\r\n                                insideLines.push([[points[1].x,points[1].y],[points[0].x,points[0].y]])\r\n                                vi.push([points[1].x,points[1].y])\r\n                                vi.push([points[0].x,points[0].y])\r\n                            }\r\n                        }\r\n                        else{\r\n                            //no intersection with the circle\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.VI.push(vi)\r\n            if(insideLines.length>0){\r\n                for (let l=0;l<insideLines.length;l++){\r\n                    // drawLine(insideLines[l][0],insideLines[l][1],\"blue\")\r\n                    eleSpace.push({\r\n                        type:\"line\",\r\n                        start:insideLines[l][0],\r\n                        end:insideLines[l][1],\r\n                        center:[data.x,data.y],\r\n                        radius:re\r\n                    })\r\n                    let point1=insideLines[l][1]\r\n                    let point2=insideLines[(l+1)%insideLines.length][0]\r\n                    if(point1[0]==point2[0]&&point1[1]==point2[1]){\r\n\r\n                    }\r\n                    else{\r\n                        //insert an arc\r\n                        eleSpace.push({\r\n                            type:\"arc\",\r\n                            start:point1,\r\n                            end:point2,\r\n                            center:[data.x,data.y],\r\n                            radius:re\r\n                        })\r\n                    }\r\n\r\n                }\r\n            }\r\n            else{\r\n                eleSpace.push({\r\n                    type:\"circle\",\r\n                    start:[],\r\n                    end:[],\r\n                    center:[data.x,data.y],\r\n                    radius:re\r\n                })\r\n            }\r\n            this.elementSpace.push(eleSpace)\r\n        }\r\n        console.log(this.elementSpace)\r\n    }\r\n\r\n    initVI(){\r\n        // console.log(this.VI)\r\n        let newVI=[]\r\n        for (let i=0;i<this.VI.length;i++){\r\n            for (let j=0;j<this.VI[i].length;j++){\r\n                let vpoint=this.VI[i][j]\r\n                let has=false\r\n                for (let v=0;v<newVI.length;v++){\r\n                    if(vpoint[0]==newVI[v].x&&vpoint[1]==newVI[v].y){\r\n                        has=true\r\n                        break\r\n                    }\r\n                }\r\n                if(!has){\r\n                    let vipoint={\r\n                        type:\"vi\",\r\n                        x:vpoint[0],\r\n                        y:vpoint[1],\r\n                        dataindex:[i,j],\r\n                        id:tanPointsNum\r\n                    }\r\n                    tanPointsNum+=1\r\n                    newVI.push(vipoint)\r\n                    this.tanGraphPoints.push(vipoint)\r\n                }\r\n            }\r\n\r\n        }\r\n        this.newVI=newVI\r\n        for(let i=0;i<newVI.length;i++){\r\n            for (let e=0;e<this.elementSpace.length;e++){\r\n                let espace=this.elementSpace[e]\r\n                for (let s=0;s<espace.length;s++){\r\n                    let eseg=espace[s]\r\n                    if(eseg.type==\"arc\"){\r\n                        let start=eseg.start\r\n                        let end=eseg.end\r\n                        if(start[0]==newVI[i].x&&start[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].startid=newVI[i].id\r\n                        }\r\n                        if(end[0]==newVI[i].x&&end[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].endid=newVI[i].id\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(this.newVI)\r\n    }\r\n\r\n    isPointOnArc(point,arc){\r\n        let start=arc.start\r\n        let end=arc.end\r\n        let center=arc.center\r\n        let startvec=[start[0]-center[0],start[1]-center[1]]\r\n        let endvec=[end[0]-center[0],end[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let startEndDeg=getDegreeTwoVec(startvec,endvec)\r\n        let pointStartDeg=getDegreeTwoVec(startvec,pointvec)\r\n\r\n        let crossmul1=crossMul(startvec,endvec)\r\n\r\n        if(crossmul1>0){\r\n            startEndDeg=2*Math.PI-startEndDeg\r\n        }\r\n\r\n        let crossmul2=crossMul(startvec,pointvec)\r\n\r\n        if(crossmul2>0){\r\n            pointStartDeg=2*Math.PI-pointStartDeg\r\n        }\r\n\r\n        if(pointStartDeg<=startEndDeg){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    splitCircularEdge(){\r\n        let viMap=[]\r\n        let tanPointMap=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            viMap.push([])\r\n            tanPointMap.push([])\r\n        }\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let id=this.newVI[i].dataindex[0]\r\n            viMap[id].push(this.newVI[i])\r\n        }\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].type==\"tanpoint\"){\r\n                let index=this.tanGraphPoints[i].dataindex\r\n                tanPointMap[index].push(this.tanGraphPoints[i])\r\n            }\r\n        }\r\n\r\n        /*        for (let i=0;i<tanPointMap.length;i++){\r\n                    if(i==91){\r\n                        for (let j=0;j<tanPointMap[i].length;j++){\r\n                            drawCircle(tanPointMap[i][j].x,tanPointMap[i][j].y,2,\"red\",\"none\")\r\n                        }\r\n                    }\r\n                }*/\r\n\r\n\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            let elespace=this.elementSpace[i]\r\n            let vis=viMap[i]\r\n            let tanpoints=tanPointMap[i]\r\n            for(let e=0;e<elespace.length;e++){\r\n                let eseg=elespace[e]\r\n                if(eseg.type==\"arc\"){\r\n                    //split this eseg\r\n                    let startindex=-1\r\n                    let endindex=-1\r\n                    let startpoint\r\n                    let endpoint\r\n                    let onPoints=[]\r\n                    for (let v=0;v<vis.length;v++){\r\n                        if(vis[v].x==eseg.start[0]&&vis[v].y==eseg.start[1]){\r\n                            startindex=vis[v].id\r\n                            startpoint=this.tanGraphPoints[startindex]\r\n                        }\r\n                        if(vis[v].x==eseg.end[0]&&vis[v].y==eseg.end[1]){\r\n                            endindex=vis[v].id\r\n                            endpoint=this.tanGraphPoints[endindex]\r\n                        }\r\n                    }\r\n                    for (let t=0;t<tanpoints.length;t++){\r\n                        if(this.isPointOnArc([tanpoints[t].x,tanpoints[t].y],eseg)){\r\n                            onPoints.push(tanpoints[t])\r\n                        }\r\n                    }\r\n                    // console.log(startindex,endindex,onPoints)\r\n                    /*                    if(i==91){\r\n                                            drawCircle(startpoint.x,startpoint.y,5,\"red\",\"none\")\r\n                                            drawCircle(endpoint.x,endpoint.y,5,\"green\",\"none\")\r\n                                            for (let o=0;o<onPoints.length;o++){\r\n                                                drawCircle(onPoints[o].x,onPoints[o].y,2,\"blue\",\"none\")\r\n                                            }\r\n\r\n                                        }*/\r\n\r\n                    let deArray=[]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n                    let endvec=[endpoint.x-eseg.center[0],endpoint.y-eseg.center[1]]\r\n                    for (let p=0;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n\r\n                    }\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"arc\",\r\n                                    startid:thisd.id,\r\n                                    endid:nextd.id,\r\n                                    center:eseg.center,\r\n                                    radius:re\r\n                                }\r\n                            )\r\n                        }\r\n\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push(\r\n                            {\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:endpoint.id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n                else if(eseg.type==\"circle\"){\r\n                    let onPoints=tanpoints\r\n                    let startvec=[onPoints[0].x-eseg.center[0],onPoints[0].y-eseg.center[1]]\r\n                    let deArray=[]\r\n                    for (let p=1;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=onPoints[0]\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"arc\",\r\n                                    startid:thisd.id,\r\n                                    endid:nextd.id,\r\n                                    center:eseg.center,\r\n                                    radius:re\r\n                                }\r\n                            )\r\n                        }\r\n\r\n                        // if(this.tanGraphEdges.length==6002){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:onPoints[0].id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push(\r\n                            {\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:onPoints[0].id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n        console.log(this.tanGraphEdges)\r\n        /*        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n                    if(this.tanGraphPoints[i].dataindex==91){\r\n                        drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"green\",\"none\")\r\n                    }\r\n                }*/\r\n    }\r\n\r\n    drawSplitEdge(){\r\n        for(let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].type==\"arc\"){\r\n                let pathstr=\"\"\r\n                let startid=this.tanGraphEdges[i].startid\r\n                let endid=this.tanGraphEdges[i].endid\r\n                let startp=[this.tanGraphPoints[startid].x,this.tanGraphPoints[startid].y]\r\n                let endp=[this.tanGraphPoints[endid].x,this.tanGraphPoints[endid].y]\r\n                let center=this.tanGraphEdges[i].center\r\n                let radius=this.tanGraphEdges[i].radius\r\n\r\n                // drawCircle(startp[0],startp[1],2,\"red\",\"none\")\r\n                // drawCircle(endp[0],endp[1],2,\"red\",\"none\")\r\n\r\n                pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                let largearcflag=0\r\n                let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n                /*                    if(i==5){\r\n                                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                                        drawLine(vec1[0],vec1[1],\"red\")\r\n                                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                                    }*/\r\n\r\n                let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                if(crossmul>0){\r\n                    largearcflag=1\r\n                }\r\n                else if(crossmul<=0){\r\n                    largearcflag=0\r\n                }\r\n\r\n                pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n                d3.select(\"svg\")\r\n                    .append(\"path\")\r\n                    .attr(\"d\",pathstr)\r\n                    .attr(\"fill\",\"none\")\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"stroke-width\",\"1\")\r\n            }\r\n        }\r\n    }\r\n\r\n    normalizeEdgeLength(){\r\n        let maxDis=-1\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].distance>maxDis){\r\n                maxDis=this.tanGraphEdges[i].distance\r\n            }\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            this.tanGraphEdges[i].distance=this.tanGraphEdges[i].distance/maxDis\r\n        }\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calPathLength(path){\r\n        let length=0\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let startid=e.from()\r\n            let endid=e.to()\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            length+=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n        }\r\n        return length\r\n    }\r\n\r\n    isSamePath(path1,path2){\r\n        if(path1.length!=path2.length){\r\n            return false\r\n        }\r\n        for (let i=0;i<path1.length;i++){\r\n            let start1=path1[i].from()\r\n            let end1=path1[i].to()\r\n            let start2=path2[i].from()\r\n            let end2=path2[i].to()\r\n            if(start1==start2&&end1==end2||start1==end2&&start2==end1){\r\n\r\n            }\r\n            else{\r\n                return false\r\n            }\r\n\r\n        }\r\n        return true\r\n    }\r\n\r\n    drawPath(path){\r\n        let that=this\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let edgeid=e.label\r\n            let edge=this.tanGraphEdges[edgeid]\r\n            let startpoint=this.tanGraphPoints[edge.startid]\r\n            let endpoint=this.tanGraphPoints[edge.endid]\r\n            if(edge.type==\"line\"){\r\n                // drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"red\",2)\r\n                d3.select(\"svg\").append(\"line\")\r\n                    .attr(\"x1\",startpoint.x)\r\n                    .attr(\"y1\",startpoint.y)\r\n                    .attr(\"x2\",endpoint.x)\r\n                    .attr(\"y2\",endpoint.y)\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.tanGraphEdges[edgeid])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n            }\r\n        }\r\n    }\r\n\r\n    createGraph(){\r\n        //create full graph\r\n        let connectG={}\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let e=0;e<this.tanGraphEdges.length;e++){\r\n            let edge=this.tanGraphEdges[e]\r\n            let distance=calDistance(edge.startpoint[0],edge.startpoint[1],edge.endpoint[0],edge.endpoint[1])\r\n            edgeDict[edge.startid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n            edgeDict[edge.endid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n        }\r\n\r\n\r\n        console.log(edgeDict)\r\n        for (var k in this.catPointDict){\r\n            connectG[k]=[]\r\n            let points=this.catPointDict[k]\r\n            for(let i=0;i<points.length;i++){\r\n                let id1=points[i].id\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let id2=points[j].id\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawTanPoint(){\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"red\",\"none\")\r\n        }\r\n    }\r\n\r\n    drawTangentEdges(){\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            if(startpoint.dataindex==25||endpoint.dataindex==25)\r\n                drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"blue\",1)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData.id=i\r\n        }\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-40)+\" \"+(miny-40)+\" \"+(maxx-minx+80)+\" \"+(maxy-miny+80))\r\n\r\n\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        let offsetX = minx-20;\r\n        let offsetY = miny-20;\r\n        let viewWidth = maxx-minx+40;\r\n        let viewHeight = maxy-miny+40\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id=i\r\n            this.pointData[i].cat=this.pointData[i].cat.toString()\r\n            let cats=this.pointData[i].cat.split(\",\")\r\n            let catarray=[]\r\n            if (cats.length>1){\r\n                this.pointData[i].multicat=true\r\n                for (let c=0;c<cats.length;c++){\r\n                    catarray.push(cats[c])\r\n                }\r\n            }\r\n            else{\r\n                this.pointData[i].multicat=false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray=catarray\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n            }\r\n        }\r\n\r\n        // console.log(this.catPointDict)\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\", this.pointData[i].cat)\r\n                    .attr(\"index\", index)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 1)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 1)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    // Phase 1 : Shortest-path graph\r\n    // create the reachability graph for all sets\r\n    // edges are constrained as below:\r\n    // 1. w/2 away from any allocation areas except for the endpoints\r\n    // 2. the edges between the pairs of nodes that are neighbors in the Delauay triangulation\r\n    // 3. the weight of edges = Math.power(|e| + C, t)\r\n\r\n    calDelauayTriangulation(){\r\n        neighbors = {}\r\n        let tmp_pts = []\r\n        let points = this.pointData\r\n        for(let i = 0; i < points.length; i ++){\r\n            tmp_pts.push([points[i].x, points[i].y])\r\n        }\r\n        let triangles = triangulate(tmp_pts)\r\n        // construct dict for delauay triangulation neighbors\r\n        for(let i = 0; i < triangles.length; i ++){\r\n\r\n            let p1 = triangles[i][0]\r\n            let p2 = triangles[i][1]\r\n            let p3 = triangles[i][2]\r\n\r\n            //let tmp_poly = []\r\n            //tmp_poly.push([this.pointData[p1].x, this.pointData[p1].y])\r\n            //tmp_poly.push([this.pointData[p2].x, this.pointData[p2].y])\r\n            //tmp_poly.push([this.pointData[p3].x, this.pointData[p3].y])\r\n            //drawPolygon(tmp_poly, 0, 0, \"red\")\r\n\r\n            //p1 = this.catPointDict[k][p1].id\r\n            //p2 = this.catPointDict[k][p2].id\r\n            //p3 = this.catPointDict[k][p3].id\r\n\r\n\r\n            if(!neighbors.hasOwnProperty(p1)){\r\n                neighbors[p1] = {}\r\n                neighbors[p1][p2] = 1\r\n                neighbors[p1][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p2)){\r\n                neighbors[p2] = {}\r\n                neighbors[p2][p1] = 1\r\n                neighbors[p2][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p3)){\r\n                neighbors[p3] = {}\r\n                neighbors[p3][p1] = 1\r\n                neighbors[p3][p2] = 1\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEdgeConstrains(edge, k){\r\n\r\n\r\n        let startid = edge.startid\r\n        let endid = edge.endid\r\n\r\n        // judge whether the endpoints are neighbors\r\n        let dataindex1 = this.tanGraphPoints[startid].dataindex\r\n        let dataindex2 = this.tanGraphPoints[endid].dataindex\r\n\r\n        if(this.tanGraphPoints[startid].type == \"datapoint\"){\r\n            let cat_Array = this.pointData[dataindex1].catArray\r\n            let flag = false\r\n            for(let c = 0; c < cat_Array.length; c ++){\r\n                if(cat_Array[c] == k){\r\n                    flag = true\r\n                    break\r\n                }\r\n            }\r\n            if(!flag){\r\n                return false\r\n            }\r\n        }\r\n\r\n        if(this.tanGraphPoints[endid].type == \"datapoint\"){\r\n            let cat_Array = this.pointData[dataindex2].catArray\r\n            let flag = false\r\n            for(let c = 0; c < cat_Array.length; c ++){\r\n                if(cat_Array[c] == k){\r\n                    flag = true\r\n                    break\r\n                }\r\n            }\r\n            if(!flag){\r\n                return false\r\n            }\r\n        }\r\n\r\n\r\n        let idx1, idx2\r\n\r\n        if(this.tanGraphPoints[startid].type != \"vi\"){\r\n            idx1 = [dataindex1]\r\n        }\r\n        else{\r\n            idx1 = dataindex1\r\n        }\r\n\r\n        if(this.tanGraphPoints[endid].type != \"vi\"){\r\n            idx2 = [dataindex2]\r\n        }\r\n        else{\r\n            idx2 = dataindex2\r\n        }\r\n\r\n        /*\r\n        let neighborFlag = false\r\n        for(let p = 0; p < idx1.length; p ++){\r\n            let pt1 = idx1[p]\r\n            for(let q = 0; q < idx2.length; q ++){\r\n                let pt2 = idx2[q]\r\n                if(neighbors.hasOwnProperty(pt1)){\r\n                    if(neighbors[pt1].hasOwnProperty(pt2)){\r\n                        neighborFlag = true\r\n                        break\r\n                    }\r\n                }\r\n                if(neighbors.hasOwnProperty(pt2)){\r\n                    if(neighbors[pt2].hasOwnProperty(pt1)){\r\n                        neighborFlag = true\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!neighborFlag){\r\n            //return false\r\n        }\r\n        */\r\n\r\n        let disFlag = true\r\n\r\n        // judge whether the edge is w/2 away from any allocation areas except for the endpoints\r\n        for(let j = 0; j < this.elementPoly.length; j ++){\r\n\r\n            let flagg = false\r\n            for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                if(this.pointData[j].catArray[cur_idx] == k){\r\n                    flagg = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            if(flagg){\r\n\r\n                continue\r\n            }\r\n\r\n            let isSame1 = false\r\n            let isSame2 = false\r\n\r\n            for(let p = 0; p < idx1.length; p ++){\r\n                if(j == idx1[p]){\r\n                    isSame1 = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            for(let q = 0; q < idx2.length; q ++){\r\n                if(j == idx2[q]){\r\n                    isSame2 = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            //if(isSame1 || isSame2){\r\n            //    continue\r\n            //}\r\n\r\n\r\n            let flagg1 = false\r\n            if(isSame1){\r\n                if(this.tanGraphPoints[startid].type == \"vi\"){\r\n                    for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                        if(this.pointData[j].catArray[cur_idx] == k){\r\n                            flagg1 = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    flagg1 = true\r\n                }\r\n            }\r\n\r\n            if(flagg1){\r\n                continue\r\n            }\r\n\r\n            let flagg2 = false\r\n            if(isSame2){\r\n                if(this.tanGraphPoints[endid].type == \"vi\"){\r\n                    for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                        if(this.pointData[j].catArray[cur_idx] == k){\r\n                            flagg2 = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    flagg2 = true\r\n                }\r\n            }\r\n\r\n            if(flagg2){\r\n                continue\r\n            }\r\n\r\n            // first cal the perpendicular from the point to the edge\r\n            let s_pt = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n            let e_pt = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n            let pt = [this.pointData[j].x, this.pointData[j].y]\r\n            let k1\r\n            let k2\r\n            let pt_o\r\n            let withinFlag = false\r\n            if(Math.abs(s_pt[0] - e_pt[0]) < eps){\r\n                k1 = null\r\n                k2 = 0\r\n                // cal intersection point for two lines\r\n                pt_o = [s_pt[0], pt[1]]\r\n                if(pt[1] >= Math.min(s_pt[1], e_pt[1]) && pt[1] <= Math.max(s_pt[1], e_pt[1])){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n            else if(Math.abs(s_pt[1] - e_pt[1]) < eps){\r\n                k1 = 0\r\n                k2 = null\r\n                // cal intersection point for two lines\r\n                pt_o = [pt[0], s_pt[1]]\r\n                if(pt[0] >= Math.min(s_pt[0], e_pt[0]) && pt[0] <= Math.max(s_pt[0], e_pt[0])){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n            else{\r\n                k1 = (e_pt[1] - s_pt[1]) / (e_pt[0] - s_pt[0])\r\n                k2 = (-1.0) / k1\r\n                // cal intersection point for two lines\r\n                let b1 = s_pt[1] - k1 * s_pt[0]\r\n                let b2 = pt[1] - k2 * pt[0]\r\n                let tmpx = (b1 - b2) / (k2 - k1)\r\n                let tmpy = k1 * tmpx + b1\r\n                pt_o = [tmpx, tmpy]\r\n                let tmpt = (tmpx - s_pt[0]) / (e_pt[0] - s_pt[0])\r\n                if(tmpt >= 0 && tmpt <= 1){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n\r\n            // if the intersection point not in the region of edge then continue\r\n            if(!withinFlag){\r\n                let dis1 = calDistance(pt[0], pt[1], s_pt[0], s_pt[1])\r\n                let dis2 = calDistance(pt[0], pt[1], e_pt[0], e_pt[1])\r\n                if(dis1 < dis2){\r\n                    pt_o = [s_pt[0], s_pt[1]]\r\n                }\r\n                else{\r\n                    pt_o = [e_pt[0], e_pt[1]]\r\n                }\r\n            }\r\n\r\n            // else cal the intersection point of the vertical line and the polygon\r\n            let tmp_poly = []\r\n            for(let p = 0; p < this.elementPoly[j].length; p ++){\r\n                tmp_poly.push([this.elementPoly[j][p].x, this.elementPoly[j][p].y])\r\n            }\r\n            let area_poly = ShapeInfo.polygon(tmp_poly)\r\n            let tmpvv = [pt_o[0] - pt[0], pt_o[1] - pt[1]]\r\n            let pt_oo = [pt[0] + 2 * tmpvv[0], pt[1] + 2 * tmpvv[1]]\r\n            let o_line = ShapeInfo.line(pt, pt_oo)\r\n            let intersections = Intersection.intersect(area_poly, o_line)\r\n            let mindis = Number.MAX_VALUE\r\n            let i_pts = intersections.points\r\n\r\n            //console.log(\"intersection points:\")\r\n            //console.log(i_pts)//\r\n\r\n            let hasIntersect = false\r\n\r\n            for(let p = 0; p < i_pts.length; p ++){\r\n                hasIntersect = true\r\n                let tmpdis = calDistance(pt[0], pt[1], i_pts[p].x, i_pts[p].y)\r\n                mindis = Math.min(mindis, tmpdis)\r\n            }\r\n\r\n            if(!hasIntersect){\r\n                disFlag = false\r\n                break\r\n            }\r\n\r\n            let linedis = calDistance(pt[0], pt[1], pt_o[0], pt_o[1]) - mindis - (EdgeWidth / 2) + 2\r\n\r\n            // finally cal the distance from the intersection point to the edge and judge whether the distance > w/2\r\n            if(linedis <= 0){\r\n                disFlag = false\r\n                break\r\n            }\r\n\r\n        }\r\n\r\n        if(!disFlag){\r\n            return false\r\n        }\r\n        else{\r\n            return true\r\n        }\r\n\r\n\r\n    }\r\n\r\n    moveOutEdge(k, i){\r\n\r\n    }\r\n\r\n    createInitGraph(){\r\n\r\n        // first create (pointData, tanPoints) map\r\n\r\n        for(let k in this.catPointDict){\r\n            //this.catPointMap[k] = {}\r\n            this.catInitEdges[k] = []\r\n        }\r\n\r\n        /*\r\n        for(let i = 0; i < this.tanGraphPoints.length; i ++){\r\n\r\n            let dataidx = this.tanGraphPoints[i].dataindex\r\n            let addidx = []\r\n\r\n            if(this.tanGraphPoints[i].type == \"vi\"){\r\n                addidx = dataidx\r\n            }\r\n            else{\r\n                addidx = [dataidx]\r\n            }\r\n\r\n            if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n                this.tanPointMap[addidx[0]] = i\r\n            }\r\n\r\n            for(let j = 0; j < addidx.length ; j ++){\r\n                let idx = addidx[j]\r\n                for (let c = 0; c < this.pointData[idx].catArray.length; c ++){\r\n                    let nowcat = this.pointData[idx].catArray[c]\r\n                    if(!this.catPointMap[nowcat].hasOwnProperty(idx)){\r\n                        this.catPointMap[nowcat][idx] = []\r\n                    }\r\n                    this.catPointMap[nowcat][idx].push(this.tanGraphPoints[i])\r\n                }\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        //let rG = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length)\r\n\r\n\r\n        //this.calDelauayTriangulation()\r\n\r\n        //console.log(neighbors)\r\n        /*\r\n        // constrain the edges to delauay triangulation and w/2 far away from allocation areas\r\n        for(let i = this.tanGraphEdges.length - 1; i >= 0; i --){\r\n            let e = this.tanGraphEdges[i]\r\n            if(this.calEdgeConstrains(e)){\r\n                //console.log(\"yes\")\r\n                // add edge to the rG\r\n                let startid = e.startid\r\n                let endid = e.endid\r\n                let dis = calDistance(\r\n                    this.tanGraphPoints[startid].x,\r\n                    this.tanGraphPoints[startid].y,\r\n                    this.tanGraphPoints[endid].x,\r\n                    this.tanGraphPoints[endid].y\r\n                )\r\n                let edge_weight = Math.pow(dis + parameter_C, parameter_t)\r\n                rG.addEdge(new jsgraphs.Edge(startid, endid, edge_weight));\r\n                rG.addEdge(new jsgraphs.Edge(endid, startid, edge_weight));\r\n            }\r\n        }\r\n        */\r\n        //console.log(\"rG\")\r\n        //console.log(rG)\r\n        //return\r\n\r\n        //console.log(\"catPointMap!\")\r\n        //console.log(this.catPointMap)\r\n\r\n        // create the edges array for each cat\r\n        for(let k in this.catPointMap){\r\n\r\n            this.rG[k] = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length)\r\n\r\n            for(let i = this.rGEdges[k].length - 1; i >= 0; i --){\r\n                let e = this.rGEdges[k][i]\r\n                if(this.calEdgeConstrains(e, k)){\r\n                    //console.log(\"yes\")\r\n                    // add edge to the rG\r\n                    let startid = e.startid\r\n                    let endid = e.endid\r\n                    let dis = calDistance(\r\n                        this.tanGraphPoints[startid].x,\r\n                        this.tanGraphPoints[startid].y,\r\n                        this.tanGraphPoints[endid].x,\r\n                        this.tanGraphPoints[endid].y\r\n                    )\r\n                    //let edge_weight = Math.pow(dis + parameter_C, parameter_t)\r\n                    let edge_weight = dis\r\n                    //let edge_weight = dis\r\n                    this.rG[k].addEdge(new jsgraphs.Edge(startid, endid, edge_weight));\r\n                    this.rG[k].addEdge(new jsgraphs.Edge(endid, startid, edge_weight));\r\n                }\r\n            }\r\n\r\n\r\n            let node_array = []\r\n\r\n            for(let node in this.catPointMap[k]){\r\n                node_array.push(node)\r\n            }\r\n\r\n            //console.log(\"node_array!!!\")\r\n            //console.log(node_array)\r\n\r\n            console.log(\"info!!\")\r\n            console.log(k)\r\n            console.log(node_array)\r\n\r\n            for(let i = 0; i < node_array.length; i ++){\r\n\r\n                //let nodes1 = this.catPointMap[k][node_array[i]]\r\n                //console.log(\"nodes1!!!\")\r\n                //console.log(nodes1)\r\n\r\n                let nodeid1 = this.tanPointMap[node_array[i]]\r\n                let dijkstra = new jsgraphs.Dijkstra(this.rG[k], nodeid1)\r\n\r\n                for(let j = i + 1; j < node_array.length; j ++){\r\n\r\n                    //if(i == j){\r\n                    //    continue\r\n                    //}\r\n\r\n                    let nodeid2 = this.tanPointMap[node_array[j]]\r\n\r\n                    if(dijkstra.hasPathTo(nodeid2)){\r\n                        let path = dijkstra.pathTo(nodeid2)\r\n                        let tmp_w = 0\r\n                        for(let eid = 0; eid < path.length; eid ++){\r\n                            tmp_w += path[eid].weight\r\n                        }\r\n                        //tmp_w = Math.pow(tmp_w + parameter_C, parameter_t)\r\n                        let tmp_e = {\r\n                            cat:k,\r\n                            start:parseInt(node_array[i]),\r\n                            end:parseInt(node_array[j]),\r\n                            edges:path,\r\n                            weight: Math.pow(tmp_w + parameter_C, parameter_t)\r\n                        }\r\n                        this.catInitEdges[k].push(tmp_e)\r\n                    }\r\n\r\n                    //let nodes2 = this.catPointMap[k][node_array[j]]\r\n                    /*\r\n                    for(let p = 0; p < nodes1.length; p ++){\r\n                        if(this.tanGraphPoints[nodes1[p].id].type != \"datapoint\"){\r\n                            continue\r\n                        }\r\n                        let dijkstra = new jsgraphs.Dijkstra(this.rG[k], nodes1[p].id);\r\n                        for(let q = 0; q < nodes2.length; q ++){\r\n                            if(this.tanGraphPoints[nodes2[q].id].type != \"datapoint\"){\r\n                                continue\r\n                            }\r\n                            if(dijkstra.hasPathTo(nodes2[q].id)){\r\n                                let path = dijkstra.pathTo(nodes2[q].id)\r\n                                let tmp_w = 0\r\n                                for(let eid = 0; eid < path.length; eid ++){\r\n                                    tmp_w += path[eid].weight\r\n                                }\r\n                                //tmp_w = Math.pow(tmp_w + parameter_C, parameter_t)\r\n                                let tmp_e = {\r\n                                    cat:k,\r\n                                    start:parseInt(node_array[i]),\r\n                                    end:parseInt(node_array[j]),\r\n                                    edges:path,\r\n                                    weight:tmp_w\r\n                                }\r\n                                this.catInitEdges[k].push(tmp_e)\r\n                            }\r\n                        }\r\n\r\n                     */\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n        /*\r\n        // add cat attribute for tan points\r\n        for(let i = 0; i < this.tanGraphPoints.length ; i ++){\r\n            let dataindex = this.tanGraphPoints[i].dataindex\r\n            if(this.tanGraphPoints[i].type == \"vi\"){\r\n                if(this.pointData[dataindex[0]].cat != this.pointData[dataindex[1]].cat){\r\n                    this.tanGraphPoints[i].cat = [this.pointData[dataindex[0]].cat, this.pointData[dataindex[1]].cat]\r\n                }\r\n                else{\r\n                    this.tanGraphPoints[i].cat = [this.pointData[dataindex[0]].cat]\r\n                }\r\n            }\r\n            else{\r\n                this.tanGraphPoints[i].cat = [this.pointData[dataindex].cat]\r\n            }\r\n        }\r\n\r\n\r\n        // split tan edges by cat\r\n        let edgeDict = {}\r\n\r\n        for(let i = 0; i < this.tanGraphEdges.length; i ++){\r\n            let startid = this.tanGraphEdges[i].startid\r\n            let endid = this.tanGraphEdges[i].endid\r\n            let cat1 = this.tanGraphPoints[startid].cat\r\n            let cat2 = this.tanGraphPoints[endid].cat\r\n            let dis = calDistance(\r\n                this.tanGraphPoints[startid].x,\r\n                this.tanGraphPoints[startid].y,\r\n                this.tanGraphPoints[endid].x,\r\n                this.tanGraphPoints[endid].y\r\n            )\r\n            this.tanGraphEdges[i].weight = Math.pow(dis + parameter_C, parameter_t)\r\n            let flag = false\r\n            let catidx = {}\r\n            for(let j = 0; j < cat1.length; j ++){\r\n                let idx1 = cat1[j]\r\n                for(let k = 0; k < cat2.length; k ++){\r\n                    if(idx1 == cat2[k]){\r\n                        flag = true\r\n                        catidx[idx1] = 1\r\n                    }\r\n                }\r\n            }\r\n            if(flag){\r\n                for(let key_cat in catidx){\r\n                    if(!edgeDict.hasOwnProperty(key_cat)){\r\n                        edgeDict[key_cat] = []\r\n                    }\r\n                    edgeDict[key_cat].push(this.tanGraphEdges[i])\r\n                }\r\n            }\r\n        }\r\n\r\n        //console.log(\"createInitGraph\")\r\n        //console.log(this.catPointDict)\r\n\r\n\r\n        //this.initGraph[k] = new jsgraphs.WeightedDiGraph(points.length)\r\n\r\n\r\n        // cal delauay triangulation\r\n        let tmp_pts = []\r\n        let points = this.pointData\r\n        for(let i = 0; i < points.length; i ++){\r\n            tmp_pts.push([points[i].x, points[i].y])\r\n        }\r\n        let triangles = triangulate(tmp_pts)\r\n        let neighbors = {}\r\n        // construct dict for delauay triangulation neighbors\r\n        for(let i = 0; i < triangles.length; i ++){\r\n\r\n            let p1 = triangles[i][0]\r\n            let p2 = triangles[i][1]\r\n            let p3 = triangles[i][2]\r\n\r\n            let tmp_poly = []\r\n            tmp_poly.push([this.pointData[p1].x, this.pointData[p1].y])\r\n            tmp_poly.push([this.pointData[p2].x, this.pointData[p2].y])\r\n            tmp_poly.push([this.pointData[p3].x, this.pointData[p3].y])\r\n            drawPolygon(tmp_poly, 0, 0, \"red\")\r\n\r\n            //p1 = this.catPointDict[k][p1].id\r\n            //p2 = this.catPointDict[k][p2].id\r\n            //p3 = this.catPointDict[k][p3].id\r\n\r\n\r\n            if(!neighbors.hasOwnProperty(p1)){\r\n                neighbors[p1] = {}\r\n                neighbors[p1][p2] = 1\r\n                neighbors[p1][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p2)){\r\n                neighbors[p2] = {}\r\n                neighbors[p2][p1] = 1\r\n                neighbors[p2][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p3)){\r\n                neighbors[p3] = {}\r\n                neighbors[p3][p1] = 1\r\n                neighbors[p3][p2] = 1\r\n            }\r\n        }\r\n\r\n\r\n        for(var k in this.catPointDict){\r\n            //let points = this.catPointDict[k]\r\n\r\n            for(let i = 0; i < edgeDict[k].length; i ++){\r\n\r\n                let startid = edgeDict[k][i].startid\r\n                let endid = edgeDict[k][i].endid\r\n\r\n                // judge whether the endpoints are neighbors\r\n                let dataindex1 = this.tanGraphPoints[startid].dataindex\r\n                let dataindex2 = this.tanGraphPoints[endid].dataindex\r\n\r\n                let idx1, idx2\r\n\r\n                if(this.tanGraphPoints[startid].type != \"vi\"){\r\n                    idx1 = [dataindex1]\r\n                }\r\n                else{\r\n                    idx1 = dataindex1\r\n                }\r\n\r\n                if(this.tanGraphPoints[endid].type != \"vi\"){\r\n                    idx2 = [dataindex2]\r\n                }\r\n                else{\r\n                    idx2 = dataindex2\r\n                }\r\n\r\n                let neighborFlag = false\r\n                for(let p = 0; p < idx1.length; p ++){\r\n                    let pt1 = idx1[p]\r\n                    for(let q = 0; q < idx2.length; q ++){\r\n                        let pt2 = idx2[q]\r\n                        if(neighbors.hasOwnProperty(pt1)){\r\n                            if(neighbors[pt1].hasOwnProperty(pt2)){\r\n                                neighborFlag = true\r\n                                break\r\n                            }\r\n                        }\r\n                        if(neighbors.hasOwnProperty(pt2)){\r\n                            if(neighbors[pt2].hasOwnProperty(pt1)){\r\n                                neighborFlag = true\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(!neighborFlag){\r\n                    continue\r\n                }\r\n\r\n                let disFlag = true\r\n\r\n                // judge whether the edge is w/2 away from any allocation areas except for the endpoints\r\n                for(let j = 0; j < this.elementPoly.length; j ++){\r\n\r\n                    let isSame = false\r\n\r\n                    for(let p = 0; p < idx1.length; p ++){\r\n                        if(j == idx1[p]){\r\n                            isSame = true\r\n                            break\r\n                        }\r\n                    }\r\n                    for(let q = 0; q < idx2.length; q ++){\r\n                        if(j == idx2[q]){\r\n                            isSame = true\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    if(isSame){\r\n                        continue\r\n                    }\r\n\r\n                    // first cal the perpendicular from the point to the edge\r\n                    let s_pt = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                    let e_pt = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                    let pt = [this.pointData[j].x, this.pointData[j].y]\r\n                    let k1\r\n                    let k2\r\n                    let pt_o\r\n                    let withinFlag = false\r\n                    if(Math.abs(s_pt[0] - e_pt[0]) < eps){\r\n                        k1 = null\r\n                        k2 = 0\r\n                        // cal intersection point for two lines\r\n                        pt_o = [s_pt[0], pt[1]]\r\n                        if(pt[1] >= Math.min(s_pt[1], e_pt[1]) && pt[1] <= Math.max(s_pt[1], e_pt[1])){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n                    else if(Math.abs(s_pt[1] - e_pt[1]) < eps){\r\n                        k1 = 0\r\n                        k2 = null\r\n                        // cal intersection point for two lines\r\n                        pt_o = [pt[0], s_pt[1]]\r\n                        if(pt[0] >= Math.min(s_pt[0], e_pt[0]) && pt[0] <= Math.max(s_pt[0], e_pt[0])){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n                    else{\r\n                        k1 = (e_pt[1] - s_pt[1]) / (e_pt[0] - s_pt[0])\r\n                        k2 = (-1.0) / k1\r\n                        // cal intersection point for two lines\r\n                        let b1 = s_pt[1] - k1 * s_pt[0]\r\n                        let b2 = pt[1] - k2 * pt[0]\r\n                        let tmpx = (b1 - b2) / (k2 - k1)\r\n                        let tmpy = k1 * tmpx + b1\r\n                        pt_o = [tmpx, tmpy]\r\n                        let tmpt = (tmpx - s_pt[0]) / (e_pt[0] - s_pt[0])\r\n                        if(tmpt >= 0 && tmpt <= 1){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n\r\n                    // if the intersection point not in the region of edge then continue\r\n                    if(!withinFlag){\r\n                        continue\r\n                    }\r\n\r\n                    // else cal the intersection point of the vertical line and the polygon\r\n                    let tmp_poly = []\r\n                    for(let p = 0; p < this.elementPoly[j].length; p ++){\r\n                        tmp_poly.push([this.elementPoly[j][p].x, this.elementPoly[j][p].y])\r\n                    }\r\n                    let area_poly = ShapeInfo.polygon(tmp_poly)\r\n                    let o_line = ShapeInfo.line(pt, pt_o)\r\n                    let intersections = Intersection.intersect(area_poly, o_line);\r\n                    let mindis = Number.MAX_VALUE\r\n                    let i_pts = intersections.points\r\n\r\n                    //console.log(\"intersection points:\")\r\n                    //console.log(i_pts)//\r\n\r\n                    for(let p = 0; p < i_pts.length; p ++){\r\n                        let tmpdis = calDistance(pt_o[0], pt_o[1], i_pts[p].x, i_pts[p].y)\r\n                        mindis = Math.min(mindis, tmpdis)\r\n                    }\r\n\r\n                    // finally cal the distance from the intersection point to the edge and judge whether the distance > w/2\r\n                    if(mindis < EdgeWidth/2){\r\n                        disFlag = false\r\n                        break\r\n                    }\r\n\r\n                }\r\n\r\n                if(!disFlag){\r\n                    //continue\r\n                }\r\n\r\n                // add the edge to the reachability graph\r\n                if(!this.initEdges.hasOwnProperty(k)){\r\n                    this.initEdges[k] = []\r\n                }\r\n\r\n                this.initEdges[k].push(edgeDict[k][i])\r\n\r\n                let start_points = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                let end_points = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                //drawLine(start_points, end_points, \"black\", 2)\r\n\r\n            }\r\n\r\n        }\r\n\r\n        console.log(this.initEdges)\r\n\r\n         */\r\n\r\n    // create SPG according to the Algorithm 2\r\n    createSPG(){\r\n\r\n\r\n\r\n        /*\r\n        for(let k in this.catInitEdges){\r\n            this.catInitEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n            let edges = this.catInitEdges[k]\r\n            for(let i = 0; i < edges.length; i ++){\r\n                console.log(\"draw\")\r\n                let st = edges[i].start\r\n                let en = edges[i].end\r\n                let w = edges[i].weight\r\n                let edge_path = edges[i].edges\r\n                let tmp_color = colors[parseInt(edges[i].cat)]\r\n                for(let p = 0; p < edge_path.length; p ++){\r\n                    let u = edge_path[p].from()\r\n                    let v = edge_path[p].to()\r\n                    let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                    let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n                if(edge_path.length == 0){\r\n                    let start_points = [this.tanGraphPoints[st].x, this.tanGraphPoints[st].y]\r\n                    let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n                else{\r\n                    let start_points = [this.tanGraphPoints[edge_path[edge_path.length - 1].to()].x, this.tanGraphPoints[edge_path[edge_path.length - 1].to()].y]\r\n                    let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        console.log(\"catInitEdges!!!\")\r\n        console.log(this.catInitEdges)\r\n\r\n\r\n        for(let k in this.catInitEdges){\r\n            this.catInitEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n            let edges = this.catInitEdges[k]\r\n            this.SPG[k] = new jsgraphs.WeightedDiGraph(this.pointData.length)\r\n            for(let i = 0; i < edges.length; i ++){\r\n                let st = edges[i].start\r\n                let en = edges[i].end\r\n                let w = edges[i].weight\r\n                let e = new jsgraphs.Edge(st, en, w)\r\n                e.label = i\r\n                e.flag = false\r\n                let e1 = new jsgraphs.Edge(en, st, w)\r\n                e1.label = i\r\n                e1.flag = true\r\n                let dijkstra = new jsgraphs.Dijkstra(this.SPG[k], st)\r\n                let drawFlag = false\r\n                if(dijkstra.hasPathTo(en)){\r\n                    let path = dijkstra.pathTo(en)\r\n                    let path_weight = 0\r\n                    for(let p = 0; p < path.length; p ++){\r\n                        path_weight += path[p].weight\r\n                    }\r\n                    if(path_weight >= w){\r\n                        //console.log(\"(\" + path_weight + \", \" + w + \")\")\r\n                        drawFlag = true\r\n                        this.SPG[k].addEdge(e)\r\n                        this.SPG[k].addEdge(e1)\r\n                    }\r\n                }\r\n                else{\r\n                    drawFlag = true\r\n                    this.SPG[k].addEdge(e)\r\n                    this.SPG[k].addEdge(e1)\r\n                }\r\n\r\n                if(drawFlag){\r\n                    if(!this.SPGEdges.hasOwnProperty(k)){\r\n                        this.SPGEdges[k] = []\r\n                    }\r\n                    this.SPGEdges[k].push(i)\r\n                    this.drawEdgePath(k, i, colors[parseInt(k)], 1)\r\n                    //console.log(edges[i])\r\n                    /*\r\n                    let edge_path = edges[i].edges\r\n                    let tmp_color = colors[parseInt(edges[i].cat)]\r\n                    for(let p = 0; p < edge_path.length; p ++){\r\n                        let u = edge_path[p].from()\r\n                        let v = edge_path[p].to()\r\n                        let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                        let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n                    if(edge_path.length == 0){\r\n                        let start_points = [this.tanGraphPoints[st].x, this.tanGraphPoints[st].y]\r\n                        let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n                    else{\r\n                        let start_points = [this.tanGraphPoints[edge_path[edge_path.length - 1].to()].x, this.tanGraphPoints[edge_path[edge_path.length - 1].to()].y]\r\n                        let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n\r\n                     */\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /*\r\n        //console.log(this.pointData)\r\n        for(var k in this.initEdges){\r\n\r\n            // increasing order\r\n            this.initEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n\r\n            //console.log(this.initEdges[k])\r\n            this.SPG[k] = new jsgraphs.WeightedDiGraph(this.pointData.length)\r\n            this.SPGEdges[k] = []\r\n\r\n            for(let i = 0; i < this.initEdges[k].length; i ++){\r\n                let startid = this.initEdges[k][i].startid\r\n                let endid = this.initEdges[k][i].endid\r\n                let weight = this.initEdges[k][i].weight\r\n                let s_ptid\r\n                let e_ptid\r\n\r\n                if(this.tanGraphPoints[startid].type == \"vi\"){\r\n                    s_ptid = this.tanGraphPoints[startid].dataindex\r\n                }else{\r\n                    s_ptid = [this.tanGraphPoints[startid].dataindex]\r\n                }\r\n\r\n                if(this.tanGraphPoints[endid].type == \"vi\"){\r\n                    e_ptid = this.tanGraphPoints[endid].dataindex\r\n                }else{\r\n                    e_ptid = [this.tanGraphPoints[endid].dataindex]\r\n                }\r\n\r\n                for(let j = s_ptid.length - 1; j >= 0; j --){\r\n                    if(this.pointData[s_ptid[j]].cat != k){\r\n                        s_ptid.splice(j, 1)\r\n                    }\r\n                }\r\n\r\n                for(let j = e_ptid.length - 1; j >= 0; j --){\r\n                    if(this.pointData[e_ptid[j]].cat != k){\r\n                        e_ptid.splice(j, 1)\r\n                    }\r\n                }\r\n\r\n                if(s_ptid.length == 0 || e_ptid.length == 0){\r\n                    continue\r\n                }\r\n\r\n                for(let j = 0 ; j < s_ptid.length ; j ++){\r\n\r\n                    let startidx = s_ptid[j]\r\n                    var dijkstra = new jsgraphs.Dijkstra(this.SPG[k], startidx);\r\n                    let hasLink = false\r\n                    let adjLink = false\r\n                    //let pathWeight = Number.MAX_VALUE\r\n\r\n                    for(let p = 0; p < e_ptid.length; p ++){\r\n\r\n                        let endidx = e_ptid[p]\r\n                        let adjList = this.SPG[k].adjList\r\n\r\n                        //for(let q = 0; q < adjList[startidx].length; q ++){\r\n                        //    let e = adjList[startidx][q]\r\n                        //    if(e.w == endidx){\r\n                        //        adjLink = true\r\n                        //    }\r\n                        //}\r\n//\r\n                        //if(adjLink){\r\n                        //    continue\r\n                        //}\r\n\r\n                        let tmp_w = 0\r\n                        if(dijkstra.hasPathTo(endidx)){\r\n                            hasLink = true\r\n                            let path = dijkstra.pathTo(e_ptid[p])\r\n                            for(let q = 0; q < path.length; q ++){\r\n                                let e = path[q]\r\n                                tmp_w += e.weight\r\n                            }\r\n                        }\r\n\r\n                        if((!hasLink) || (hasLink && tmp_w >= weight)){\r\n                            // add edge to SPG\r\n                            this.SPG[k].addEdge(new jsgraphs.Edge(startidx, endidx, weight))\r\n                            this.SPG[k].addEdge(new jsgraphs.Edge(endidx, startidx, weight))\r\n                            this.SPGEdges[k].push(this.initEdges[k][i])\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n        //console.log(this.SPG)\r\n        //console.log(this.SPGEdges)\r\n\r\n        for(var k in this.SPGEdges){\r\n            for(let i = 0; i < this.SPGEdges[k].length; i ++){\r\n                let startid = this.SPGEdges[k][i].startid\r\n                let endid = this.SPGEdges[k][i].endid\r\n                let start_points = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                let end_points = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                drawLine(start_points, end_points, \"black\", 3)\r\n            }\r\n        }\r\n\r\n         */\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calCrossEdges(){\r\n        console.log(this.SPGEdges)\r\n        var Edge_Array = {}\r\n        for(let k in this.SPGEdges){\r\n            Edge_Array[k] = []\r\n            for(let i = 0; i < this.SPGEdges[k].length; i ++){\r\n                let idx = this.SPGEdges[k][i]\r\n                let edge_path = this.catInitEdges[k][idx].edges\r\n                let tmp_e = []\r\n                for(let p = 0; p < edge_path.length; p ++){\r\n                    let tmp_line = {}\r\n                    let u = edge_path[p].v\r\n                    let v = edge_path[p].w\r\n                    tmp_line.start = {x: this.tanGraphPoints[u].x,\r\n                                      y:this.tanGraphPoints[u].y}\r\n                    tmp_line.end = {x:this.tanGraphPoints[v].x,\r\n                                    y:this.tanGraphPoints[v].y}\r\n                    tmp_e.push(tmp_line)\r\n                }\r\n                Edge_Array[k].push(tmp_e)\r\n            }\r\n        }\r\n\r\n        let crossnum = 0\r\n        for(let k1 in Edge_Array){\r\n\r\n            for(let i = 0; i < Edge_Array[k1].length; i ++){\r\n                let e1 = Edge_Array[k1][i]\r\n                for(let k2 in Edge_Array){\r\n                    if(k1 == k2){\r\n                        continue\r\n                    }\r\n                    for(let j = 0; j < Edge_Array[k2].length; j ++){\r\n                        let e2 = Edge_Array[k2][j]\r\n                        let flag = false\r\n                        for(let p = 0; p < e1.length; p ++){\r\n                            let eS1 = e1[p].start\r\n                            let eE1 = e1[p].end\r\n                            for(let q = 0; q < e2.length; q ++){\r\n                                let eS2 = e2[q].start\r\n                                let eE2 = e2[q].end\r\n                                if(this.checkEdgeCrossing(eS1, eE1, eS2, eE2)){\r\n                                    crossnum ++\r\n                                    flag = true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(flag){\r\n\r\n                                for(let q = 0; q < e2.length; q ++){\r\n                                    let eS2 = e2[q].start\r\n                                    let eE2 = e2[q].end\r\n                                    let startpoints = [eS2.x, eS2.y]\r\n                                    let endpoints = [eE2.x, eE2.y]\r\n                                    drawLine(startpoints, endpoints, \"red\", 2)\r\n                                }\r\n\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        crossnum /= 2\r\n\r\n        console.log(\"Points Num : \")\r\n        console.log(this.pointData.length)\r\n        console.log(\"Cross Num : \")\r\n        console.log(crossnum)\r\n\r\n    }\r\n\r\n    //Phase 2 : Fillable faces\r\n    // find all faces in SPG\r\n\r\n    drawEdgePath(k, i, color, width){\r\n        let edge_path = this.catInitEdges[k][i].edges\r\n        for(let p = 0; p < edge_path.length; p ++){\r\n            let u = edge_path[p].v\r\n            let v = edge_path[p].w\r\n            let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n            let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n            drawLine(start_points, end_points, color, width)\r\n        }\r\n    }\r\n\r\n    judgeClockWise(pointIdx){\r\n\r\n        //counterclockwise return true\r\n        //clockwise return false\r\n        let p1 = [this.pointData[pointIdx[0]].x, this.pointData[pointIdx[0]].y]\r\n        let p2 = [this.pointData[pointIdx[1]].x, this.pointData[pointIdx[1]].y]\r\n        let p3 = [this.pointData[pointIdx[2]].x, this.pointData[pointIdx[2]].y]\r\n        let res = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\r\n        if(res > 0){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n    }\r\n\r\n    dfs(s, k){\r\n        this.visited[s] = 1\r\n        for(let i = 0; i < this.SPG[k].adjList[s].length; i ++){\r\n            let e = this.SPG[k].adjList[s][i]\r\n            let to = e.w\r\n            if(this.visited[to] == 0){\r\n                this.fa[to] = s\r\n                this.dfs(to, k)\r\n            }\r\n            else if(this.visited[to] == 1 && to != this.fa[s]){\r\n                let tmp = s\r\n                let tmp_circle = []\r\n                tmp_circle.push(to)\r\n                while(tmp != to){\r\n                    tmp_circle.push(tmp)\r\n                    tmp = this.fa[tmp]\r\n                }\r\n                //tmp_circle.push(tmp)\r\n                if(tmp_circle.length < 3){\r\n                    continue\r\n                }\r\n                if(!this.circles.hasOwnProperty(k)){\r\n                    this.circles[k] = []\r\n                }\r\n                if(!this.judgeClockWise(tmp_circle)){\r\n                    tmp_circle.reverse()\r\n                }\r\n                this.circles[k].push(tmp_circle)\r\n                this.circles[k][this.circles[k].length - 1].delflag = false\r\n            }\r\n        }\r\n        this.visited[s] = 2\r\n    }\r\n\r\n    findAllCircles(){\r\n\r\n        console.log(\"SPG\")\r\n        console.log(this.SPG)\r\n\r\n        for(let k in this.SPG){\r\n            for(let i = 0; i < this.SPG[k].V; i ++){\r\n                this.visited = []\r\n                this.fa = []\r\n                this.visited = new Array(this.SPG[k].V).fill(0)\r\n                this.fa = new Array(this.SPG[k].V).fill(-1)\r\n                this.dfs(i, k)\r\n            }\r\n        }\r\n\r\n        //console.log(this.circles)\r\n\r\n        //for(let i = 0; i < this.circles.length; i ++){\r\n        //    for(let j = 0; j < this.circles[i].length ; j ++){\r\n        //        let id1 = this.circles[i][j]\r\n        //        let id2 = this.circles[i][(j + 1) % this.circles[i].length]\r\n        //        let startpoint = [this.pointData[id1].x, this.pointData[id1].y]\r\n        //        let endpoint = [this.pointData[id2].x, this.pointData[id2].y]\r\n        //        drawLine(startpoint, endpoint, \"red\", 3)\r\n        //    }\r\n        //}\r\n\r\n    }\r\n\r\n    // remove same faces\r\n    findPolygons(){\r\n\r\n        this.polygons = {}\r\n\r\n\r\n        // remove same faces\r\n        for(let k in this.circles){\r\n\r\n            for(let i = 0; i < this.circles[k].length; i ++){\r\n\r\n                if(this.circles[k][i].delflag){\r\n                    continue\r\n                }\r\n\r\n                let head1 = this.circles[k][i][0]\r\n                let len1 = this.circles[k][i].length\r\n\r\n                for(let j = i + 1; j < this.circles[k].length; j ++){\r\n                    let len2 = this.circles[k][j].length\r\n                    let idx2 = -1\r\n                    if(len1 != len2){\r\n                        continue\r\n                    }\r\n                    for(let p = 0; p < len2; p ++){\r\n                        if(this.circles[k][j][p] == head1){\r\n                            idx2 = p\r\n                        }\r\n                    }\r\n                    if(idx2 == -1){\r\n                        continue\r\n                    }\r\n\r\n                    let sameflag = true\r\n\r\n                    for(let cnt = 0; cnt < len2; cnt ++){\r\n                        let id1 = cnt\r\n                        let id2 = (idx2 + cnt) % len2\r\n                        if(this.circles[k][i][id1] != this.circles[k][j][id2]){\r\n                            sameflag = false\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    if(sameflag){\r\n                        this.circles[k][j].delflag = true\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            for(let i = 0; i < this.circles[k].length; i ++){\r\n\r\n                if(this.circles[k][i].delflag){\r\n                    continue\r\n                }\r\n\r\n                if(!this.polygons.hasOwnProperty(k)){\r\n                    this.polygons[k] = []\r\n                }\r\n\r\n                this.polygons[k].push(this.circles[k][i])\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        //for(let k in this.catPointDict){\r\n        //    this.polygons[k] = []\r\n        //}\r\n        //this.polygons[\"0\"].push([12,10,9])\r\n        //this.polygons[\"0\"].push([26,27,28,32,33])\r\n        //this.polygons[\"0\"].push([29,31,30])\r\n//\r\n        //this.polygons[\"1\"].push([38,41,42,36])\r\n//\r\n        //this.polygons[\"2\"].push([59,61,60])\r\n        //this.polygons[\"2\"].push([66,68,69])\r\n        //this.polygons[\"2\"].push([90,64,65,73])\r\n//\r\n        //for(let k in this.polygons){\r\n        //    for(let i = 0; i < this.polygons[k].length; i ++){\r\n        //        this.polygons[k][i].fillFlag = true\r\n        //    }\r\n        //}\r\n\r\n        //console.log(\"circles\")\r\n        //console.log(this.circles)\r\n        //console.log(\"polygons\")\r\n        //console.log(this.polygons)\r\n\r\n        /*\r\n        for(let k in this.polygons){\r\n            for(let i = 0; i < this.polygons[k].length; i ++){\r\n                for(let j = 0; j < this.polygons[k][i].length; j ++){\r\n                    //console.log(this.polygons[k][i][j])\r\n                    let id1 = this.polygons[k][i][j]\r\n                    let id2 = this.polygons[k][i][(j + 1) % this.polygons[k][i].length]\r\n                    let adjList = this.SPG[k].adjList\r\n                    for(let p = 0; p < adjList[id1].length; p ++){\r\n                        let e = adjList[id1][p]\r\n                        if(e.w == id2){\r\n                            //this.drawEdgePath(k, e.label, \"red\", 3)\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    //console.log(\"(\" + id1 + \", \" + id2 + \")\")\r\n                    //let startpoint = [this.pointData[id1].x, this.pointData[id1].y]\r\n                    //let endpoint = [this.pointData[id2].x, this.pointData[id2].y]\r\n                    //drawLine(startpoint, endpoint, \"red\", 3)\r\n                }\r\n            }\r\n        }\r\n        */\r\n    }\r\n\r\n    // judge whether a given face can be filled\r\n    judgePolygons(){\r\n\r\n        for(let k in this.polygons){\r\n            for(let i = 0; i < this.polygons[k].length; i ++){\r\n                // cal nodes_f\r\n                this.polygons[k][i].nodes_f = this.polygons[k][i].length\r\n                // cal area\r\n                let p_pts = []\r\n                for(let j = 0; j < this.polygons[k][i].length; j ++){\r\n\r\n                    let id1 = this.polygons[k][i][j]\r\n                    let id2 = this.polygons[k][i][(j + 1) % this.polygons[k][i].length]\r\n\r\n                    let adjList = this.SPG[k].adjList\r\n\r\n                    for(let pp = 0; pp < adjList[id1].length; pp ++){\r\n                        let e = adjList[id1][pp]\r\n                        if(e.w == id2){\r\n                            let edge_path = this.catInitEdges[k][e.label].edges\r\n                            let tmp_pts = []\r\n                            for(let ppp = 0; ppp < edge_path.length; ppp ++){\r\n                                let u = edge_path[ppp].v\r\n                                let v = edge_path[ppp].w\r\n                                tmp_pts.push([this.tanGraphPoints[u].x, this.tanGraphPoints[u].y])\r\n                                tmp_pts.push([this.tanGraphPoints[v].x, this.tanGraphPoints[v].y])\r\n                            }\r\n                            if(e.flag){\r\n                                for(let tid = tmp_pts.length - 1; tid >= 0; tid --){\r\n                                    p_pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                }\r\n                            }\r\n                            else{\r\n                                for(let tid = 0; tid < tmp_pts.length; tid ++){\r\n                                    p_pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                }\r\n                            }\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                }\r\n                //console.log(\"p_pts!\")\r\n                //console.log(p_pts)\r\n                this.polygons[k][i].area_f = Math.abs(AreaCal(p_pts))\r\n                this.polygons[k][i].fillFlag = false\r\n                this.polygons[k][i].PolygonInfo = ShapeInfo.polygon(p_pts)\r\n            }\r\n        }\r\n        let Set_Order = []\r\n        for(let k in this.catPointDict){\r\n            let tmp = {}\r\n            tmp.num = this.catPointDict[k].length\r\n            tmp.cat = k\r\n            Set_Order.push(tmp)\r\n        }\r\n        Set_Order.sort(function (a, b){\r\n            return a.num - b.num\r\n        })\r\n        for(let i = Set_Order.length - 1; i >= 0; i --){\r\n            let k = Set_Order[i].cat\r\n            if(!this.polygons.hasOwnProperty(k)){\r\n                continue\r\n            }\r\n            let outer_set = {}\r\n            for(let N = 0; N < this.pointData.length; N ++){\r\n                outer_set[N] = 1\r\n            }\r\n            for(let M = 0; M < this.catPointDict[k].length; M ++){\r\n                let cur_id = this.catPointDict[k][M].id\r\n                if(outer_set.hasOwnProperty(cur_id)){\r\n                    delete outer_set[cur_id]\r\n                }\r\n            }\r\n            for(let p = 0; p < this.polygons[k].length; p ++){\r\n                // Rule 1\r\n                let rule1 = false\r\n                let rule1_res = this.polygons[k][p].area_f / ( 1 + this.polygons[k][p].nodes_f)\r\n                if(rule1_res < parameter_A){\r\n                    rule1 = true\r\n                }\r\n                if(!rule1){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule1!\")\r\n                // Rule 2\r\n                let rule2 = true\r\n                for(let idd in outer_set){\r\n                    let tmp_ppt = [this.pointData[parseInt(idd)].x, this.pointData[parseInt(idd)].y]\r\n                    console.log(\"Polygon Info\")\r\n                    console.log(this.polygons[k][p].PolygonInfo.args[0])\r\n                    if(IntersectionQuery.pointInPolygon(tmp_ppt, this.polygons[k][p].PolygonInfo.args[0])){\r\n                        rule2 = false\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule2){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule2!\")\r\n                // Rule 3\r\n                let rule3 = true\r\n                let cur_polygon = this.polygons[k][p].PolygonInfo\r\n                for(let j = Set_Order.length - 1; j > i; j --){\r\n                    let n_k = Set_Order[j].cat\r\n                    let n_adj = this.SPG[n_k].adjList\r\n                    for(let m = 0; m < n_adj.length; m ++){\r\n                        for(let n = 0; n < n_adj[m].length; n ++){\r\n                            let cur_e = this.catInitEdges[n_k][n_adj[m][n].label].edges\r\n                            for(let a = 0; a < cur_e.length; a ++){\r\n                                let u = cur_e[a].v\r\n                                let v = cur_e[a].w\r\n                                let startpoint = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                                let endpoint = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                                let line = ShapeInfo.line(startpoint, endpoint)\r\n                                let pts = Intersection.intersect(line, cur_polygon)\r\n                                if(pts.points.length > 0){\r\n                                    rule3 = false\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(!rule3){\r\n                                break\r\n                            }\r\n                        }\r\n                        if(!rule3){\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!rule3){\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule3){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule3!\")\r\n                // Rule 4\r\n                let rule4 = true\r\n                for(let j = Set_Order.length - 1; j > i; j --){\r\n                    let n_k = Set_Order[j].cat\r\n                    let set_other = {}\r\n                    for(let pid = 0; pid < this.catPointDict[n_k].length; pid ++){\r\n                        set_other[this.catPointDict[n_k][pid].id] = 1\r\n                    }\r\n                    let n_adj = this.SPG[n_k].adjList\r\n                    for(let q = 0; q < this.polygons[k][p].length; q ++){\r\n                        let id1 = this.polygons[k][p][q]\r\n                        let id2 = this.polygons[k][p][(q + 1) % this.polygons[k][p].length]\r\n                        for(let alen = 0; alen < n_adj[id1].length; alen ++){\r\n                            let e = n_adj[id1][alen]\r\n                            if(e.w == id2){\r\n                                for(let qq = 0; qq < this.polygons[k][p].length; qq ++){\r\n                                    if(!set_other.hasOwnProperty(this.polygons[k][p][qq])){\r\n                                        rule4 = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(!rule4){\r\n                                break\r\n                            }\r\n                        }\r\n                        if(!rule4){\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!rule4){\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule4){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule4!\")\r\n                console.log(\"A\")\r\n                console.log(rule1_res)\r\n                this.polygons[k][p].fillFlag = true\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    // Phase 3 : Visualization\r\n\r\n    drawAreas(k,curdata){\r\n\r\n        d3.select('svg').append(\"path\")\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 1)\r\n            //.attr('fill-rule',\"evenodd\")\r\n\r\n    }\r\n\r\n\r\n    drawKelpFusion(){\r\n\r\n        console.log(\"Polygons!!\")\r\n        console.log(this.polygons)\r\n\r\n        let Set_Order = []\r\n\r\n        for(let k in this.catPointDict){\r\n            let tmp = {}\r\n            tmp.num = this.catPointDict[k].length\r\n            tmp.cat = k\r\n            Set_Order.push(tmp)\r\n        }\r\n\r\n        Set_Order.sort(function (a, b){\r\n            return a.num - b.num\r\n        })\r\n\r\n        for(let i = Set_Order.length - 1; i >= 0; i --){\r\n\r\n            let cur_k = Set_Order[i].cat\r\n\r\n            // draw points\r\n            for(let j = 0; j < this.catPointDict[cur_k].length; j ++){\r\n                let pointID = this.catPointDict[cur_k][j].id\r\n                let v1 = [this.pointData[pointID].x, this.pointData[pointID].y]\r\n                let tmp_polygon = []\r\n                for(let p = 0; p < this.elementPoly[pointID].length; p ++){\r\n                    //let v2 = [this.elementPoly[pointID][p].x, this.elementPoly[pointID][p].y]\r\n                    //let v = [v2[0] - v1[0], v2[1] - v1[1]]\r\n                    //let len = Math.sqrt(v[0] * v[0] + v[1] * v[1])\r\n                    //let cur_v = [v[0] * (len + EdgeWidth / 2) / len, v[1] * (len + EdgeWidth / 2) / len]\r\n                    //tmp_polygon.push([v1[0] + cur_v[0], v1[1] + cur_v[1]])\r\n                    tmp_polygon.push([this.elementPoly[pointID][p].x, this.elementPoly[pointID][p].y])\r\n                }\r\n                this.drawAreas(cur_k, lineFunction(tmp_polygon))\r\n            }\r\n\r\n            // draw edges\r\n\r\n            if(this.SPGEdges.hasOwnProperty(cur_k)){\r\n                if(this.SPGEdges[cur_k].hasOwnProperty(\"length\")){\r\n                    for(let j = 0; j < this.SPGEdges[cur_k].length; j ++){\r\n                        let idx = this.SPGEdges[cur_k][j]\r\n                        let e = this.catInitEdges[cur_k][idx].edges\r\n                        let pts = []\r\n                        let pt1 = []\r\n                        let pt2 = []\r\n                        for(let p = 0; p < e.length; p ++){\r\n                            if(this.tanGraphPoints[e[p].v].type == \"addpoint\" || this.tanGraphPoints[e[p].w].type == \"addpoint\"){\r\n                                //continue\r\n                            }\r\n                            let vidx = e[p].v\r\n                            let widx = e[p].w\r\n\r\n                            let dataindex1 = -1\r\n                            let dataindex2 = -1\r\n                            let st, en\r\n\r\n                            if(this.tanGraphPoints[vidx].type != \"vi\" && this.tanGraphPoints[vidx].type != \"datapoint\"){\r\n                                dataindex1 = this.tanGraphPoints[vidx].dataindex\r\n                            }\r\n\r\n                            if(dataindex1 == -1){\r\n                                st = [this.tanGraphPoints[vidx].x, this.tanGraphPoints[vidx].y]\r\n                            }\r\n                            else{\r\n                                let catArray = this.pointData[dataindex1].catArray\r\n                                let isSame = false\r\n                                for(let c = 0; c < catArray.length; c ++){\r\n                                    if(catArray[c] == cur_k){\r\n                                        isSame = true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(isSame){\r\n                                    st = [this.tanGraphPoints[vidx].x, this.tanGraphPoints[vidx].y]\r\n                                }\r\n                                else{\r\n                                    let ve = [this.tanGraphPoints[vidx].x - this.pointData[dataindex1].x, this.tanGraphPoints[vidx].y - this.pointData[dataindex1].y]\r\n                                    let nlen = Math.sqrt(ve[0] * ve[0] + ve[1] * ve[1])\r\n                                    st = [this.tanGraphPoints[vidx].x + ve[0] * EdgeWidth / (2 * nlen), this.tanGraphPoints[vidx].y + ve[1] * EdgeWidth / (2 * nlen)]\r\n                                }\r\n                            }\r\n\r\n                            if(this.tanGraphPoints[widx].type != \"vi\" && this.tanGraphPoints[widx].type != \"datapoint\"){\r\n                                dataindex2 = this.tanGraphPoints[widx].dataindex\r\n                            }\r\n\r\n                            if(dataindex2 == -1){\r\n                                en = [this.tanGraphPoints[widx].x, this.tanGraphPoints[widx].y]\r\n                            }\r\n                            else{\r\n                                let catArray = this.pointData[dataindex2].catArray\r\n                                let isSame = false\r\n                                for(let c = 0; c < catArray.length; c ++){\r\n                                    if(catArray[c] == cur_k){\r\n                                        isSame = true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(isSame){\r\n                                    en = [this.tanGraphPoints[widx].x, this.tanGraphPoints[widx].y]\r\n                                }\r\n                                else{\r\n                                    let ve = [this.tanGraphPoints[widx].x - this.pointData[dataindex2].x, this.tanGraphPoints[widx].y - this.pointData[dataindex2].y]\r\n                                    let nlen = Math.sqrt(ve[0] * ve[0] + ve[1] * ve[1])\r\n                                    en = [this.tanGraphPoints[widx].x + ve[0] * EdgeWidth / (2 * nlen), this.tanGraphPoints[widx].y + ve[1] * EdgeWidth / (2 * nlen)]\r\n                                }\r\n                            }\r\n\r\n                            //drawLine(st, en, colors[cur_k], EdgeWidth)\r\n\r\n                            let v1 = [en[0] - st[0], en[1] - st[1]]\r\n                            let v2 = [(-1.0) * v1[1], v1[0]]\r\n                            let normlen = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1])\r\n                            v2 = [v2[0] / normlen, v2[1] / normlen]\r\n                            // Counterclockwise\r\n                            pt1.push([st[0] + v2[0] * EdgeWidth / 2 , st[1] + v2[1] * EdgeWidth / 2])\r\n                            pt1.push([en[0] + v2[0] * EdgeWidth / 2 , en[1] + v2[1] * EdgeWidth / 2])\r\n                            // Clockwise\r\n                            pt2.push([st[0] - v2[0] * EdgeWidth / 2 , st[1] - v2[1] * EdgeWidth / 2])\r\n                            pt2.push([en[0] - v2[0] * EdgeWidth / 2 , en[1] - v2[1] * EdgeWidth / 2])\r\n                        }\r\n                        for(let p = 0; p < pt1.length; p ++){\r\n                            if(!Object.is(pt1[p][0], NaN) && !Object.is(pt1[p][0], NaN)){\r\n                                //drawCircle(pt1[p][0], pt1[p][1], 2, 'red', 1)\r\n                                pts.push([pt1[p][0], pt1[p][1]])\r\n                            }\r\n                        }\r\n                        for(let p = pt2.length - 1; p >= 0; p --){\r\n                            if(!Object.is(pt2[p][0], NaN) && !Object.is(pt2[p][0], NaN)){\r\n                                //drawCircle(pt2[p][0], pt2[p][1], 2, 'red', 1)\r\n                                pts.push([pt2[p][0], pt2[p][1]])\r\n                            }\r\n                        }\r\n                        //console.log(\"pts!\")\r\n                        //console.log(pts)\r\n                        this.drawAreas(cur_k, lineFunction(pts))\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n\r\n            // fill polygons\r\n            if(this.polygons.hasOwnProperty(cur_k)){\r\n                //if(this.polygons.hasOwnProperty(\"length\")){\r\n                    for(let j = 0; j < this.polygons[cur_k].length; j ++){\r\n                        if(this.polygons[cur_k][j].fillFlag){\r\n                            let pts = []\r\n                            for(let p = 0; p < this.polygons[cur_k][j].length; p ++){\r\n                                let id1 = this.polygons[cur_k][j][p]\r\n                                let id2 = this.polygons[cur_k][j][(p + 1) % this.polygons[cur_k][j].length]\r\n                                let adjList = this.SPG[cur_k].adjList\r\n                                for(let pp = 0; pp < adjList[id1].length; pp ++){\r\n                                    let e = adjList[id1][pp]\r\n                                    if(e.w == id2){\r\n                                        let edge_path = this.catInitEdges[cur_k][e.label].edges\r\n                                        let tmp_pts = []\r\n                                        for(let ppp = 0; ppp < edge_path.length; ppp ++){\r\n                                            let u = edge_path[ppp].v\r\n                                            let v = edge_path[ppp].w\r\n                                            tmp_pts.push([this.tanGraphPoints[u].x, this.tanGraphPoints[u].y])\r\n                                            tmp_pts.push([this.tanGraphPoints[v].x, this.tanGraphPoints[v].y])\r\n                                        }\r\n                                        if(e.flag){\r\n                                            for(let tid = tmp_pts.length - 1; tid >= 0; tid --){\r\n                                                pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                            }\r\n                                        }\r\n                                        else{\r\n                                            for(let tid = 0; tid < tmp_pts.length; tid ++){\r\n                                                pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                            }\r\n                                        }\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            console.log(\"fill\")\r\n                            //for(let id = 0; id < pts.length; id ++){\r\n                            //    drawCircle(pts[id][0], pts[id][1], 5, 'red' , 2)\r\n                            //}\r\n\r\n                            this.drawAreas(cur_k, lineFunction(pts))\r\n                        }\r\n                    }\r\n                //}\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={900} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default KelpFusion","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport * as d3 from \"d3\"\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport {Button, Switch} from 'antd';\r\nimport {calDistance, PointToSegDist} from \"./util\"\r\nimport * as A from '@svgdotjs/svg.js'\r\nimport * as B from '@svgdotjs/svg.topoly.js'\r\nimport BSpline from \"./BSpline\";\r\nconst { pathDataToPolys } = require('svg-path-to-polygons');\r\n\r\n\r\nvar IsoInsideTest = require('point-in-polygon');\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n// var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n\r\nclass CalOverLap extends Component{\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        //this.getPath()\r\n        this.getSVG()\r\n\r\n    }\r\n\r\n\r\n    getSVG(){\r\n\r\n        let filename=\"Citywide.svg\"\r\n\r\n        fetch('/data/Evaluation/bubbleset/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'image/svg+xml'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.text())\r\n            .then(data=>{\r\n                //console.log(data)\r\n                console.log(data)\r\n\r\n                let doc = new DOMParser();\r\n                let xml = doc.parseFromString(data,\"image/svg+xml\")\r\n                let gs = xml.getElementsByTagName(\"g\")\r\n                console.log(\"select g res:\")\r\n                console.log(gs)\r\n                var paths = []\r\n                for(let i = 0; i < gs.length; i ++){\r\n                    let stylestr = gs[i].attributes[0].nodeValue.toString()\r\n                    let cmpstr = \"fill: none\"\r\n                    if(stylestr.match(cmpstr)==null){\r\n                      paths.push(gs[i].getElementsByTagName(\"path\"))\r\n                    }\r\n                }\r\n                //var paths = xml.getElementsByTagName(\"path\");\r\n\r\n                console.log(paths)\r\n                //console.log(xml)\r\n                //console.log(paths)\r\n\r\n                //console.log(paths)\r\n\r\n                let cat_Polygon = []\r\n                let cat_Area = []\r\n                let cat_Overlap_Area = []\r\n\r\n                let minX = Number.MAX_VALUE\r\n                let minY = Number.MAX_VALUE\r\n                let maxX = Number.MIN_VALUE\r\n                let maxY = Number.MIN_VALUE\r\n\r\n                for(let i = 0; i < paths.length; i ++){\r\n                    //console.log(paths[i])\r\n                    console.time(\"to polygon\")\r\n                    let path_data = paths[i][0].attributes.d.nodeValue\r\n                    let canvas = A.SVG().addTo('body')\r\n                    let p = canvas.path(path_data)\r\n                    let points = p.toPoly('5px')._array\r\n                    cat_Polygon.push(points)\r\n                    cat_Area.push(0)\r\n                    cat_Overlap_Area.push(0)\r\n                    for(let j = 0; j < points.length; j ++){\r\n                        let x = points[j][0]\r\n                        let y = points[j][1]\r\n                        minX = Math.min(minX, x)\r\n                        minY = Math.min(minY, y)\r\n                        maxX = Math.max(maxX, x)\r\n                        maxY = Math.max(maxY, y)\r\n                    }\r\n                    //console.log(points)\r\n                    d3.select(\"#mainsvg\").append(\"path\")\r\n                        .attr(\"d\",path_data)\r\n                        .attr(\"fill\",colors[i])\r\n                        .style('opacity', 0.5)\r\n                    //for(let j = 0; j < points.length; j ++){\r\n                    //    let x = points[j][0]\r\n                    //    let y = points[j][1]\r\n                    //    d3.select(\"#mainsvg\").append('circle')\r\n                    //        .attr(\"cx\",x)\r\n                    //        .attr(\"cy\",y)\r\n                    //        .attr(\"r\",2)\r\n                    //        .attr(\"fill\",\"red\")\r\n                    //}\r\n                    console.timeEnd(\"to polygon\")\r\n                }\r\n\r\n                d3.select(\"#mainsvg\")\r\n                    .attr(\"viewBox\",minX+\" \"+minY+\" \"+(maxX-minX)+\" \"+(maxY-minY))\r\n\r\n\r\n                minX -= 5\r\n                minY -= 5\r\n                maxX += 5\r\n                maxY += 5\r\n\r\n                for(let x = minX; x <= maxX; x ++){\r\n                    for(let y= minY; y <= maxY; y ++){\r\n                        let overlapID = []\r\n                        for(let i = 0; i < cat_Polygon.length; i ++){\r\n                            if(IsoInsideTest([x, y], cat_Polygon[i])){\r\n                                overlapID.push(i)\r\n                                cat_Area[i] ++\r\n                            }\r\n                        }\r\n                        if(overlapID.length > 1){\r\n                            d3.select('#mainsvg').append(\"circle\")\r\n                                .attr(\"cx\",x)\r\n                                .attr(\"cy\",y)\r\n                                .attr(\"r\",1)\r\n                                .attr(\"fill\",\"red\")\r\n                            for(let i = 0; i < overlapID.length; i ++){\r\n                                cat_Overlap_Area[i] ++\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let Sum_Area = 0\r\n                let Overlap_Area = 0\r\n\r\n                for(let i = 0; i < cat_Area.length; i ++){\r\n                    Sum_Area += cat_Area[i]\r\n                    Overlap_Area += cat_Overlap_Area[i]\r\n                }\r\n\r\n                console.log(filename)\r\n                console.log(\"OverLap Area: \" + Overlap_Area)\r\n                console.log(\"Sum Area: \" + Sum_Area)\r\n                console.log(\"Result: \" + Overlap_Area / Sum_Area)\r\n\r\n            })\r\n\r\n    }\r\n\r\n    getPath(){\r\n\r\n        //for(let f = 1; f <= 10; f ++){\r\n            //let filename = \"ex\" + f.toString() + \".txt\"\r\n            //console.log(filename)\r\n            let filename = \"Citywide.txt\"\r\n            fetch('/data/Evaluation/'+filename,{\r\n                method:'GET',\r\n                headers:{\r\n                    'Content-Type':'application/json;charset=UTF-8'\r\n                },\r\n                mode:'cors',\r\n                cache:'default'\r\n            })\r\n                .then(res=>res.json())\r\n                .then(data=>{\r\n                    //console.log(data)\r\n                    var paths = data\r\n\r\n                    let cat_Polygon = {}\r\n                    let cat_Area = {}\r\n                    let cat_Overlap_Area = {}\r\n                    let selectIdx = {}\r\n\r\n                    let minX = Number.MAX_VALUE\r\n                    let minY = Number.MAX_VALUE\r\n                    let maxX = Number.MIN_VALUE\r\n                    let maxY = Number.MIN_VALUE\r\n\r\n                    //console.log(paths)\r\n                    console.time(\"cal\")\r\n                    for(let k in paths){\r\n\r\n                        let draw_data = \"\"\r\n\r\n                        cat_Polygon[k] = []\r\n                        cat_Area[k] = 0\r\n                        cat_Overlap_Area[k] = 0\r\n\r\n                        let sID = 0\r\n                        let maxPath = -1\r\n\r\n                        console.time(\"to polygon\")\r\n                        for(let i = 0; i < paths[k].length; i ++){\r\n                            let path_data = paths[k][i]\r\n                            draw_data += path_data\r\n                            let canvas = A.SVG().addTo('body')\r\n                            let p = canvas.path(path_data)\r\n                            let points = p.toPoly('5px')._array\r\n                            cat_Polygon[k].push(points)\r\n                            if(points.length > maxPath){\r\n                                maxPath = points.length\r\n                                sID = i\r\n                            }\r\n                            for(let j = 0; j < points.length; j ++){\r\n                                let x = points[j][0]\r\n                                let y = points[j][1]\r\n                                minX = Math.min(minX, x)\r\n                                minY = Math.min(minY, y)\r\n                                maxX = Math.max(maxX, x)\r\n                                maxY = Math.max(maxY, y)\r\n                            }\r\n                        }\r\n                        console.timeEnd(\"to polygon\")\r\n\r\n                        selectIdx[k] = sID\r\n\r\n                        d3.select(\"#mainsvg\").append(\"path\")\r\n                            .attr(\"d\",draw_data)\r\n                            .style(\"fill\",colors[parseInt(k)])\r\n                            .style('opacity', 0.5)\r\n\r\n                    }\r\n\r\n                    d3.select(\"#mainsvg\")\r\n                        .attr(\"viewBox\",minX+\" \"+minY+\" \"+(maxX-minX)+\" \"+(maxY-minY))\r\n\r\n                    minX -= 5\r\n                    minY -= 5\r\n                    maxX += 5\r\n                    maxY += 5\r\n\r\n                    //console.log(cat_Polygon)\r\n\r\n                    for(let x = minX; x <= maxX; x ++){\r\n                        for(let y= minY; y <= maxY; y ++){\r\n\r\n                            let overlapID = []\r\n\r\n                            for(let k in cat_Polygon){\r\n\r\n                                let sID = selectIdx[k]\r\n\r\n                                if(!IsoInsideTest([x, y], cat_Polygon[k][sID])){\r\n                                    continue\r\n                                }\r\n\r\n                                let flag2 = true\r\n                                for(let i = 0; i < cat_Polygon[k].length; i ++){\r\n                                    if(i == sID){\r\n                                        continue\r\n                                    }\r\n                                    if(IsoInsideTest([x, y], cat_Polygon[k][i])){\r\n                                        flag2 = false\r\n                                        break\r\n                                    }\r\n                                }\r\n\r\n                                if(flag2){\r\n                                    cat_Area[k] ++\r\n                                    overlapID.push(k)\r\n                                }\r\n\r\n                            }\r\n\r\n                            if(overlapID.length > 1){\r\n                                d3.select('#mainsvg').append(\"circle\")\r\n                                    .attr(\"cx\",x)\r\n                                    .attr(\"cy\",y)\r\n                                    .attr(\"r\",1)\r\n                                    .attr(\"fill\",\"red\")\r\n                                for(let i = 0; i < overlapID.length; i ++){\r\n                                    cat_Overlap_Area[i] ++\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n                    let Sum_Area = 0\r\n                    let Overlap_Area = 0\r\n\r\n                    for(let k in cat_Area){\r\n                        Sum_Area += cat_Area[k]\r\n                        Overlap_Area += cat_Overlap_Area[k]\r\n                    }\r\n\r\n                    console.log(filename)\r\n                    console.log(\"OverLap Area: \" + Overlap_Area)\r\n                    console.log(\"Sum Area: \" + Sum_Area)\r\n                    console.log(\"Result: \" + Overlap_Area / Sum_Area)\r\n\r\n                    console.timeEnd(\"cal\")\r\n\r\n\r\n\r\n                })\r\n        //}\r\n        //let filename=\"life_fertility.txt\"\r\n\r\n\r\n    }\r\n\r\n\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={1200} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default CalOverLap","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport BubbleDemo from \"./BubbleDemo\"\r\nimport KelpDiagram from\"./KelpDiagram\"\r\nimport KelpFusion from \"./KelpFusion\";\r\nimport CalOverLap from \"./CalOverLap\";\r\nimport CSVData from \"./CSVData\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n\r\n      <BubbleDemo></BubbleDemo>\r\n      {/*<KelpDiagram></KelpDiagram>*/}\r\n      {/*<KelpFusion></KelpFusion>*/}\r\n      {/*<CalOverLap></CalOverLap>*/}\r\n      {/*<CSVData></CSVData>*/}\r\n\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}