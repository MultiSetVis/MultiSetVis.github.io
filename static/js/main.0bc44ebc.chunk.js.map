{"version":3,"sources":["priority_queue.js","logo.svg","App.js","reportWebVitals.js","MainSvg.js","dataHacker.js","CSVData.js","GapMinderNew.js","ManuallyTree.js","Example1.js","LocalCluster.js","util.js","BSpline.js","AdaptiveIsovalue.js","HierarchicalCluster.js","BMOAlgo.js","AlgorithmEntry.js","IndexUI.js","BubbleDemo.js","KelpDiagram.js","KelpFusion.js","CalOverLap.js","index.js"],"names":["PriorityQueue","d","this","_d","_elements","module","exports","prototype","checkEdgeCrossing","P1","P2","Q1","Q2","Math","min","x","max","y","isEmpty","size","peek","Error","modify_Prim","e1","e2","thisid","weightcross","szbefore","length","i","s","start","e","end","id","clusterid2","hasOwnProperty","cat","score","splice","tmp","enq","sz","parseInt","adjust","searchFather","f","m","j","_compare","modify_Kruskal_V2","fs","clusterid1","fe","push","modify_Kruskal","fa","deq","first","last","pop","current","largest","left","right","_swap","element","parent","floor","forEach","fn","a","b","aux","pid","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","colors","jsgraphs","require","POINT_EDGE_EPS","Component","clustering","calDistance","x1","y1","x2","y2","sqrt","pow","getVecNorm","vec","normalizeVec","norm","drawCircle","r","fill","stroke","d3","append","attr","drawRect","width","height","color","drawLine","on","PointToSegDist","cross","d2","px","py","calTanPoint","cx","cy","radius","point","vc1c2","radC1C2","acos","theta","p1","cos","sin","p2","PI","calCommonTanPoint","r1","r2","tanPoints","delta1","delta2","vecpq","dir","newpointp","newpointq","dir2","newpointp2","newpointq2","intersecx","intersecy","tanpoints1","tanpoints2","p3","delta","abs","drawArc","startp","endp","center","pathstr","largearcflag","vec1","vec2","crossmul","getDegreeTwoVec","norm1","norm2","rotatePoint","rx0","ry0","alpha","crossMul","BSpline","points","degree","copy","dimension","baseFunc","basisDeg2","baseFuncRangeInt","basisDeg3","basisDeg4","basisDeg5","seqAt","dim","margin","n","getInterpol","seq","t","rangeInt","tInt","result","calcAt","res","g","offsetX","offsetY","viewWidth","viewHeight","MarchingSquaresJS","IsoInsideTest","AreaCal","IntersectionQuery","ShapeInfo","Intersection","Point2D","buffer","nodeR1","nodeR0","edgeR1","edgeR0","defaultEdgeWidth","itemEnergyShape","nodeWeight","edgeWeight","barrierGap","intervals","pixelGroup","gapBetween","fixdis","control_points","initialControlPoints","is_selected","eps","nearpts","hasChangeView","prepoints","svgwidth","svgheight","skipPoint","minItemArea","Number","MAX_VALUE","editSeg","lineFunction","curve","lineFunction_reDraw","clone","obj","Date","setTime","getTime","Array","Object","AdaptiveIsovalue","onChangeEdgeWidth","value","setState","edgeWidth","changeEdgeWidth","selectedEdge","onChangeNodeR0","onChangeNodeR1","onChangeEdgeR0","onChangeEdgeR1","onChangePixelGroup","onChangeGap","state","hasSelectEdge","isfirstcreate","pointData","canvasWidth","canvasHeight","maxX","maxY","minX","minY","maxDis","MIN_VALUE","catPointDict","catEdgeDict","edges","maxDistance","itemShape","itemBBox","catEnergyField","catNotGroup","activeRegion","energyField","field","editMode","editIndex","updatedEnergyPoints","edgeControlPoints","hasMST","updateIdx","hasBubbles","firstFlag","render","componentDidMount","X","Y","Width","Height","props","onRef","document","getElementById","getBoundingClientRect","oncontextmenu","pdict","flag","c","catArray","nowcat","edict","filledges","catarr","startpoint","editPoints","editEdges","HpointData","Hedges","console","time","shape","parseFloat","toString","cats","split","catarray","multicat","centralizeData","calEdgeLength","calActiveRegion","updatePoints","updateEdges","preProcessPoints","preProcessEdges","calEnergyField_Part","timeEnd","calFinalEnergeField_Part","fillCrossingEdge_Part","remove","findOutLine","calOutLine","calEdgeControlPoints","that","log","selectAll","filter","init","createMST","loadEdgeData","handleCreated","ViewFlag","minx","miny","maxx","maxy","virtrual","vpoints","virtrualNodes","p","colorArray","call","extent","scaleExtent","transform","event","items","index","getElementsByTagName","getAttribute","getBBox","bbox","sortArr","avgdis","tempcontrolpoints","k","controlpoints","minDis","minindex","edge","dis","order","iscontinue","temppoints","lastindex","sort","dw","firstOutline","secondOutline","dot","dx","dy","drawPathData","reDraw","stopPropagation","handleClick","vstart","vend","v","thisindex","minlength","maxlength","endpoint","vpoint","nowp","nextp","edgelength","maxEdgeLength","minEdgeLength","nextProps","nextState","nextContext","fieldData","startY","boundingY","startX","boundingX","endY","boundingHeight","endX","boundingWidth","finalField","isoDict","calISOLine","polygontest","tmp_polygon","prelength","polygon","sk","selectidx","curlen","meandis","sidx","isthis","st_idx","pt_len","j_pt","idx1","idx2","ve1","ve2","ve3","ve3_len","test_pt","is_use_inner","j_y","j_x","path_Info","curdata","drawISOLinesV2","JSON","stringify","calEnergyField","calFinalEnergeField","fillCrossingEdge","createGapInBoundary","drawEdges","drawPointData","ceil","centerX","centerY","barrierMap","item","lx1","ly1","lx2","ly2","projlenSq","dotprod","lenSq","distancetoendnode","distancetoedge","mindis","distancetostartnode","totaldistance","getPointEdgeDistance","enddis","sp","se","selength","distancetonode","rect1","rect2","maxpdis","k1","isGroup","isgroup","k2","calDistanceToEdge","pointMap","pointBarrierMap","edgeBarrierMap","pointIndexMap","edgeIndexMap","edgeIndexMap2","subUpdate","members","startx","endx","starty","endy","realx","realy","distance","calDistanceToItem","energy","EDGELENGTH_THRESH","startid","endid","calDistanceToEdgeV2","distancetoEdge","distancetoNode","totalDistance","newR1","delflag","it","relativex","relativey","hasSameCat","samecat","c1","cat1","c2","cat2","area_abc","area_abd","area_cda","gap","deletePoints","isboundary","isolines","isolinepoints","isoLineMap","relativepoints","isoInsidePoints","pointInPolygon","notDeleteIndex","nodePoints","totalInside","isolineIndex","deleteindex","isdelete","newisolines","catarr1","catarr2","gfield","finalvalue","isInside","thisPointID","gpointIndexMap","thisEdgeID","gedgeIndexMap","thiscat","gbarrierMap","gwidth","gheight","othervalue","otherinside","otherPointID","otherEdgeID","othercat","isContained","gpointBarrierMap","Set","updateidx","preK","bounding","smoothEnergyField","idx","val","lines","val1","val2","tmpx","uy","ux","target","map","style","dat","Polygon","max_y","min_y","max_x","min_x","NET","ymax","AET","curi","CurSize","fx","fy","relativeotherx","relativeothery","P_1","P_2","p_x1","shift","p_x2","x_begin","x_end","cut","len","bx1","by1","bx2","by2","dragstarted","execflag","_groups","attributes","tmp_idx","isnum","iidx","jidx","v1","v2","dragged","sourceEvent","ex","ey","reDrawData","cur_len","tmp_pts","q","tmpDict","sid","cur_idx","s_pts","tmpPath","node","totLen","getTotalLength","r1_idx","dis1","r2_idx","dis2","tmp_p","getPointAtLength","tmpdis1","tmpdis2","dragended","v3","fillPolygon","button","pointpath","data","isoLines","polygons","linearRing","noFrame","isoLineDict","tpoints","splinePoints","spline","kernel","sum","kernelsize","anchor","C","ny","nx","exp","normalizeKernel","isSingular","edgeCrossingList","start1","end1","linesToCheck1","vlength","start2","end2","linesToCheck2","l1","l2","crossInfo","newFieldDict","crossingPoints","fillArea","crosspoint","otherid","line","crossline","dl","lineLength","vec3","linedirvec","normdirvec","step","topBoundPoints","bottomBoundPoints","lastTop","lastBottom","rightstop","topstop","bottomstop","newanchor1","disalongline","topfind","bottomfind","newpointtop","newxtop","newytop","otherx","othery","newpointbottom","newxbottom","newybottom","fillPolyPoints","leftstop","newanchor2","fillPolygonForEdge","getGaussianKernel","sx","sy","cur_width","cur_height","newField","newvalue","formatpoints","isInterior","parentID","updateEnergyPoints","span","onChange","disabled","onClick","getData","bind","hasLoadData","removeOverlaps","defaultProps","preEdgeDict","curEdgeDict","FileSaver","DBSCAN_EPS","weightCross","weightDistance","weightMess","maxCross","DISTANCE_THRESHHOLD","priority_queue","svgid","opsvgid","preEdges","tmpEditEdges","editView","BeforeWidth","BeforeHeight","ScreenWidth","ScreenHeight","HierarchicalCluster","ref","child","read","hasinit","hasEdit","hascreated","editV","issplit","graph","clustergraph","isSelect","selectItem","clusterDict","clustergraphInfo","clusterArr","noiseDict","intersecEdges","vis","heap1","heap2","QTree","edgesdict","draggedIndex","draggedEdgeIndex","draggedEdgeSeg","nodeStartDict","nodeEndDict","lastClickIndex","lastClickItem","deletedEdge","addedEdge","tempEdges","componentWillMount","init_all","window","screen","availHeight","availWidth","dissum","disnum","tmpp1","calEPS","optimizeMST","applyEdit","beginTime","generateTreeWithHierarchical","endTime","countEdgeCrossingWithRouting","hasCreate","Graph","V","label","disArray","messArray","tempedges","mess","calEdgeMess","weight","calEdgeWeight","node1","node2","crossnum","edgecat","sortedEdges","removeEdggeList","sortEdgesGlobal","DepthFirstSearch","hasPathTo","checkNewEdge","addEdge","checkConnect","tempEdgeList","scores","calEdgeWeightWithCrossing","minCost","maxindex","sortEdgesGlobalWithMinDis","edgesnum","nodesnum","dfs","id1","id2","removelist","num","isPointInEdgeRange","calPointEdgeDistance","calVecCosine","vec4","seg1","SVGElement","select","empty","insert","drawOneEdge","each","savedData","fetch","method","headers","mode","cache","json","removeindex","countEdgeCrossing","isedit","newGraph","cc","ConnectedComponents","componentCount","newClusterDict","componentId","idnum","getElementsByClassName","newEdges","recalculateSpanningTreeAfterEdit","drawOneEdgeAfterEdit","tmpe","recalculateSpanningTree","new","ei","thisedge","pcat","linesToCheck","ids","swap","checkline","intersecInfo","findCrossingBetweenEdgeRect","rec","rect","line1","line3","line2","line4","point1","point2","vnode","cornerpointindex","cornerpoint","iternum","vnode1","vnode2","centerpoint","movevec","movenorm","checkVNodeInBound","minCross","bestVnode","potentialNode","pnode","count","node3","temppoint","samepoiint","newid","index1","index2","newedge","isLocalTree","surfaceRoutingEdge","oneEdge","dragControlPoint","edgeindex","segindex","bubbleState","editReDraw","dragEdge","handleMouseDown","newline","edgeIndex","segIndex","thisedgeindex","thissegindex","deleteEdge","findCircle","catEdges","nodeDegree","finish","circleEdges","has","lastcat","checkCircle","isAdded","worstindex","worstscore","worstEdge","drag","nodeindex","st","en","rerouting","w","h","deleteEdges","reroutingEdges","pointedgedis","preEdge","tmpp","vnodes1","flag1","st1_p","en1_p","st2_p","en2_p","vnodes2","path","clickIndex","hasLinked","lines1","vnodes","lines2","p4","midx","midy","midnode","initWithNoCluster","preAddedClusters","catclusters","startclusterid","endclusterid","merged","newclusterdict","createGraphWithCluster","createLocalTree","hierarchicalMergeV2","dbscan","DBSCAN","dataset","pointDataSet","clusters","run","clusterPoints","noise","g2","cluster1","cluster2","calClusterDistance","minstart","minend","minScore","bestStart","bestEnd","minScoreWithDis","links","minIndex","minScoreWithDistance","minIndexWithDistance","hasBest","checkConnectBetweenTwoCluster","rectangle","top","intersections","intersect","status","pointInRectangle","isDeleted","checkConnectBetweenTwoClusterV2","totcluster","optimalLinks1","optimalLinks2","addLinks","checkConnectBetweenAllCluster","bestLink","unionFather","checkConnectBetweenAllClusterV2","optimalLinks","link","findOptimalLink","findMinScore","sortEdgesGlobalWithCluster","findLinkBetweenCluster","checkConnectBetweenCluster","clusterstart","clusterend","infostr","handleManually","afterEditReDraw","content","blob","Blob","type","saveAs","marginTop","checkedChildren","unCheckedChildren","editBackbone","checked","AlgorithmEntry","alert","finishInput","svg","svgsaver","Header","Select","Option","Layout","Footer","Sider","Content","columns","title","dataIndex","text","key","tags","tag","keynum","GroupDict","cur_set","is_input","IndexUI","updateview","GroupData","name","dataFile","scaleX","scaleY","selValue","hasCreateMST","menu","Item","rel","savePNG","saveSVG","saveData","box","handleMousedown","undefined","Scale","tmpg","handleDeleteNode","addNewPoints","set","tmp_index","findIndex","GroupCat","curcat","tmpcat","tmpGroupData","scale_ratio_x","scale_ratio_y","transform_dx","transform_dy","ratio","filename","drawInit","saveSvgAsPng","viewbox","svgstr","html","options","p5","pad1","pad2","background","textAlign","fontFamily","fontWeight","fontSize","theme","padding","className","float","border","showSearch","placeholder","changeSel","handleUpload","overlay","arrow","DownOutlined","pagination","position","scroll","dataSource","BubbleDemo","d3Voronoi","re","tanPointsNum","deltaDeg","triangulate","EdgeWidth","neighbors","pathDataToPolys","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.0bc44ebc.chunk.js","sourcesContent":["//修改自：https://github.com/janogonzalez/priorityqueuejs\r\n\r\nmodule.exports = PriorityQueue;\r\n\r\nfunction PriorityQueue(d) {\r\n    this._d = d;\r\n    this._elements = [];\r\n}\r\n\r\nPriorityQueue.prototype.checkEdgeCrossing = function(P1,P2,Q1,Q2){\r\n    if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n        Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n        Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n        Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n        if(\r\n            ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n            ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n        ){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n    else{\r\n        return false\r\n    }\r\n}\r\n\r\nPriorityQueue.prototype.isEmpty = function() {\r\n    return this.size() === 0;\r\n};\r\n\r\nPriorityQueue.prototype.peek = function() {\r\n    if (this.isEmpty()) throw new Error('PriorityQueue is empty');\r\n    return this._elements[0];\r\n};\r\n\r\nPriorityQueue.prototype.modify_Prim = function(e1,e2,thisid,weightcross){\r\n    //let a = this._elements.length\r\n    //console.log(\"modify before: \" + a)\r\n    let szbefore = this._elements.length;\r\n    for(let i = this._elements.length - 1;i >= 0;i --){\r\n        let s = this._d[this._elements[i]].start;\r\n        let e = this._d[this._elements[i]].end;\r\n        let id = this._d[this._elements[i]].clusterid2;\r\n        if((!this._d.hasOwnProperty(this._elements[i])) || id == thisid){\r\n            this._elements.splice(i,1);\r\n            continue;\r\n        }\r\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\r\n            this._d[this._elements[i]].score += weightcross\r\n        }\r\n    }\r\n    let tmp = this._elements;\r\n    this._elements = [];\r\n    for(let i = 0;i< tmp.length;i++){\r\n        this.enq(tmp[i]);\r\n    }\r\n\r\n    let sz = this._elements.length;\r\n    if(sz <= 1 || sz == szbefore){\r\n        return;\r\n    }\r\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\r\n        this.adjust(i,sz - 1);\r\n    }\r\n\r\n}\r\n\r\nPriorityQueue.prototype.searchFather = function (f,x){\r\n    while(x!=f[x]){\r\n        f[x] = f[f[x]];\r\n        x = f[x];\r\n    }\r\n    return x;\r\n}\r\n\r\nPriorityQueue.prototype.adjust = function(start, m){\r\n    let i = start;\r\n    let j = 2 * i + 1;\r\n    let tmp = this._elements[i];\r\n    while(j <= m){\r\n        if(j < m && this._compare(j, j + 1)){\r\n            j ++;\r\n        }\r\n        if(this._d[tmp].score <= this._d[this._elements[j]].score){\r\n            break;\r\n        }\r\n        else{\r\n            this._elements[i] = this._elements[j];\r\n            //V1\r\n            //this._d[this._elements[i]].pid = i;\r\n            i = j;\r\n            j = 2 * j + 1;\r\n        }\r\n    }\r\n    this._elements[i] = tmp;\r\n    //V1\r\n    //this._d[this._elements[i]].pid = i;\r\n}\r\n//function(e1,e2,f,weightcross,fa)\r\n\r\nPriorityQueue.prototype.modify_Kruskal_V2 = function(e1,e2,f,weightcross){\r\n\r\n    //let szbefore = this._elements.length;\r\n    let tmp = []\r\n    for(let i = this._elements.length - 1;i >= 0;i --){\r\n        let s = this._d[this._elements[i]].start;\r\n        let e = this._d[this._elements[i]].end;\r\n        let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\r\n        let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\r\n        if((!this._d.hasOwnProperty(this._elements[i]))){\r\n            this._elements.splice(i,1);\r\n            continue;\r\n        }\r\n        if(fs == fe){\r\n            delete this._d[this._elements[i]];\r\n            this._elements.splice(i,1);\r\n            continue;\r\n        }\r\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\r\n            this._d[this._elements[i]].score += weightcross\r\n        }\r\n        tmp.push(this._elements[i])\r\n    }\r\n\r\n    let sz = tmp.length;\r\n\r\n    if(sz <= 1){\r\n        return;\r\n    }\r\n\r\n    this._elements=[]\r\n\r\n    for(let i = 0;i < sz;i ++){\r\n        this.enq(tmp[i]);\r\n    }\r\n\r\n    //for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\r\n    //    this.adjust(i,sz - 1);\r\n    //}\r\n\r\n}\r\n\r\nPriorityQueue.prototype.modify_Kruskal = function(e1,e2,f,weightcross,fa){\r\n    //let a = this._elements.length\r\n    //console.log(\"modify before: \" + a)\r\n    //let szbefore = this._elements.length;\r\n    //for(let i = this._elements.length - 1;i >= 0;i --){\r\n    //    let s = this._d[this._elements[i]].start;\r\n    //    let e = this._d[this._elements[i]].end;\r\n    //    let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\r\n    //    let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\r\n    //    if((!this._d.hasOwnProperty(this._elements[i]))){\r\n    //        this._elements.splice(i,1);\r\n    //        continue;\r\n    //    }\r\n    //    if(fs == fa && fe == fa){\r\n    //        delete this._d[this._elements[i]];\r\n    //        this._elements.splice(i,1);\r\n    //        continue;\r\n    //    }\r\n    //    if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\r\n    //        this._d[this._elements[i]].score += weightcross\r\n    //    }\r\n    //}\r\n\r\n    let sz = this._elements.length;\r\n\r\n    //if(sz <= 1 || sz == szbefore){\r\n    //    return;\r\n    //}\r\n\r\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\r\n        this.adjust(i,sz - 1);\r\n    }\r\n\r\n    //for(let i = 0;i < sz;i ++){\r\n    //    this._d[this._elements[i]].pid = i;\r\n    //}\r\n\r\n}\r\n\r\nPriorityQueue.prototype.deq = function() {\r\n    //let a = this._elements.length\r\n    //console.log(\"deq before: \" + a)\r\n    //delete this._d[this._elements[0]];\r\n    var first = this.peek();\r\n    //V1\r\n    //this._d[first].pid = -1;\r\n    var last = this._elements.pop();\r\n    var size = this.size();\r\n    if (size === 0) return first;\r\n\r\n    this._elements[0] = last;\r\n    var current = 0;\r\n\r\n    while (current < size) {\r\n        var largest = current;\r\n        var left = (2 * current) + 1;\r\n        var right = (2 * current) + 2;\r\n\r\n        if (left < size && this._compare(left, largest) >= 0) {\r\n            largest = left;\r\n        }\r\n\r\n        if (right < size && this._compare(right, largest) >= 0) {\r\n            largest = right;\r\n        }\r\n\r\n        if (largest === current) break;\r\n\r\n        this._swap(largest, current);\r\n        current = largest;\r\n    }\r\n    //let b = this._elements.length\r\n    //console.log(\"deq after: \" + b)\r\n    return first;\r\n};\r\n\r\nPriorityQueue.prototype.enq = function(element) {\r\n    //let a = this._elements.length\r\n    //console.log(\"enq before: \" + a)\r\n    var size = this._elements.push(element);\r\n    var current = size - 1;\r\n\r\n    while (current > 0) {\r\n        var parent = Math.floor((current - 1) / 2);\r\n        if (this._compare(current, parent) <= 0) break;\r\n        this._swap(parent, current);\r\n        current = parent;\r\n    }\r\n   //let b = this._elements.length\r\n   //console.log(\"enq after: \" + b)\r\n    return size;\r\n};\r\n\r\nPriorityQueue.prototype.size = function() {\r\n    return this._elements.length;\r\n};\r\n\r\nPriorityQueue.prototype.forEach = function(fn) {\r\n    return this._elements.forEach(fn);\r\n};\r\n\r\nPriorityQueue.prototype._compare = function(a, b) {\r\n    return this._d[this._elements[b]].score - this._d[this._elements[a]].score;\r\n};\r\n\r\nPriorityQueue.prototype._swap = function(a, b) {\r\n    var aux = this._elements[a];\r\n    this._d[this._elements[a]].pid = b;\r\n    this._d[this._elements[b]].pid = a;\r\n    this._elements[a] = this._elements[b];\r\n    this._elements[b] = aux;\r\n};","export default __webpack_public_path__ + \"static/media/logo.2d27ead7.svg\";","import logo from './logo.svg';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.js</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#434343','#8701ec','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\n\r\n\r\nclass MainSvg extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.maxDistance=-1\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        let centerx=minx+(maxx-minx)/2\r\n        let centery=miny+(maxy-miny)/2\r\n        let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x+=move[0]\r\n            this.pointData[i].y+=move[1]\r\n        }\r\n        this.maxX=maxx+move[0]\r\n        this.minX=minx+move[0]\r\n        this.maxY=maxy+move[1]\r\n        this.minY=miny+move[1]\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x-=this.minX-20\r\n            this.pointData[i].y-=this.minY-20\r\n        }\r\n    }\r\n\r\n    calEPS(){\r\n        POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample3.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n               this.centralizeData()\r\n                this.calEPS()\r\n                this.createGraph()\r\n                this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                this.drawEdges()\r\n                this.drawPointData()\r\n                this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n        Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n        Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n        Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n            for (let i=0;i<sortedEdges.length;i++){\r\n                let start=sortedEdges[i][0]\r\n                let end=sortedEdges[i][1]\r\n                let weight=sortedEdges[i][2]\r\n                let dis=sortedEdges[i][3]\r\n                let mess=sortedEdges[i][4]\r\n\r\n                if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                    continue\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n                if(!dfs.hasPathTo(end)){\r\n                    if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                        this.graph.addEdge(start,end)\r\n                        // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                        this.edges.push({\r\n                            start:start,\r\n                            end:end,\r\n                            weight:weight,\r\n                            dis:dis,\r\n                            mess:mess\r\n                        })\r\n                        // this.graph.node(start).label=true\r\n                        // this.graph.node(end).label=true\r\n                    }\r\n                    else{\r\n                        removeEdggeList.push({\r\n                            start:start,\r\n                            end:end,\r\n                            weight:weight,\r\n                            dis:dis,\r\n                            crossnum:-1,\r\n                            mess:mess\r\n                        })\r\n                    }\r\n                    // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                    // console.log(this.graph.adj(start))\r\n                    // this.drawLine(this.pointData)\r\n                }\r\n            }\r\n\r\n        while(!this.checkConnect()){\r\n                let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n            // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n/*        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index=i\r\n            d3.select(\"svg\")\r\n                .append(\"circle\")\r\n                .attr(\"cx\",this.pointData[i].x)\r\n                .attr(\"cy\",this.pointData[i].y)\r\n                .attr(\"r\",this.pointData[i].radius)\r\n                .attr(\"fill\",colors[this.pointData[i].cat])\r\n                .attr(\"catefory\",this.pointData[i].cat)\r\n                .attr(\"index\",index)\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.pointData[index])\r\n                })\r\n                .on(\"drag\",function(){\r\n                    console.log(\"drag!\")\r\n                })\r\n                .call(drag)\r\n        }\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        let maxOneCross=Number.MIN_VALUE\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            let oneCrossNum=0\r\n\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                        oneCrossNum+=1\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(oneCrossNum>maxOneCross){\r\n                maxOneCross=oneCrossNum\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n        console.log(\"max crossing num of one edge: \"+maxOneCross)\r\n\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.savePointData.bind(this)}> Save </button>\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default MainSvg","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\n\r\n\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass DataHacker extends Component{\r\n    constructor() {\r\n        super();\r\n        this.globalCategory=0\r\n        this.points=[]\r\n        this.numOfPoints=0\r\n        this.nowCategory=0\r\n        this.jsonoutput=null\r\n        this.input=null\r\n        this.width=60\r\n        this.height=70\r\n    }\r\n\r\n    componentDidMount() {\r\n        d3.select(\"svg\")\r\n            .on(\"click\",this.leftClick.bind(this))\r\n/*        for (let i=0;i<11;i++){\r\n            d3.select(\"svg\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",(i+1)*1000/11)\r\n                .attr(\"y1\",0)\r\n                .attr(\"x2\",(i+1)*1000/11)\r\n                .attr(\"y2\",1000)\r\n                .attr(\"stroke\", \"black\")\r\n                .attr(\"stroke-width\", \"2px\");\r\n\r\n        }*/\r\n\r\n    }\r\n\r\n\r\n    drawPoint(x,y,color,cat,index){\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",7)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .on(\"click\",this.deletePoint.bind(this))\r\n    }\r\n\r\n    drawRect(x,y,w,h,color,cat,index){\r\n        d3.select(\"svg\")\r\n            .append(\"rect\")\r\n            .attr(\"x\",x-w/2)\r\n            .attr(\"y\",y-h/2)\r\n            .attr(\"width\",w)\r\n            .attr(\"height\",h)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .on(\"click\",this.deletePoint.bind(this))\r\n        d3.select(\"svg\")\r\n            .append(\"text\")\r\n            .attr(\"x\",x-w/2)\r\n            .attr(\"y\",y-h/2)\r\n            .attr(\"index\",index)\r\n            .style(\"font-size\",12)\r\n            .text(index)\r\n    }\r\n\r\n    deletePoint(e){\r\n        e.stopPropagation()\r\n        let el=e.target\r\n        let index=d3.select(el).attr(\"index\")\r\n        this.points[index]=-1\r\n        d3.select(el).remove()\r\n        console.log(index)\r\n        d3.selectAll(\"text\")\r\n            .filter(function(d,i){\r\n                return d3.select(this).attr(\"index\")==index\r\n            })\r\n            .remove()\r\n        // console.log(this.points)\r\n    }\r\n\r\n    leftClick(e){\r\n        // console.log(e)\r\n        let x=e.offsetX\r\n        let y=e.offsetY\r\n        // this.drawRect(x,y,this.width,this.height,colors[this.nowCategory],this.nowCategory,this.numOfPoints)\r\n        this.drawPoint(x,y,colors[this.nowCategory],this.nowCategory,this.numOfPoints)\r\n        this.points.push({\r\n            x:x,\r\n            y:y,\r\n            cat:this.nowCategory,\r\n            id:this.numOfPoints,\r\n            radius:7\r\n            // width:this.width,\r\n            // height:this.height\r\n        })\r\n        this.numOfPoints+=1\r\n        // console.log(this.points)\r\n    }\r\n\r\n    savePoints(){\r\n        let tempPoints=[]\r\n        let num=0\r\n        for (let i=0;i<this.points.length;i++){\r\n            if(this.points[i]!=-1){\r\n                this.points[i].id=num\r\n                num+=1\r\n                tempPoints.push(this.points[i])\r\n            }\r\n        }\r\n        this.points=tempPoints\r\n        d3.select(\"svg\").selectAll(\"circle\").remove()\r\n        d3.select(\"svg\").selectAll(\"text\").remove()\r\n\r\n        for (let i=0;i<this.points.length;i++){\r\n            // this.drawRect(this.points[i].x,this.points[i].y,this.points[i].width,this.points[i].height,colors[this.points[i].cat],this.points[i].cat,i)\r\n            this.drawPoint(this.points[i].x,this.points[i].y,colors[this.points[i].cat],this.points[i].cat,i)\r\n\r\n        }\r\n        this.numOfPoints=this.points.length\r\n\r\n        for (let i=0;i<this.points.length;i++){\r\n            this.points[i].cat=this.points[i].cat.toString()\r\n            this.points[i].shape=\"circle\"\r\n\r\n        }\r\n\r\n        // console.log(this.points)\r\n        let res=JSON.stringify(this.points)\r\n        this.jsonoutput.innerHTML=res\r\n        console.log(res)\r\n    }\r\n\r\n    addCategory(){\r\n        this.globalCategory+=1\r\n        this.nowCategory=this.globalCategory\r\n        console.log(this.globalCategory)\r\n    }\r\n\r\n    loadPoints(){\r\n        fetch('/data/savedDate.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.points=data\r\n                this.numOfPoints=this.points.length-1\r\n                let categories=[]\r\n\r\n                for (let i=0;i<this.points.length;i++){\r\n                    this.drawPoint(this.points[i].x,this.points[i].y,colors[this.points[i].cat],this.points[i].cat,i)\r\n                    if(categories.indexOf(this.points[i].cat)<0){\r\n                        categories.push(this.points[i].cat)\r\n                    }\r\n                }\r\n                this.globalCategory=categories.length-1\r\n                 this.nowCategory=this.globalCategory\r\n                console.log(this.points)\r\n            })\r\n    }\r\n\r\n    switchCategory(){\r\n        let cat=parseInt(this.input.value)\r\n        this.nowCategory=cat\r\n        // this.input.value=\"\"\r\n        console.log(cat)\r\n    }\r\n    changeWidthHeight(){\r\n        let wh=this.input2.value.split(\",\")\r\n        console.log(this.input.value)\r\n        let w=parseFloat(wh[0])\r\n        let h=parseFloat(wh[1])\r\n        this.width=w\r\n        this.height=h\r\n        // this.input.value=\"\"\r\n        console.log(w,h)\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <svg id={\"hacksvg\"} width={\"1000px\"} height={\"1000px\"} >\r\n                </svg>\r\n                <button onClick={this.addCategory.bind(this)}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"800px\"}}>Add Category</button>\r\n                <input ref={(input)=>this.input=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"750px\"}}></input>\r\n                <button onClick={this.switchCategory.bind(this)}  style={{width:200,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"750px\",marginLeft:10}}>Change Category</button>\r\n                <button onClick={this.savePoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"700px\",marginLeft:10}}>Save</button>\r\n                <button onClick={this.loadPoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"700px\",marginLeft:10}}>Load</button>\r\n                <input ref={(input)=>this.input2=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"650px\"}}></input>\r\n                <button onClick={this.changeWidthHeight.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"650px\",marginLeft:10}}>Change Width and Height</button>\r\n                <label ref={(jsonoutput)=>this.jsonoutput=jsonoutput} style={{width:300,height:200,fontSize:\"10px\",position:\"absolute\",left:\"1550px\",bottom:\"300px\",marginLeft:10,overflow:\"scroll\"}}>\r\n\r\n                </label>\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default DataHacker","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass CSVData extends Component{\r\n    constructor() {\r\n        super();\r\n        this.population=null\r\n        this.lifeExp=null\r\n        this.fertility=null\r\n        this.geoInfo=null\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.getPopulation()\r\n    }\r\n\r\n    getPopulation(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/population_total.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.population=data\r\n                console.log(\"population\")\r\n                console.log(that.population)\r\n                that.getLifeExpectancy()\r\n            })\r\n    }\r\n\r\n    getLifeExpectancy(){\r\n        let that=this\r\n        d3.csv(\"data/GapMinder/life_expectancy_years.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.lifeExp=data\r\n                console.log(\"lifeexp\")\r\n                console.log(that.lifeExp)\r\n                that.getFertility()\r\n            })\r\n    }\r\n\r\n    getFertility(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/children_per_woman_total_fertility.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.fertility=data\r\n                console.log(\"fertility\")\r\n                console.log(that.fertility)\r\n                that.getGroInfo()\r\n            })\r\n    }\r\n\r\n    getGroInfo(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/ddf--entities--geo--country.csv\",function(data){\r\n            return {\r\n                country:data.name,\r\n                value:data.worldregion\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.geoInfo=data\r\n                console.log(that.geoInfo)\r\n                that.dataFusion()\r\n            })\r\n    }\r\n\r\n    dataFusion(){\r\n        let datapoint=[]\r\n        let countrylist={}\r\n        let catnum=0\r\n        let catDict={}\r\n\r\n        for (let i=0;i<this.fertility.length;i++){\r\n            if(this.fertility[i].value==\"\"){\r\n                continue\r\n            }\r\n            let country=this.fertility[i].country\r\n            let hascat=false\r\n\r\n            for (let j=0;j<this.geoInfo.length;j++){\r\n                if(!catDict.hasOwnProperty(this.geoInfo[j].value)){\r\n                    catDict[this.geoInfo[j].value]=catnum\r\n                    catnum+=1\r\n                }\r\n                if(country==this.geoInfo[j].country){\r\n                    // datapoint[i].geo=this.geoInfo[j].value\r\n                    // datapoint[i].cat=catDict[this.geoInfo[j].value]\r\n                    hascat=true\r\n                    break\r\n                }\r\n            }\r\n            if(!hascat){\r\n                console.log(this.fertility[i].country)\r\n                continue\r\n            }\r\n            else{\r\n                datapoint.push({\r\n                    country:this.fertility[i].country,\r\n                    fertility:parseFloat(this.fertility[i].value)\r\n                })\r\n            }\r\n\r\n        }\r\n\r\n        for (let i=0;i<datapoint.length;i++){\r\n            let country=datapoint[i].country\r\n\r\n            for (let j=0;j<this.population.length;j++){\r\n                if(country==this.population[j].country){\r\n                    datapoint[i].population=parseInt(this.population[j].value)\r\n                    break\r\n                }\r\n            }\r\n            for (let j=0;j<this.lifeExp.length;j++){\r\n                if(country==this.lifeExp[j].country){\r\n                    datapoint[i].lifeExp=parseFloat(this.lifeExp[j].value)\r\n                    break\r\n                }\r\n            }\r\n            for (let j=0;j<this.geoInfo.length;j++){\r\n                if(country==this.geoInfo[j].country){\r\n                    datapoint[i].geo=this.geoInfo[j].value\r\n                    datapoint[i].cat=catDict[this.geoInfo[j].value]\r\n                    break\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n\r\n\r\n        this.data=datapoint\r\n        // console.log(JSON.stringify(datapoint))\r\n        console.log(datapoint)\r\n        this.drawScatterPlot()\r\n\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",5)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"circle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n\r\n        let xscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.fertility)})),d3.max(this.data.map((d)=>{return d.fertility}))])\r\n            .range([0,800])\r\n        let yscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.lifeExp)})),d3.max(this.data.map((d)=>{return d.lifeExp}))])\r\n            .range([1000,0])\r\n        let rscale=d3.scaleSqrt().domain([d3.min(this.data.map((d)=>{return d.population})),d3.max(this.data.map((d)=>{return d.population}))])\r\n            .range([3,20])\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(xscale(this.data[i].fertility),yscale(this.data[i].lifeExp),rscale(this.data[i].population),colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    getCSV(){\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    render(){\r\n        return (<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default CSVData","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass GapMinderNew extends  Component{\r\n    constructor() {\r\n        super();\r\n        this.population=[]\r\n        this.fertility=[]\r\n        this.lifeExp=[]\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        let that=this\r\n        d3.csv(\"data/GapMinder-new/population.csv\",function(data){\r\n            // console.log(data)\r\n                // console.log(data[i])\r\n                let country=data.Country\r\n                that.data.push({\r\n                    country:country,\r\n                    population:parseInt(data.Pop1985),\r\n                    fertility:parseFloat(data.F1985),\r\n                    lifeExp:parseFloat(data.L1985),\r\n                    geo:data.Group\r\n                })\r\n        }).then(function(data){\r\n            let catDict={}\r\n            let catnum=0\r\n            for (let i=0;i<that.data.length;i++){\r\n                if(!catDict.hasOwnProperty(that.data[i].geo)){\r\n                    catDict[that.data[i].geo]=catnum\r\n                    catnum++\r\n                }\r\n            }\r\n            for (let i=0;i<that.data.length;i++){\r\n                that.data[i].cat=catDict[that.data[i].geo]\r\n            }\r\n            console.log(that.data)\r\n            that.drawScatterPlot()\r\n\r\n        })\r\n\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n\r\n        let xscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.fertility)})),d3.max(this.data.map((d)=>{return d.fertility}))])\r\n            .range([50,900])\r\n        let yscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.lifeExp)})),d3.max(this.data.map((d)=>{return d.lifeExp}))])\r\n            .range([900,0])\r\n        let rscale=d3.scaleSqrt().domain([d3.min(this.data.map((d)=>{return d.population})),d3.max(this.data.map((d)=>{return d.population}))])\r\n            .range([5,20])\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(xscale(this.data[i].fertility),yscale(this.data[i].lifeExp),rscale(this.data[i].population),colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",r)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"circle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    render() {\r\n        return(<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default GapMinderNew","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#8701ec','#434343','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\n\r\n\r\nclass ManuallyTree extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n/*        let centerx=minx+(maxx-minx)/2\r\n        let centery=miny+(maxy-miny)/2\r\n        let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x+=move[0]\r\n            this.pointData[i].y+=move[1]\r\n        }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x-=this.minX-20\r\n            this.pointData[i].y-=this.minY-20\r\n        }*/\r\n    }\r\n\r\n    calEPS(){\r\n        POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                // this.calEPS()\r\n                // this.createGraph()\r\n                // this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                // this.drawEdges()\r\n                this.drawPointData()\r\n                // this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        console.log(this.edges)\r\n        d3.selectAll(\"line\").remove()\r\n        let that=this\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let node1=this.edges[i].start\r\n            let node2=this.edges[i].end\r\n\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[node1].x)\r\n                .attr(\"y1\",this.pointData[node1].y)\r\n                .attr(\"x2\",this.pointData[node2].x)\r\n                .attr(\"y2\",this.pointData[node2].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",i)\r\n                .on(\"click\",function(){\r\n                    let removeindex=d3.select(this).attr(\"index\")\r\n                    that.edges[removeindex].isdelete=true\r\n                    d3.select(this).remove()\r\n                    console.log(that.edges)\r\n                })\r\n        }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetEdge1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n        }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n                <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default ManuallyTree","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#ffcc99','#001aff','#c0c0c0','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass Example1 extends  Component{\r\n    constructor() {\r\n        super();\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        let that=this\r\n        d3.csv(\"data/GapMinder-new/ex1.csv\",function(data){\r\n            // console.log(data)\r\n            // console.log(data[i])\r\n            let country=data.Country\r\n            that.data.push({\r\n                x:parseInt(data.xfield),\r\n                y:parseFloat(data.yfield),\r\n                cat:data.cat\r\n            })\r\n        }).then(function(data){\r\n            console.log(that.data)\r\n            that.drawScatterPlot()\r\n\r\n        })\r\n\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(this.data[i].x,this.data[i].y,10,colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"rect\")\r\n            .attr(\"x\",x-r)\r\n            .attr(\"y\",y-r)\r\n            .attr(\"width\",r)\r\n            .attr(\"height\",r)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"rectangle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    render() {\r\n        return(<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default Example1","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#8701ec','#434343','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\nvar clustering = require('density-clustering');\r\n\r\n\r\nclass LocalCluster extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n    }\r\n\r\n    calEPS(){\r\n        // POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let dis=this.calDistance(this.pointData[i],this.pointData[j])\r\n                if(dis>maxDis){\r\n                    maxDis=dis\r\n                }\r\n            }\r\n        }\r\n        POINT_EDGE_EPS=maxDis*0.035\r\n/*                d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",POINT_EDGE_EPS)\r\n            .attr(\"cy\",POINT_EDGE_EPS)\r\n            .attr(\"r\",POINT_EDGE_EPS)\r\n            .attr(\"fill\",\"black\")*/\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                this.calEPS()\r\n                // this.findCluster()\r\n                this.createGraph()\r\n                this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                this.drawPointData()\r\n                // this.generateTreeWithHierarchical()\r\n                this.drawEdges()\r\n                this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n\r\n\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnectBetweenCluster(){\r\n        for(let k in this.clusterDict){\r\n            let start=this.clusterDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n            for (let i=1;i<this.clusterDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.clusterDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        console.log(this.edges)\r\n        d3.selectAll(\"line\").remove()\r\n        let that=this\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let node1=this.edges[i].start\r\n            let node2=this.edges[i].end\r\n\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[node1].x)\r\n                .attr(\"y1\",this.pointData[node1].y)\r\n                .attr(\"x2\",this.pointData[node2].x)\r\n                .attr(\"y2\",this.pointData[node2].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",i)\r\n                .on(\"click\",function(){\r\n                    let removeindex=d3.select(this).attr(\"index\")\r\n                    that.edges[removeindex].isdelete=true\r\n                    d3.select(this).remove()\r\n                    console.log(that.edges)\r\n                })\r\n        }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetEdge2.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                // .on(\"drag\",function(){\r\n                //     console.log(\"drag!\")\r\n                // })\r\n                .call(drag)\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                // .on(\"drag\",function(){\r\n                //     console.log(\"drag!\")\r\n                // })\r\n                .call(drag)\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    createLocalTree(points){\r\n        //1. find center point\r\n        //2. generate tree\r\n        let midx=0\r\n        let midy=0\r\n        for (let i=0;i<points.length;i++){\r\n            midx+=points[i].x\r\n            midy+=points[i].y\r\n        }\r\n        midx=midx/points.length\r\n        midy=midy/points.length\r\n        let midnode={\r\n            x:midx,\r\n            y:midy\r\n        }\r\n        let minDis=Number.MAX_VALUE\r\n        let minindex=-1\r\n        for (let i=0;i<points.length;i++){\r\n            let dis=this.calDistance(midnode,points[i])\r\n            if(dis<minDis){\r\n                minDis=dis\r\n                minindex=i\r\n            }\r\n        }\r\n\r\n\r\n\r\n        for (let i=0;i<points.length;i++){\r\n            if(i!=minindex){\r\n                this.edges.push({\r\n                    start:points[minindex].id,\r\n                    end:points[i].id,\r\n                })\r\n                this.graph.addEdge(points[minindex].id,points[i].id)\r\n            }\r\n        }\r\n\r\n        // console.log(this.edges)\r\n/*        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }*/\r\n\r\n    }\r\n\r\n    generateTreeWithHierarchical(){\r\n        this.findCluster()\r\n        this.createGraphWithCluster()\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                this.createLocalTree(this.clusterDict[k][i])\r\n            }\r\n        }\r\n\r\n        this.mergeCluster()\r\n    }\r\n\r\n    findCluster(){\r\n        for (var k in this.catPointDict){\r\n            console.log(k)\r\n            this.clusterDict[k]=[]\r\n            this.noiseDict[k]=[]\r\n            var dbscan = new clustering.DBSCAN();\r\n            let dataset=[]\r\n            let pointDataSet=[]\r\n// parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster\r\n\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n            }\r\n            // console.log(dataset)\r\n            // console.log(pointDataSet)\r\n            var clusters = dbscan.run(dataset, POINT_EDGE_EPS, 2);\r\n            console.log(clusters, dbscan.noise);\r\n            let point\r\n            for(let i=0;i<clusters.length;i++){\r\n                let clusterPoints=[]\r\n                for (let j=0;j<clusters[i].length;j++){\r\n                     clusterPoints.push(pointDataSet[clusters[i][j]])\r\n                    // console.log(point)\r\n/*                    let point=dataset[clusters[i][j]]\r\n                    d3.select(\"svg\")\r\n                        .append(\"circle\")\r\n                        .attr(\"cx\",point[0])\r\n                        .attr(\"cy\",point[1])\r\n                        .attr(\"r\",10)\r\n                        .attr(\"fill\",\"none\")\r\n                        .attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",2)*/\r\n                }\r\n                // this.createLocalTree(clusterPoints)\r\n                this.clusterDict[k].push(clusterPoints)\r\n            }\r\n            for (let i=0;i<dbscan.noise.length;i++){\r\n                this.clusterDict[k].push([pointDataSet[dbscan.noise[i]]])\r\n            }\r\n        }\r\n        console.log(this.clusterDict)\r\n        // console.log(this.noiseDict)\r\n    }\r\n\r\n    createGraphWithCluster(){\r\n        let clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n            }\r\n\r\n        }\r\n        this.clusterArr=clusterArr\r\n        console.log(this.clusterArr)\r\n        var g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        this.clustergraph=g\r\n\r\n        var g2 = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g2.V;i++){\r\n            g2.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g2\r\n    }\r\n\r\n    calClusterDistance(cluster1,cluster2){\r\n        let dissum=0\r\n        let num=0\r\n        let mindis=Number.MAX_VALUE\r\n        for(let i=0;i<cluster1.length;i++){\r\n            for (let j=0;j<cluster2.length;j++){\r\n                // dissum+=this.calDistance(cluster1[i],cluster2[j])\r\n                // num+=1\r\n                let dis=this.calDistance(cluster1[i],cluster2[j])\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                }\r\n            }\r\n        }\r\n        return mindis\r\n    }\r\n\r\n    sortEdgesGlobalWithCluster(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.clusterDict){\r\n            for(let i=0;i<this.clusterDict[k].length;i++){\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let dis=this.calClusterDistance(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    // let mess=this.calEdgeMess(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    disArray.push(dis)\r\n                    // messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    // tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                    tempedges.push([this.clusterDict[k][i].id,this.clusterDict[k][j].id,dis])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            // let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            // edges.push([start,end,weight,dis,mess])\r\n            edges.push([start,end,weight,dis])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    findLinkBetweenCluster(cluster1,cluster2){\r\n        let mindis=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                if(!this.checkNewEdge(start,end)){\r\n                    flag=true\r\n                    let dis=this.calDistance(start,end)\r\n                    if(dis<mindis){\r\n                        mindis=dis\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return [flag,minstart,minend,mindis]\r\n    }\r\n\r\n    findOptimalLink(cluster1,cluster2){\r\n        let mincrossnum=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                let crossnum=0\r\n\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n\r\n                }\r\n                if(crossnum<mincrossnum){\r\n                    mincrossnum=crossnum\r\n                    minstart=start\r\n                    minend=end\r\n                }\r\n                else if(crossnum==mincrossnum){\r\n                    let dis1=this.calDistance(minstart,minend)\r\n                    let dis2=this.calDistance(start,end)\r\n                    if(dis2<dis1){\r\n                        mincrossnum=crossnum\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return [minstart,minend,mincrossnum]\r\n    }\r\n\r\n    mergeCluster(){\r\n        //average distance as distance between clusters\r\n        //find an optimal link with least crossing\r\n\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithCluster()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            // let mess=sortedEdges[i][4]\r\n\r\n\r\n\r\n            if(this.clusterArr[start].cat!=this.clusterArr[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n\r\n                let link=this.findLinkBetweenCluster(this.clusterArr[start].points,this.clusterArr[end].points)\r\n\r\n                if(link[0]){\r\n                    this.clustergraph.addEdge(start,end)\r\n                    this.graph.addEdge(link[1].id,link[2].id)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:link[1].id,\r\n                        end:link[2].id,\r\n                        weight:link[3],\r\n                        dis:link[3],\r\n                        // mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        // mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n        // this.drawEdges()\r\n\r\n        while(!this.checkConnectBetweenCluster()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.findOptimalLink(this.clusterArr[start].points,this.clusterArr[end].points)\r\n                    removeEdggeList[i].weight=scores[3]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push({\r\n                        clusterstart:start,\r\n                        clusterend:end,\r\n                        start:scores[0].id,\r\n                        end:scores[1].id,\r\n                        weight:scores[2],\r\n                        crossnum:scores[2]\r\n                    })\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.clustergraph.addEdge(tempEdgeList[maxindex].clusterstart,tempEdgeList[maxindex].clusterend)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                // dis:tempEdgeList[maxindex].dis,\r\n                // mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // this.drawEdges()\r\n            console.log()\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n                <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default LocalCluster","import * as d3 from \"d3\";\r\n\r\nexport function add(a,b){\r\n    return a+b\r\n}\r\n\r\nexport function calDistance(x1,y1,x2,y2){\r\n    return Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2))\r\n}\r\n\r\nexport function getVecNorm(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    return norm\r\n}\r\n\r\nexport function normalizeVec(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    let newvec=[vec[0]/norm,vec[1]/norm]\r\n    return newvec\r\n}\r\n\r\nexport function drawCircle(x,y,r,fill,stroke){\r\n    d3.select(\"#mainsvg\")\r\n        .append(\"circle\")\r\n        .attr(\"class\",\"elespace\")\r\n        .attr(\"cx\",x)\r\n        .attr(\"cy\",y)\r\n        .attr(\"r\",r)\r\n        .attr(\"fill\",fill)\r\n        .attr(\"stroke\",stroke)\r\n        .attr(\"stroke-width\",1)\r\n}\r\n\r\nexport function drawRect(x,y,width,height,color){\r\n    d3.select(\"svg\")\r\n        .append(\"rect\")\r\n        .attr(\"x\",x-width/2)\r\n        .attr(\"y\",y-height/2)\r\n        .attr(\"width\",width)\r\n        .attr(\"height\",height)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",color)\r\n        .attr(\"stroke-width\",2)\r\n}\r\n\r\nexport function drawPolygon(points,dx,dy,color){\r\n    d3.select(\"svg\").append(\"path\")\r\n        .style(\"fill\", \"none\")\r\n        .style(\"stroke\",color)\r\n        .style(\"stroke-width\", 0.5)\r\n        .attr(\"d\", function () {\r\n            var p = \"\";\r\n            p += (d3.line()\r\n                    .x(function (dat) {\r\n                        return dat[0]+dx;\r\n                    })\r\n                    .y(function (dat) {\r\n                        return dat[1]+dy;\r\n                    })\r\n            )(points)+ \"\";\r\n            return p;\r\n        })\r\n        .on('mouseover', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"red\")\r\n                .style(\"stroke-width\", 2);\r\n        })\r\n        .on('mouseout', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"black\")\r\n                .style(\"stroke-width\", 0.5);\r\n        });\r\n}\r\nexport function drawLine(start,end,color,width){\r\n    d3.select(\"svg\").append(\"line\")\r\n        .attr(\"x1\",start[0])\r\n        .attr(\"y1\",start[1])\r\n        .attr(\"x2\",end[0])\r\n        .attr(\"y2\",end[1])\r\n        .attr(\"stroke-width\",width)\r\n        .attr(\"stroke\",color)\r\n        .on(\"mouseover\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",\"red\")\r\n        })\r\n        .on(\"mouseout\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",color)\r\n        })\r\n}\r\n\r\nexport function  isContained(catarr,cat){\r\n    catarr=catarr.split(\",\")\r\n    for(let i=0;i<catarr.length;i++){\r\n        if(catarr[i]==cat){\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nexport function  PointToSegDist( x,  y,  x1,  y1,  x2,  y2)\r\n{\r\n     let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n    // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n    if (cross <= 0) return -1\r\n\r\n     let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n    // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n    if (cross >= d2) return -1\r\n\r\n\r\n\r\n    let r = cross / d2;\r\n    let px = x1 + (x2 - x1) * r;\r\n    let py = y1 + (y2 - y1) * r;\r\n    return Math.sqrt((x - px) * (x - px) + (py - y) * (py - y));\r\n}\r\n\r\nfunction calLineCirclePoint(){\r\n    //ax+by+c=0\r\n}\r\n\r\nexport function calTanPoint(cx,cy,radius,point) {\r\n    //点到圆心的距离\r\n    let d = Math.sqrt(Math.pow(cx - point.x,2) + Math.pow(cy - point.y,2));\r\n    let vc1c2 = {x:point.x - cx,y:-point.y + cy}; //屏幕坐标系与笛卡尔坐标系是y轴是反着的\r\n    let radC1C2 = Math.acos(vc1c2.x / Math.sqrt(Math.pow(vc1c2.x,2) + Math.pow(vc1c2.y,2)));\r\n    let theta = Math.acos(radius/d);\r\n    if(point.y < cy){\r\n        let p1 = {x:cx + Math.cos(theta + radC1C2)*radius,y:cy - Math.sin(theta + radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(theta - radC1C2)*radius,y:cy + Math.sin(theta - radC1C2)*radius};\r\n        return {p1:p1,p2:p2};\r\n    }else{\r\n        radC1C2 = Math.PI - radC1C2;\r\n        let p1 = {x:cx + Math.cos(Math.PI - theta - radC1C2)*radius,y:cy + Math.sin(Math.PI - theta - radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(Math.PI - (theta - radC1C2))*radius,y:cy - Math.sin(Math.PI - (theta - radC1C2))*radius};\r\n        return {p1:p1,p2:p2};\r\n    }\r\n}\r\n\r\nexport function calCommonTanPoint(x1,y1,r1,x2,y2,r2){\r\n    let tanPoints=[]\r\n    let delta1=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1+r2,2)//+\r\n    let delta2=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1-r2,2)//-\r\n\r\n    let p1=r1*(x2*x2+y2*y2-x1*x2-y1*y2)\r\n    let p2=r2*(x1*x1+y1*y1-x1*x2-y1*y2)\r\n    let q=x1*y2-x2*y1\r\n\r\n    //four points\r\n    let vecpq=[x2-x1,y2-y1]\r\n    let normvec=[-vecpq[1],vecpq[0]]\r\n    let dir=normalizeVec(normvec)\r\n    let newpointp=[x1+r1*dir[0],y1+r1*dir[1]]\r\n    let newpointq=[x2+r2*dir[0],y2+r2*dir[1]]\r\n\r\n    tanPoints.push([newpointp,newpointq])\r\n\r\n    let dir2=[-1*dir[0],-1*dir[1]]\r\n    let newpointp2=[x1+r1*dir2[0],y1+r1*dir2[1]]\r\n    let newpointq2=[x2+r2*dir2[0],y2+r2*dir2[1]]\r\n\r\n    tanPoints.push([newpointp2,newpointq2])\r\n\r\n\r\n    if(delta1<0&&delta2<0){\r\n        return []\r\n    }\r\n    else if(delta1<0&&delta2>0){\r\n        //相交, just four points, two lines\r\n        return tanPoints\r\n    }\r\n    else if(delta1==0&&delta2>0){\r\n        //外切, five points, two lines\r\n        return tanPoints\r\n\r\n    }\r\n    else if(delta1>0&&delta2>0){\r\n        //外离, eight points, four lines\r\n        let intersecx=(r1*x2+r2*x1)/(r1+r2)\r\n        let intersecy=(r1*y2+r2*y1)/(r1+r2)\r\n        let tanpoints1=calTanPoint(x1,y1,r1,{x:intersecx,y:intersecy})\r\n        let tanpoints2=calTanPoint(x2,y2,r2,{x:intersecx,y:intersecy})\r\n\r\n        let p1=tanpoints1.p1\r\n        let p2={x:intersecx,y:intersecy}\r\n        let p3=tanpoints2.p1\r\n\r\n        let delta=(p3.y-p1.y)*(p2.x-p1.x)-(p2.y-p1.y)*(p3.x-p1.x)\r\n        if(Math.abs(delta)<=0.000001){\r\n            //p1p1\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n\r\n        }\r\n    else{\r\n        //p1p2\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n        }\r\n\r\n    return tanPoints\r\n\r\n    }\r\n\r\n    else{\r\n        return []\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nexport function drawArc(startp,endp,center,radius){\r\n    let pathstr=\"\"\r\n    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n    let largearcflag=0\r\n    let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n    let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n    let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n    if(crossmul>0){\r\n        largearcflag=1\r\n    }\r\n    else if(crossmul<=0){\r\n        largearcflag=0\r\n    }\r\n    pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n    d3.select(\"svg\")\r\n        .append(\"path\")\r\n        .attr(\"d\",pathstr)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",\"black\")\r\n        .attr(\"stroke-width\",\"1\")\r\n}\r\n\r\nexport function getDegreeTwoVec(vec1,vec2){\r\n    let norm1=getVecNorm(vec1)\r\n    let norm2=getVecNorm(vec2)\r\n    let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n\r\n    let cos=dot/(norm1*norm2)\r\n\r\n    return Math.acos(cos)\r\n\r\n}\r\n\r\nexport function rotatePoint(x,y,rx0,ry0,alpha){\r\n    let x0= (x - rx0)*Math.cos(alpha) - (y - ry0)*Math.sin(alpha) + rx0 ;\r\n    let y0= (x - rx0)*Math.sin(alpha) + (y - ry0)*Math.cos(alpha) + ry0 ;\r\n    return [x0,y0]\r\n}\r\n\r\nexport function crossMul(vec1,vec2){\r\n\r\n    return vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n}\r\n\r\nexport function clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}","var BSpline = function(points,degree,copy){\r\n    if(copy){\r\n        this.points = []\r\n        for(var i = 0;i<points.length;i++){\r\n            this.points.push(points[i]);\r\n        }\r\n    }else{\r\n        this.points = points;\r\n    }\r\n    this.degree = degree;\r\n    this.dimension = points[0].length;\r\n    if(degree == 2){\r\n        this.baseFunc = this.basisDeg2;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 3){\r\n        this.baseFunc = this.basisDeg3;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 4){\r\n        this.baseFunc = this.basisDeg4;\r\n        this.baseFuncRangeInt = 3;\r\n    }else if(degree == 5){\r\n        this.baseFunc = this.basisDeg5;\r\n        this.baseFuncRangeInt = 3;\r\n    } \r\n};\r\n\r\nBSpline.prototype.seqAt = function(dim){\r\n    var points = this.points;\r\n    var margin = this.degree + 1;\r\n    return function(n){\r\n        if(n < margin){\r\n            return points[0][dim];\r\n        }else if(points.length + margin <= n){\r\n            return points[points.length-1][dim];\r\n        }else{\r\n            return points[n-margin][dim];\r\n        }\r\n    };\r\n};\r\n\r\nBSpline.prototype.basisDeg2 = function(x){\r\n    if(-0.5 <= x && x < 0.5){\r\n        return 0.75 - x*x;\r\n    }else if(0.5 <= x && x <= 1.5){\r\n        return 1.125 + (-1.5 + x/2.0)*x;\r\n    }else if(-1.5 <= x && x < -0.5){\r\n        return 1.125 + (1.5 + x/2.0)*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg3 = function(x){\r\n    if(-1 <= x && x < 0){\r\n        return 2.0/3.0 + (-1.0 - x/2.0)*x*x;\r\n    }else if(1 <= x && x <= 2){\r\n        return 4.0/3.0 + x*(-2.0 + (1.0 - x/6.0)*x);\r\n    }else if(-2 <= x && x < -1){\r\n        return 4.0/3.0 + x*(2.0 + (1.0 + x/6.0)*x);\r\n    }else if(0 <= x && x < 1){\r\n        return 2.0/3.0 + (-1.0 + x/2.0)*x*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg4 = function(x){\r\n    if(-1.5 <= x && x < -0.5){\r\n        return 55.0/96.0 + x*(-(5.0/24.0) + x*(-(5.0/4.0) + (-(5.0/6.0) - x/6.0)*x));\r\n    }else if(0.5 <= x && x < 1.5){\r\n        return 55.0/96.0 + x*(5.0/24.0 + x*(-(5.0/4.0) + (5.0/6.0 - x/6.0)*x));\r\n    }else if(1.5 <= x && x <= 2.5){\r\n        return 625.0/384.0 + x*(-(125.0/48.0) + x*(25.0/16.0 + (-(5.0/12.0) + x/24.0)*x));\r\n    }else if(-2.5 <= x && x <= -1.5){\r\n        return 625.0/384.0 + x*(125.0/48.0 + x*(25.0/16.0 + (5.0/12.0 + x/24.0)*x));\r\n    }else if(-1.5 <= x && x < 1.5){\r\n        return 115.0/192.0 + x*x*(-(5.0/8.0) + x*x/4.0);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg5 = function(x){\r\n    if(-2 <= x && x < -1){\r\n        return 17.0/40.0 + x*(-(5.0/8.0) + x*(-(7.0/4.0) + x*(-(5.0/4.0) + (-(3.0/8.0) - x/24.0)*x)));\r\n    }else if(0 <= x && x < 1){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 - x/12.0)*x*x);\r\n    }else if(2 <= x && x <= 3){\r\n        return 81.0/40.0 + x*(-(27.0/8.0) + x*(9.0/4.0 + x*(-(3.0/4.0) + (1.0/8.0 - x/120.0)*x)));\r\n    }else if(-3 <= x && x < -2){\r\n        return 81.0/40.0 + x*(27.0/8.0 + x*(9.0/4.0 + x*(3.0/4.0 + (1.0/8.0 + x/120.0)*x)));\r\n    }else if(1 <= x && x < 2){\r\n        return 17.0/40.0 + x*(5.0/8.0 + x*(-(7.0/4.0) + x*(5.0/4.0 + (-(3.0/8.0) + x/24.0)*x)));\r\n    }else if(-1 <= x && x < 0){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 + x/12.0)*x*x);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.getInterpol = function(seq,t){\r\n    var f = this.baseFunc;\r\n    var rangeInt = this.baseFuncRangeInt;\r\n    var tInt = Math.floor(t);\r\n    var result = 0;\r\n    for(var i = tInt - rangeInt;i <= tInt + rangeInt;i++){\r\n        result += seq(i)*f(t-i);\r\n    }\r\n    return result;\r\n};\r\n\r\nBSpline.prototype.calcAt = function(t){\r\n    t = t*((this.degree+1)*2+this.points.length);//t must be in [0,1]\r\n    if(this.dimension == 2){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t)];\r\n    }else if(this.dimension == 3){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t),this.getInterpol(this.seqAt(2),t)];\r\n    }else{\r\n        var res = [];\r\n        for(var i = 0;i<this.dimension;i++){\r\n            res.push(this.getInterpol(this.seqAt(i),t));\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nexport default BSpline\r\n","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport { Slider, InputNumber, Row, Col } from 'antd';\r\nimport 'antd/dist/antd.css'; // or 'antd/dist/antd.less'\r\nimport { Button } from 'antd';\r\n\r\nimport * as d3 from \"d3\"\r\nimport {calDistance, drawRect, normalizeVec, drawPolygon, drawLine,PointToSegDist,getVecNorm} from \"./util\"\r\nimport {isoBandOptions} from \"marchingsquares/src/options\";\r\nimport {main} from \"d3/dist/package\";\r\n\r\nimport BSpline from \"./BSpline\";\r\n\r\nvar MarchingSquaresJS = require('marchingsquares');\r\nvar IsoInsideTest = require('point-in-polygon');\r\nvar AreaCal = require('2d-polygon-area');\r\n//barrier map:\r\n//1: inside the gap of a node\r\n//2: inside the gap of an edge\r\n//3. inside a node\r\n//4. inside an edge\r\n//5. inside the initial field of a node\r\n//6. inside the initial field of an edge\r\n\r\n// Note: X and Y attribute are all center point for both circle and rectangle!\r\n\r\nvar pointDataName=\"BubbleSetExample1.txt\"\r\nvar edgeDataName=\"BubbleSetEdge1.txt\"\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar buffer=10\r\n// var nodeR0=10\r\n// var nodeR1=20\r\n// var edgeR0=15\r\n// var edgeR1=20\r\nvar nodeR1=15\r\nvar nodeR0=nodeR1-5\r\n\r\nvar edgeR1=20\r\nvar edgeR0=edgeR1-5\r\n\r\n\r\nvar defaultEdgeWidth=5\r\nvar edgeWidth=5 //5-10\r\nvar itemEnergyShape=\"circle\"\r\nvar nodeWeight=1\r\nvar edgeWeight=1\r\nvar nodeNegWeight=-0.8\r\nvar edgeNegWeight=0\r\nvar barrierGap=3\r\nvar intervals = [0.001]\r\nvar pixelGroup = 2\r\nvar gapBetween=1\r\nvar fixdis = Math.sqrt(0.25 * (pixelGroup - 1) * (pixelGroup - 1) + 0.25 * (pixelGroup - 1) * (pixelGroup - 1))\r\nvar control_points={}\r\nvar initialControlPoints={}\r\nvar is_selected={}\r\nvar eps = 1e-10\r\nvar move_points = []\r\nvar mid_point = 0\r\nvar nearpts = []\r\nvar svg;\r\nvar g;\r\nvar hasChangeView = false;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\nvar prepoints = []\r\n\r\nvar svgwidth = 2000\r\nvar svgheight = 2000\r\nvar skipPoint = 10\r\nvar minItemArea = Number.MAX_VALUE\r\n\r\nvar editSeg = {}\r\nvar recalNum = 0\r\nvar recal = false\r\nvar remove_Polys = {}\r\n\r\nvar lineFunction = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveBasisClosed);\r\n\r\nvar lineFunction_reDraw = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveCardinal);\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//d3.select(\"svg\")\r\nclass AdaptiveIsovalue extends  Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n        edges: PropTypes.array\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[],\r\n        edges:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            nodeR0: 10,\r\n            nodeR1: 20,\r\n            edgeR0: 15,\r\n            edgeR1: 20,\r\n            pixelGroup: 3,\r\n            gapBetween:1,\r\n            edgeWidth: defaultEdgeWidth,\r\n            hasSelectEdge:false\r\n        }\r\n        this.isfirstcreate=true\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.edgeControlPoints=[]\r\n        this.hasMST=false\r\n        this.updateIdx = []\r\n        this.hasBubbles = false\r\n        this.firstFlag = true\r\n    }\r\n\r\n    init(){\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.updateIdx = []\r\n        this.firstFlag = true\r\n    }\r\n\r\n    init_all(){\r\n\r\n        colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        buffer=10\r\n        nodeR1=15\r\n        nodeR0=nodeR1-5\r\n        edgeR1=20\r\n        edgeR0=edgeR1-5\r\n        defaultEdgeWidth=5\r\n        edgeWidth=5\r\n        itemEnergyShape=\"circle\"\r\n        nodeWeight=1\r\n        edgeWeight=1\r\n        nodeNegWeight=-0.8\r\n        edgeNegWeight=0\r\n        barrierGap=3\r\n        intervals = [0.001]\r\n        pixelGroup = 2\r\n        gapBetween=1\r\n        fixdis = Math.sqrt(0.25 * (pixelGroup - 1) * (pixelGroup - 1) + 0.25 * (pixelGroup - 1) * (pixelGroup - 1))\r\n        control_points={}\r\n        initialControlPoints={}\r\n        is_selected={}\r\n        eps = 1e-10\r\n        move_points = []\r\n        mid_point = 0\r\n        nearpts = []\r\n        hasChangeView = false;\r\n        prepoints = []\r\n        svgwidth = 2000\r\n        svgheight = 2000\r\n        skipPoint = 10\r\n        minItemArea = Number.MAX_VALUE\r\n        editSeg = {}\r\n        recalNum = 0\r\n        recal = false\r\n        remove_Polys = {}\r\n\r\n        this.setState({\r\n            nodeR0: 10,\r\n            nodeR1: 20,\r\n            edgeR0: 15,\r\n            edgeR1: 20,\r\n            pixelGroup: 3,\r\n            gapBetween:1,\r\n            edgeWidth: defaultEdgeWidth,\r\n            hasSelectEdge:false\r\n        })\r\n        this.isfirstcreate=true\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.edgeControlPoints=[]\r\n        this.hasMST=false\r\n        this.updateIdx = []\r\n        this.hasBubbles = false\r\n        this.firstFlag = true\r\n\r\n        this.render()\r\n        this.componentDidMount()\r\n\r\n    }\r\n\r\n    bubbleState(){\r\n        return this.hasBubbles\r\n    }\r\n\r\n    setViewBox(X, Y, Width, Height){\r\n        X = offsetX\r\n        Y = offsetY\r\n        Width = viewWidth\r\n        Height = viewHeight\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n        //let svg = d3.select(\"svg\");\r\n\r\n\r\n        //this.getData()\r\n    }\r\n\r\n    preProcessPoints(points, pdict){\r\n        for(let i = 0;i < points.length; i ++){\r\n            let tmp\r\n            if(points[i].flag == true){\r\n                tmp = this.pointData[points[i].id]\r\n                tmp.flag = true\r\n            }\r\n            else{\r\n                tmp = points[i]\r\n            }\r\n            for (let c = 0;c < tmp.catArray.length; c ++){\r\n                let nowcat = tmp.catArray[c]\r\n                if(!pdict.hasOwnProperty(nowcat)){\r\n                    pdict[nowcat] = []\r\n                }\r\n                pdict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    preProcessEdges(edges, edict, filledges){\r\n        //console.log(\"preProcessEdges\")\r\n        //console.log(edges)\r\n        //console.log(this.edges)\r\n        for(let i = 0;i < edges.length; i ++){\r\n            let tmp\r\n            let catarr\r\n            if(edges[i].flag == true){\r\n                tmp = this.edges[edges[i].id]\r\n                tmp.flag = true\r\n                catarr = this.pointData[tmp.start].catArray\r\n                filledges.push(tmp)\r\n            }\r\n            else{\r\n                tmp = edges[i]\r\n                catarr = tmp.startpoint.catArray\r\n            }\r\n            for (let c = 0;c < catarr.length; c ++){\r\n                let nowcat = catarr[c]\r\n                if(!edict.hasOwnProperty(nowcat)){\r\n                    edict[nowcat] = []\r\n                }\r\n                edict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    editReDraw(editPoints, editEdges, HpointData, Hedges){\r\n\r\n        //console.log(\"editReDraw:\")\r\n        //console.log(editEdges)\r\n\r\n        console.time(\"Total Time\")\r\n\r\n        let tmpedges = clone(this.edges)\r\n        //console.log(\"Before:\")\r\n        //console.log(tmpedges)\r\n\r\n        this.pointData = HpointData\r\n        this.edges = Hedges\r\n        this.catPointDict = {}\r\n        this.catEdgeDict = {}\r\n        this.updateIdx = []\r\n        this.itemShape = this.pointData[0].shape\r\n\r\n        for (let i = 0; i < this.pointData.length; i++) {\r\n            this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id = i\r\n            this.pointData[i].cat = this.pointData[i].cat.toString()\r\n            let cats = this.pointData[i].cat.split(\",\")\r\n            let catarray = []\r\n            if (cats.length > 1) {\r\n                this.pointData[i].multicat = true\r\n                for (let c = 0; c < cats.length; c++) {\r\n                    catarray.push(cats[c])\r\n                }\r\n            } else {\r\n                this.pointData[i].multicat = false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray = catarray\r\n        }\r\n\r\n        this.centralizeData(false)\r\n\r\n        this.calEdgeLength()\r\n\r\n        this.calActiveRegion(false)\r\n\r\n        let updatePoints = {}\r\n        let updateEdges = {}\r\n        let filledges = []\r\n\r\n        this.preProcessPoints(editPoints, updatePoints)\r\n        this.preProcessEdges(editEdges, updateEdges, filledges)\r\n\r\n        //console.log(\"After:\")\r\n        //console.log(this.edges)\r\n        //console.log(\"Update Edges:\")\r\n        //console.log(updateEdges)\r\n\r\n        //console.log(\"update info:\")\r\n        //console.log(updatePoints)\r\n        //console.log(updateEdges)\r\n\r\n        console.time(\"cal energy field\")\r\n        //this.calEnergyField()\r\n        this.calEnergyField_Part(updatePoints, updateEdges)\r\n        console.timeEnd(\"cal energy field\")\r\n\r\n        //d3.selectAll(\"rect\").remove()\r\n        //for(let k in this.catEnergyField){\r\n            //this.drawEnergyField(\"0\")\r\n        //}\r\n\r\n        console.time(\"cal final energy field\")\r\n        //this.calFinalEnergeField()\r\n        //d3.selectAll(\"#final\").remove()\r\n        this.calFinalEnergeField_Part()\r\n        console.timeEnd(\"cal final energy field\")\r\n\r\n        console.time(\"fill cross edge\")\r\n        this.fillCrossingEdge_Part(filledges)\r\n        console.timeEnd(\"fill cross edge\")\r\n\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        d3.selectAll(\"path\").remove()\r\n        //d3.selectAll(\"rect\").remove()\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        //this.drawEdges()\r\n//\r\n        //this.drawPointData()\r\n\r\n\r\n\r\n        console.timeEnd(\"Total Time\")\r\n\r\n        let that=this\r\n        function handleSvgClick(){\r\n            console.log(\"click svg!\")\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n\r\n\r\n    }\r\n\r\n    getData(){\r\n        //let that=this\r\n        //fetch('/data/'+pointDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n            //.then(res=>res.json())\r\n            //.then(data=>{\r\n        if(this.props.pointData && this.props.edges) {\r\n            if(this.props.edges.length > 0){\r\n                this.hasMST = true;\r\n            }\r\n            this.init();\r\n            if(this.hasMST == false){\r\n                let tmp = this.props.createMST()\r\n                this.pointData = tmp[0]\r\n                this.edges = tmp[1]\r\n                colors = tmp[2]\r\n                this.hasMST = true;\r\n            }\r\n            else{\r\n                this.pointData = this.props.pointData\r\n                this.edges = this.props.edges\r\n            }\r\n            //console.log(\"Draw Bubbles\")\r\n            //console.log(this.pointData)\r\n            //console.log(this.edges)\r\n            this.itemShape = this.pointData[0].shape\r\n            for (let i = 0; i < this.pointData.length; i++) {\r\n                this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n                this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n                this.pointData[i].id = i\r\n                this.pointData[i].cat = this.pointData[i].cat.toString()\r\n\r\n                if(this.pointData[i].hasOwnProperty(\"radius\")){\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].radius * this.pointData[i].radius * Math.PI)\r\n                }\r\n                else{\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].width * this.pointData[i].width)\r\n                }\r\n\r\n                let cats = this.pointData[i].cat.split(\",\")\r\n                let catarray = []\r\n                if (cats.length > 1) {\r\n                    this.pointData[i].multicat = true\r\n                    for (let c = 0; c < cats.length; c++) {\r\n                        catarray.push(cats[c])\r\n                    }\r\n                } else {\r\n                    this.pointData[i].multicat = false\r\n                    catarray.push(this.pointData[i].cat)\r\n                }\r\n                this.pointData[i].catArray = catarray\r\n            }\r\n\r\n            this.loadEdgeData()\r\n            if(this.props.handleCreated){\r\n                this.props.handleCreated()\r\n            }\r\n        }\r\n            //})\r\n\r\n    }\r\n\r\n\r\n\r\n    centralizeData(ViewFlag){\r\n        this.minX=Number.MAX_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.maxX=Number.MIN_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            //this.pointData[i].isGroup=true;\r\n            if(itemEnergyShape==\"circle\"){\r\n                if(this.itemShape==\"rectangle\"){\r\n                    let r=Math.sqrt(Math.pow(this.pointData[i].width,2)+Math.pow(this.pointData[i].height,2))/2\r\n                    this.pointData[i].radius=r\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].radius\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].radius\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].radius\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].radius\r\n\r\n            }\r\n            else if(itemEnergyShape==\"rectangle\"){\r\n                if(this.itemShape==\"circle\"){\r\n                    this.pointData[i].width=this.pointData[i].radius*2\r\n                    this.pointData[i].height=this.pointData[i].radius*2\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].width/2\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].width/2\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].height/2\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].height/2\r\n\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,this.pointData[i].maxX)\r\n            this.maxY=Math.max(this.maxY,this.pointData[i].maxY)\r\n            this.minX=Math.min(this.minX,this.pointData[i].minX)\r\n            this.minY=Math.min(this.minY,this.pointData[i].minY)\r\n\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                    this.catPointDict[nowcat].minX = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxX = Number.MIN_VALUE\r\n                    this.catPointDict[nowcat].minY = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxY = Number.MIN_VALUE\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,this.pointData[i].minX)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,this.pointData[i].maxX)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,this.pointData[i].minY)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,this.pointData[i].maxY)\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let catarr=this.pointData[start].catArray\r\n\r\n            let minx=Math.min(this.pointData[start].x,this.pointData[end].x)\r\n            let miny=Math.min(this.pointData[start].y,this.pointData[end].y)\r\n            let maxx=Math.max(this.pointData[start].x,this.pointData[end].x)\r\n            let maxy=Math.max(this.pointData[start].y,this.pointData[end].y)\r\n\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                for (let p=0;p<vpoints.length;p++){\r\n                    let x=vpoints[p][0]\r\n                    let y=vpoints[p][1]\r\n                    minx=Math.min(minx,x)\r\n                    miny=Math.min(miny,y)\r\n                    maxx=Math.max(maxx,x)\r\n                    maxy=Math.max(maxy,y)\r\n                }\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,maxx)\r\n            this.maxY=Math.max(this.maxY,maxy)\r\n            this.minX=Math.min(this.minX,minx)\r\n            this.minY=Math.min(this.minY,miny)\r\n\r\n            this.edges[i].x=minx\r\n            this.edges[i].y=miny\r\n            this.edges[i].width=maxx-minx\r\n            this.edges[i].height=maxy-miny\r\n\r\n            //this.edges[i].isGroup=true;\r\n\r\n            for (let c=0;c<catarr.length;c++){\r\n                // let catarr=this.pointData[this.edges[i].start].catArray\r\n                let nowcat=catarr[c]\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,minx)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,maxx)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,miny)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,maxy)\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat=this.edges[i].cat\r\n            if(!this.catEdgeDict.hasOwnProperty(cat)){\r\n                this.catEdgeDict[cat]=[]\r\n            }\r\n            this.catEdgeDict[cat].push(this.edges[i])\r\n\r\n        }\r\n        //console.log(this.catEdgeDict)\r\n\r\n        if(ViewFlag){\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n////\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n//\r\n            d3.selectAll('g').attr(\"transform\",\"\");\r\n        }\r\n\r\n\r\n        if(hasChangeView == false){\r\n            offsetX = this.minX-Math.max(nodeR1,edgeR1)-buffer-10\r\n            offsetY = this.minY-Math.max(nodeR1,edgeR1)-buffer-10\r\n            viewWidth = this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            viewHeight = this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            hasChangeView = true\r\n        }\r\n\r\n    }\r\n\r\n\r\n    drawPointData(){\r\n        colors = this.props.colorArray\r\n        // d3.select(\"svg\").selectAll(\"*\").remove();\r\n        svg = d3.select('svg');\r\n\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let items=[]\r\n\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"circle\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    \"id\":items[i].getAttribute(\"index\"),\r\n                    \"bbox\":items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"rect\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    isInEdgeRange(x,y,start,end){\r\n        let x1=start.x\r\n        let y1=start.y\r\n        let x2=end.x\r\n        let y2=end.y\r\n\r\n        let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n        // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n        if (cross <= 0) return false\r\n\r\n        let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n        // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n        if (cross >= d2) return false\r\n\r\n        return true\r\n    }\r\n\r\n    calEdgeControlPoints(){\r\n        function sortArr(a,b){\r\n            return a.avgdis-b.avgdis\r\n        }\r\n        this.edgeControlPoints=[]\r\n        let tempcontrolpoints=[]\r\n        for(let i=0;i<this.edges.length;i++){\r\n            this.edgeControlPoints.push([])\r\n            tempcontrolpoints.push([])\r\n        }\r\n        for (var k in control_points){\r\n            for (let n=0;n<control_points[k].length;n++){\r\n                let controlpoints=control_points[k][n]\r\n                for(let i=0;i<controlpoints.length;i++){\r\n                    let minDis=Number.MAX_VALUE\r\n                    let minindex=-1\r\n                    for(let e=0;e<this.edges.length;e++){\r\n                        let edge=this.edges[e]\r\n                        if(edge.cat!=k){\r\n                            continue\r\n                        }\r\n                        let start=this.pointData[edge.start]\r\n                        let end=this.pointData[edge.end]\r\n                        let dis=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n                        if(dis>0){\r\n                            if(dis<minDis){\r\n                                minDis=dis\r\n                                minindex=e\r\n                            }\r\n                        }\r\n                    }\r\n                    if(minindex>=0){\r\n                        tempcontrolpoints[minindex].push({\r\n                            order:n,\r\n                            index:i,\r\n                            dis:minDis\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        // console.log(tempcontrolpoints[153])\r\n\r\n        for(let i=0;i<tempcontrolpoints.length;i++){\r\n            let iscontinue=false\r\n            let temppoints=[]\r\n            for(let j=1;j<tempcontrolpoints[i].length;j++){\r\n                let lastindex=tempcontrolpoints[i][j-1].index\r\n                let index=tempcontrolpoints[i][j].index\r\n                if(index-lastindex==1){\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                    else{\r\n                        iscontinue=true\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                }\r\n                else{\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                        iscontinue=false\r\n\r\n                        this.edgeControlPoints[i].push(temppoints)\r\n\r\n                        temppoints=[]\r\n                    }\r\n                    else{\r\n\r\n                    }\r\n                }\r\n            }\r\n            if(iscontinue){\r\n                temppoints.push(tempcontrolpoints[i][tempcontrolpoints[i].length-1])\r\n                this.edgeControlPoints[i].push(temppoints)\r\n            }\r\n        }\r\n        console.log(this.edgeControlPoints)\r\n\r\n        for (let i=0;i<this.edgeControlPoints.length;i++){\r\n            if(this.edgeControlPoints[i].length>2){\r\n                for (let j=0;j<this.edgeControlPoints[i].length;j++){\r\n                    let avgdis=0\r\n                    for (let p=0;p<this.edgeControlPoints[i][j].length;p++){\r\n                        avgdis+=this.edgeControlPoints[i][j][p].dis\r\n                    }\r\n                    avgdis=avgdis/this.edgeControlPoints[i][j].length\r\n                    this.edgeControlPoints[i][j].avgdis=avgdis\r\n                }\r\n                this.edgeControlPoints[i].sort(sortArr)\r\n                let tmp=[this.edgeControlPoints[i][0],this.edgeControlPoints[i][1]]\r\n                this.edgeControlPoints[i]=tmp\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    changeEdgeWidth(index,width){\r\n        let dw=width-defaultEdgeWidth\r\n        dw=dw*1.5\r\n        // console.log(width,dw)\r\n        //recalculate energy field\r\n/*        let i=index\r\n        let edges=this.edges\r\n        let k=edges[index].cat\r\n        let controlpoints=control_points[k]\r\n        let start=this.pointData[edges[index].start]\r\n        let end=this.pointData[edges[index].end]\r\n        let distances=[]\r\n        for (let i=0;i<controlpoints.length;i++){\r\n            let distoedge=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n            distances.push(distoedge)\r\n        }\r\n\r\n        let iscontinue=false\r\n        let temppoints={\r\n            points:[],\r\n            dis:0\r\n        }\r\n        let potentialPoints=[]\r\n        for(let i=0;i<distances.length;i++){\r\n            if(distances[i]>=0){\r\n                if(iscontinue){\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n                else{\r\n                    iscontinue=true\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n            }\r\n            else{\r\n                if(iscontinue){\r\n                    if(temppoints.points.length>1){\r\n                        temppoints.dis=temppoints.dis/temppoints.points.length\r\n                        potentialPoints.push(temppoints)\r\n                    }\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    iscontinue=false\r\n                }\r\n                else{\r\n\r\n                }\r\n            }\r\n        }\r\n        for(let i=0;i<potentialPoints.length;i++){\r\n            for(let p=0;p<potentialPoints[i].points.length;p++){\r\n                let point=controlpoints[potentialPoints[i].points[p]]\r\n                drawRect(point[0],point[1],1,1,\"red\")\r\n            }\r\n        }\r\n        console.log(potentialPoints)*/\r\n        let k=this.edges[index].cat\r\n        let start=this.pointData[this.edges[index].start]\r\n        let end=this.pointData[this.edges[index].end]\r\n        let dir=[end.x-start.x,end.y-start.y]\r\n\r\n        let norm=[-dir[1],dir[0]]\r\n        norm=normalizeVec(norm)\r\n\r\n        // drawLine([start.x,start.y],[start.x+50*norm[0],start.y+50*norm[1]],\"red\")\r\n\r\n        //console.log(\"changEdgeWidth:\")\r\n        //console.log(this.edgeControlPoints)\r\n\r\n        let controlpoints=this.edgeControlPoints[index]\r\n            let firstOutline=controlpoints[0]\r\n            let secondOutline=controlpoints[1]\r\n            let p1=control_points[k][firstOutline[0].order][firstOutline[0].index]\r\n            let vec1=[p1[0]-start.x,p1[1]-start.y]\r\n            let dot=vec1[0]*norm[0]+vec1[1]*norm[1]\r\n\r\n            let firstMidpoint=firstOutline.length/2\r\n            let secondMidpoint=secondOutline.length/2\r\n\r\n            if(dot>0){\r\n                //same direction with firstOutline\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n\r\n            }\r\n            else{\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n            }\r\n\r\n            //apply changes to energy field\r\n\r\n\r\n\r\n        let drawPathData=\"\";\r\n        for(let j = 0;j < control_points[k].length; j ++){\r\n            drawPathData += lineFunction(control_points[k][j]);\r\n        }\r\n        this.reDraw(k,this,drawPathData)\r\n\r\n\r\n    }\r\n\r\n    handleEdgeWidth(event, element){\r\n        event.stopPropagation()\r\n        let that = this\r\n        that.selectedEdge=parseInt(d3.select(element).attr(\"index\"))\r\n        that.setState({\r\n            hasSelectEdge:true\r\n        })\r\n        d3.select(\"svg\").selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(element).attr(\"index\"))==that.selectedEdge\r\n            })\r\n            .attr(\"stroke\",\"red\")\r\n            .attr(\"opacity\",1)\r\n    }\r\n\r\n    drawEdges(){\r\n        d3.select(\"#mainsvg\").selectAll(\"line\").remove()\r\n        let that=this\r\n\r\n        function handleClick(event){\r\n            event.stopPropagation()\r\n            that.selectedEdge=parseInt(d3.select(this).attr(\"index\"))\r\n            that.setState({\r\n                hasSelectEdge:true\r\n            })\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",1)\r\n        }\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                let vend\r\n                for (let v=0;v<vpoints.length;v++){\r\n                    vend=vpoints[v]\r\n                    g.append(\"line\")\r\n                        .attr(\"x1\",vstart[0])\r\n                        .attr(\"y1\",vstart[1])\r\n                        .attr(\"x2\",vend[0])\r\n                        .attr(\"y2\",vend[1])\r\n                        .attr(\"index\",index)\r\n                        .attr(\"stroke-width\",3)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"opacity\",0)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",1)\r\n                        })\r\n                        .on(\"mouseout\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",0)\r\n                        })\r\n                        .on(\"click\",handleClick)\r\n                    vstart=vend\r\n                }\r\n                vend=[this.pointData[end].x,this.pointData[end].y]\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n            else{\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",this.pointData[start].x)\r\n                    .attr(\"y1\",this.pointData[start].y)\r\n                    .attr(\"x2\",this.pointData[end].x)\r\n                    .attr(\"y2\",this.pointData[end].y)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    calEdgeLength(){\r\n        let minlength=Number.MAX_VALUE\r\n        let maxlength=Number.MIN_VALUE\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let startpoint=this.pointData[this.edges[i].start]\r\n            let endpoint=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vpoint=this.edges[i].virtrualNodes\r\n                let nowp\r\n                let nextp\r\n                let edgelength=0\r\n                nowp=[startpoint.x,startpoint.y]\r\n                for (let i=0;i<vpoint.length;i++){\r\n                    nextp=vpoint[i]\r\n                    edgelength+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                    nowp=nextp\r\n                }\r\n                edgelength+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let edgelength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n        this.maxEdgeLength=maxlength\r\n        this.minEdgeLength=minlength\r\n\r\n    }\r\n\r\n    componentWillUpdate(nextProps, nextState, nextContext) {\r\n    }\r\n\r\n    findOutLine(){\r\n        for (var k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n        intervals=[0.01]\r\n        console.time(\"isoline\")\r\n\r\n        // total field to active region\r\n        let fieldData = {}\r\n        for(var k in this.catEnergyField){\r\n            fieldData[k] = []\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let i = 0\r\n            for(let y = startY; y < endY; y ++){\r\n                fieldData[k].push([])\r\n                for(let x = startX; x < endX; x ++){\r\n                    fieldData[k][i].push(this.catEnergyField[k].finalField[y][x])\r\n                }\r\n                i ++\r\n            }\r\n        }\r\n\r\n        let isoDict=this.calISOLine(intervals, fieldData)\r\n\r\n        //console.log(isoDict)\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {};\r\n\r\n\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].boundingX\r\n            let dy=this.catEnergyField[k].boundingY\r\n            let prelength = 0\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                let sk = skipPoint\r\n                if(isoDict[k][i].length < 30){\r\n                    //continue;\r\n                }\r\n                if(isoDict[k][i].length < 50){\r\n                    //sk = 1\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n\r\n                    if(prelength==0){\r\n                        tmp_polygon[k].selectidx = []\r\n                        control_points[k] = []\r\n                    }\r\n\r\n                    tmp_polygon[k].selectidx.push(tmp_polygon[k].length - 1)\r\n\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n\r\n                    let curlen = control_points[k].length\r\n                    control_points[k][curlen] = [];\r\n                    control_points[k][curlen] = polygon;\r\n\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                    prelength ++\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        console.timeEnd(\"isoline\")\r\n\r\n        console.time(\"remove isoline\")\r\n        //console.log(tmp_polygon)\r\n\r\n        for(let k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k] = []\r\n        }\r\n\r\n\r\n        //remove_Polys = {}\r\n\r\n        for(var k in isoDict){\r\n            //let dx=this.catEnergyField[k].boundingX\r\n            //let dy=this.catEnergyField[k].boundingY\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                let isthis = false\r\n                for(let j = 0;j < sidx.length; j ++){\r\n                    if(i == sidx[j]){\r\n                        isthis = true\r\n                        break\r\n                    }\r\n                }\r\n                if(isthis){\r\n                    continue\r\n                }\r\n                let flag = true;\r\n                for(let p = 0; p < sidx.length; p ++){\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx[p]]);\r\n                        if(flag == false){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n\r\n                    if(AreaCal(tmp_polygon[k][i]) < minItemArea){\r\n                        continue\r\n                    }\r\n\r\n                    let st_idx = 0\r\n                    let pt_len = tmp_polygon[k][i].length\r\n                    let j_pt = [-1,-1]\r\n                    while(st_idx < pt_len){\r\n                        let idx1 = (st_idx - 1 + pt_len) % pt_len\r\n                        let idx2 = (st_idx + 1) % pt_len\r\n                        let ve1 = [tmp_polygon[k][i][idx1][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx1][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve2 = [tmp_polygon[k][i][idx2][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx2][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve3 = [ve1[0] + ve2[0], ve1[1] + ve2[1]]\r\n                        let ve3_len = Math.sqrt(ve3[0] * ve3[0] + ve3[1] * ve3[1])\r\n                        if(ve3_len != 0){\r\n                            ve3 = [ve3[0] / ve3_len, ve3[1] / ve3_len]\r\n                        }\r\n                        let test_pt = [tmp_polygon[k][i][st_idx][0] + 2 * ve3[0], tmp_polygon[k][i][st_idx][1] + 2 * ve3[1]]\r\n                        if(IsoInsideTest(test_pt, tmp_polygon[k][i])){\r\n                            j_pt = [test_pt[0], test_pt[1]]\r\n                            break;\r\n                        }\r\n                        st_idx ++\r\n                    }\r\n\r\n                    let is_use_inner = true\r\n\r\n                    if(j_pt[0] != -1 && j_pt[1] != -1){\r\n                        //if(k==\"2\"){\r\n                        //  g.append(\"circle\")\r\n                        //      .attr(\"cx\",j_pt[0])\r\n                        //      .attr(\"cy\",j_pt[1])\r\n                        //      .attr(\"r\",3)\r\n                        //      .attr(\"fill\",\"black\")\r\n//\r\n                        //}\r\n\r\n                        let j_y = parseInt((j_pt[1] -this.catEnergyField[k].y) / pixelGroup)\r\n                        let j_x = parseInt((j_pt[0] -this.catEnergyField[k].x) / pixelGroup)\r\n                        //if(k==\"2\"){\r\n                        //    console.log(\"inner outline!\")\r\n                        //    console.log(\"(\" + j_pt[0] + \", \" + j_pt[1] + \")\")\r\n                        //    console.log(this.catEnergyField[\"2\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].edgeIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].edgeIndexMap[j_y][j_x])\r\n                        //}\r\n                        //console.log(\"inner outline!\")\r\n                        //console.log(this.catEnergyField[k].field[j_y][j_x])\r\n                        //console.log(this.catEnergyField[k].finalField[j_y][j_x])\r\n                        if(this.catEnergyField[k].finalField[j_y][j_x] > 0.01){\r\n                            is_use_inner = false\r\n                        }\r\n                    }\r\n\r\n                    if(!is_use_inner){\r\n                        continue\r\n                    }\r\n\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n                /*\r\n                else{\r\n                    recal = true\r\n                    if(!remove_Polys.hasOwnProperty(k)){\r\n                        remove_Polys[k] = []\r\n                    }\r\n                    let tmp_polygon = []\r\n                    let sub_polygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j ++){\r\n                        let realx = isoDict[k][i][j][0]*pixelGroup + dx\r\n                        let realy = isoDict[k][i][j][1]*pixelGroup + dy\r\n                        sub_polygon.push([realx, realy])\r\n                        let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                        let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n                        tmp_polygon.push([x, y])\r\n                    }\r\n                    remove_Polys[k].push(tmp_polygon)\r\n                    this.fillPolygon(sub_polygon, k, 0, true)\r\n                }\r\n\r\n                 */\r\n            }\r\n        }\r\n        console.timeEnd(\"remove isoline\")\r\n\r\n    }\r\n\r\n    calOutLine(){\r\n\r\n        //if(recal && recalNum == 0){\r\n        //    recalNum += 1\r\n        //    for(let k in remove_Polys){\r\n        //        this.recalFinalEnergeField(k)\r\n        //    }\r\n        //}\r\n//\r\n        //if(this.firstFlag){\r\n        //    this.firstFlag = false\r\n        //    this.createGapInBoundary()\r\n        //}\r\n\r\n\r\n        //this.findOutLine()\r\n\r\n        let path_Info = {}\r\n\r\n        for(var k in this.catEnergyField){\r\n            path_Info[k] = []\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                path_Info[k].push(lineFunction(control_points[k][i]))\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        console.log(\"path_info!!!\")\r\n        console.log(JSON.stringify(path_Info))\r\n\r\n        for (var k in control_points){\r\n            initialControlPoints[k]=[]\r\n            for (let i=0;i<control_points[k].length;i++){\r\n                initialControlPoints[k][i]=[]\r\n                for (let j=0;j<control_points[k][i].length;j++){\r\n                    initialControlPoints[k][i].push([])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][0])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][1])\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    loadEdgeData(){\r\n        //let that=this\r\n        //fetch('/data/'+edgeDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n                //this.edges=data\r\n                console.time(\"Total Time\")\r\n\r\n                this.centralizeData(true)\r\n\r\n\r\n                // this.drawEdges()\r\n                this.calEdgeLength()\r\n                this.calActiveRegion(true)\r\n\r\n                console.time(\"cal energe\")\r\n                this.calEnergyField()\r\n                console.timeEnd(\"cal energe\")\r\n\r\n                console.time(\"cal final energe\")\r\n                //this.calFinalEnergeFieldV2()\r\n                this.calFinalEnergeField()\r\n                console.timeEnd(\"cal final energe\")\r\n\r\n                console.time(\"fill cross edge\")\r\n                this.fillCrossingEdge()\r\n                console.timeEnd(\"fill cross edge\")\r\n\r\n\r\n                console.time(\"create gap\")\r\n                this.createGapInBoundary()\r\n                console.timeEnd(\"create gap\")\r\n\r\n                //console.time(\"smooth\")\r\n                // this.smoothEnergyField()\r\n                //console.timeEnd(\"smooth\")\r\n\r\n                // for(let k in this.catPointDict){\r\n                //    this.drawEnergyField(k);\r\n                // }\r\n\r\n\r\n\r\n                d3.select(\"svg\").selectAll(\"*\").remove()\r\n                g = d3.select('svg').append(\"g\")\r\n\r\n                //g.append(\"image\")\r\n                //    .attr(\"x\",-42)\r\n                //    .attr(\"y\",-42)\r\n                //    .attr(\"width\",995)\r\n                //    .attr(\"height\",1350)\r\n                //    .attr(\"xlink:href\",\"/data/background/Manhatton.jpg\")\r\n\r\n                recal = false\r\n                recalNum = 0\r\n\r\n                this.findOutLine()\r\n                this.calOutLine()\r\n\r\n                /*\r\n\r\n                // re-cal the energy field for inner outline\r\n                for (var k in this.catEnergyField){\r\n                    this.catEnergyField[k].tfinalField = []\r\n                    for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                        this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                        for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                            let val = this.catEnergyField[k].finalField[y][x];\r\n                            if(IsoInsideTest([x, y], polygontest[k])){\r\n                                //console.log(\"test!!\")\r\n                                if(val > 0){\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                                }\r\n                                else{\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                                }\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].finalField[y][x] = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                let isoLineDict={}\r\n                for (var k in this.catEnergyField){\r\n                    var isoLines = [];\r\n                    isoLines=MarchingSquaresJS\r\n                        .isoLines(this.catEnergyField[k].tfinalField,\r\n                            intervals,\r\n                            {\r\n                                polygons: false,\r\n                                linearRing: false,\r\n                                noFrame:true\r\n                            }\r\n                        )\r\n                    isoLineDict[k]=isoLines[0]\r\n                }\r\n\r\n                for (var k in isoLineDict){\r\n                    //console.log(isoLineDict[k])\r\n                    let dx=this.catEnergyField[k].x\r\n                    let dy=this.catEnergyField[k].y\r\n                    for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                        if(isoLineDict[k][i].length < 30){\r\n                            continue;\r\n                        }\r\n                        let curlen = control_points[k].length;\r\n                        control_points[k][curlen] = [];\r\n                        for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                            control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                        }\r\n                        let meandis = 0;\r\n                        let sz = control_points[k][curlen].length;\r\n                        for(let j = 0; j < sz; j ++){\r\n                            meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                                control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                        }\r\n                        meandis /= sz\r\n                        control_points[k][curlen].meandis = meandis;\r\n                    }\r\n                    //this.drawEnergyField(k);\r\n                }\r\n\r\n                 */\r\n\r\n                //this.drawEnergyField(\"2\")\r\n                //this.drawEnergyField(\"3\")\r\n\r\n                this.calEdgeControlPoints()\r\n\r\n\r\n\r\n                this.drawEdges()\r\n                this.drawPointData()\r\n\r\n                //for(let k in this.catEnergyField){\r\n                //    this.drawEnergyField(k)\r\n                //}\r\n\r\n                console.timeEnd(\"Total Time\")\r\n\r\n                let that=this\r\n                function handleSvgClick(){\r\n                    console.log(\"click svg!\")\r\n                    d3.select(\"svg\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                        .attr(\"opacity\",0)\r\n                    that.selectedEdge=-1\r\n                    that.setState({\r\n                        hasSelectEdge:false,\r\n                        edgeWidth:defaultEdgeWidth\r\n                    })\r\n                }\r\n                        d3.select(\"svg\")\r\n                            .on(\"click\",handleSvgClick)\r\n\r\n            //})\r\n    }\r\n\r\n    afterEditReDraw(){\r\n\r\n        this.pointData = this.props.pointData\r\n\r\n        this.edges = this.props.edges\r\n\r\n        this.drawEdges()\r\n\r\n        this.drawPointData()\r\n\r\n        let that=this\r\n\r\n        function handleSvgClick(){\r\n            console.log(\"click svg!\")\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n    }\r\n\r\n    calActiveRegion(flag){\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(flag || !this.catEnergyField.hasOwnProperty(k)){\r\n                this.catEnergyField[k]={}\r\n                //console.log(\"calActiveRegion:\")\r\n                //console.log(k)\r\n            }\r\n\r\n            let maxx=this.catPointDict[k].maxX\r\n            let minx=this.catPointDict[k].minX\r\n            let maxy=this.catPointDict[k].maxY\r\n            let miny=this.catPointDict[k].minY\r\n\r\n            //console.log(\"active region: \")\r\n            //console.log([maxx, minx, maxy, miny])\r\n\r\n            this.catEnergyField[k].boundingX=minx-Math.max(nodeR1,edgeR1)-buffer\r\n            this.catEnergyField[k].boundingY=miny-Math.max(nodeR1,edgeR1)-buffer\r\n\r\n            this.catEnergyField[k].boundingWidth=Math.ceil((maxx-minx+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n            this.catEnergyField[k].boundingHeight=Math.ceil((maxy-miny+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n\r\n            if(flag || !this.catEnergyField[k].hasOwnProperty(\"field\")){\r\n\r\n                let centerX = this.catEnergyField[k].boundingX + 0.5 * this.catEnergyField[k].boundingWidth\r\n                let centerY = this.catEnergyField[k].boundingY + 0.5 * this.catEnergyField[k].boundingHeight\r\n\r\n                this.catEnergyField[k].x = parseInt((centerX - 0.5 * svgwidth))\r\n                this.catEnergyField[k].y = parseInt((centerY - 0.5 * svgheight))\r\n\r\n                this.catEnergyField[k].width = parseInt(svgwidth / pixelGroup)\r\n                this.catEnergyField[k].height = parseInt(svgheight / pixelGroup)\r\n\r\n                this.catEnergyField[k].field=[]\r\n                this.catEnergyField[k].barrierMap=[]\r\n                for (let i=0;i<svgheight;i++){\r\n                    this.catEnergyField[k].field.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].barrierMap.push(new Array(svgwidth).fill(0))\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.hasBubbles = true\r\n\r\n    }\r\n\r\n    calDistanceToItem(x,y,item){\r\n        //TODO: Rectangle items\r\n        //inside is 0\r\n        if(itemEnergyShape==\"circle\"){\r\n            let dis=calDistance(x,y,item.x,item.y)\r\n            if(dis<item.radius){\r\n                return 0\r\n            }\r\n            else{\r\n                return dis-item.radius\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    getPointEdgeDistance(lx1, ly1, lx2, ly2, x, y) {\r\n        var x1 = lx1;\r\n        var y1 = ly1;\r\n        var x2 = lx2 - x1;\r\n        var y2 = ly2 - y1;\r\n        var px = x - x1;\r\n        var py = y - y1;\r\n        var dotprod = px * x2 + py * y2;\r\n        var projlenSq;\r\n        if(dotprod <= 0) {\r\n            projlenSq = 0;\r\n        } else {\r\n            px = x2 - px;\r\n            py = y2 - py;\r\n            dotprod = px * x2 + py * y2;\r\n            if(dotprod <= 0) {\r\n                projlenSq = 0;\r\n            } else {\r\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\r\n            }\r\n        }\r\n        var lenSq = px * px + py * py - projlenSq;\r\n        if(lenSq < 0) {\r\n            lenSq = 0;\r\n        }\r\n        return Math.sqrt(lenSq);\r\n    }\r\n\r\n    calDistanceToEdgeV2(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint, endpoint\r\n        if(edge.flag == false){\r\n            startpoint = edge.startpoint\r\n            endpoint = edge.endpoint\r\n        }\r\n        else{\r\n            startpoint=this.pointData[edge.start]\r\n            endpoint=this.pointData[edge.end]\r\n        }\r\n        if(edge.virtrual && edge.virtrualNodes.length > 0){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calDistanceToEdge(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint=this.pointData[edge.start]\r\n        let endpoint=this.pointData[edge.end]\r\n        if(edge.virtrual){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    isRectIntersects (rect1,rect2) {\r\n        if(rect1.width <= 0 || rect1.height <= 0 || rect2.width <= 0 || rect2.height <= 0) return false;\r\n        return (rect2.maxX > rect1.minX &&\r\n            rect2.maxY > rect1.minY &&\r\n            rect2.minX < rect1.maxX &&\r\n            rect2.minY < rect1.maxY);\r\n    };\r\n\r\n    isThisCat(point,cat){\r\n        let catarr=point.catArray\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    LabelGroupElement(){\r\n        let maxpdis = nodeR1 * 2\r\n        for(let k1 in this.catPointDict){\r\n\r\n            // cal for points\r\n            for(let i = 0;i < this.catPointDict[k1].length; i ++){\r\n                if(this.catPointDict[k1][i].isGroup==false){\r\n                    continue;\r\n                }\r\n                let isgroup = true;\r\n                let x1 = this.catPointDict[k1][i].x;\r\n                let y1 = this.catPointDict[k1][i].y;\r\n                for(let k2 in this.catPointDict){\r\n//\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n//\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(calDistance(x1,y1,x2,y2) < maxpdis + this.catPointDict[k2][j].radius + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n//\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    // cal edge\r\n                    if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                        continue;\r\n                    }\r\n                    for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                        if(this.calDistanceToEdge(x1,y1,this.catEdgeDict[k2][j])[0] < maxpdis + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catEdgeDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n                }\r\n                this.catPointDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n            // cal for edges\r\n            if(!this.catEdgeDict.hasOwnProperty(k1)){\r\n                continue;\r\n            }\r\n            for(let i = 0;i < this.catEdgeDict[k1].length;i ++){\r\n                let s1 = this.pointData[this.catEdgeDict[k1][i].start];\r\n                let e1 = this.pointData[this.catEdgeDict[k1][i].end];\r\n                if(this.catEdgeDict[k1][i].isGroup == false){\r\n                    continue;\r\n                }\r\n                let isgroup = true\r\n                for(let k2 in this.catPointDict){\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(this.calDistanceToEdge(x2,y2,this.catEdgeDict[k1][i])[0] < maxpdis + this.catPointDict[k2][j].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    //// cal edge\r\n                    //if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                    //    continue;\r\n                    //}\r\n                    //for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                    //    let s2 = this.pointData[this.catEdgeDict[k2][j].start];\r\n                    //    let e2 = this.pointData[this.catEdgeDict[k2][j].end];\r\n                    //    if(this.checkEdgeCrossing(s1,e1,s2,e2)[0]){\r\n                    //        isgroup = false;\r\n                    //        this.catEdgeDict[k2][j].isGroup = false;\r\n                    //        break;\r\n                    //    }\r\n                    //}\r\n                    //if(isgroup==false){\r\n                    //    break;\r\n                    //}\r\n//\r\n                }\r\n                this.catEdgeDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField_Part(updatePoints, updateEdges){\r\n\r\n        console.log(\"calEnergyField_Part:\")\r\n        console.log(updateEdges)\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(!this.catEnergyField[k].hasOwnProperty(\"finalField\")){\r\n                // group attrs\r\n                this.catPointDict[k].pointMap=[]\r\n                this.catEnergyField[k].pointBarrierMap=[]\r\n                this.catEnergyField[k].edgeBarrierMap=[]\r\n                this.catEnergyField[k].pointIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap2=[]\r\n                this.catEnergyField[k].finalField = []\r\n                this.catEnergyField[k].subUpdate = []\r\n\r\n                for (let y=0;y<svgheight;y++){\r\n                    this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                    this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n\r\n                    this.catEnergyField[k].edgeIndexMap2.push([])\r\n                    for(let x=0;x<svgwidth;x++){\r\n                        this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for(var k in this.catPointDict){\r\n\r\n            if(!updatePoints.hasOwnProperty(k)){\r\n                updatePoints[k] = []\r\n            }\r\n\r\n            if(!updateEdges.hasOwnProperty(k)){\r\n                updateEdges[k] = []\r\n            }\r\n\r\n            let members = updatePoints[k]\r\n\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                //this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n\r\n                            if(members[i].flag == false){\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.015 || this.catEnergyField[k].edgeIndexMap[y][x] == -1){\r\n                                    this.catEnergyField[k].field[y][x] = 0\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=-1\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                            }\r\n                            else{\r\n\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                        if(members[i].flag == true){\r\n\r\n                            if(distance<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=1\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                                }\r\n                            }\r\n\r\n                            if(distance<=fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=3\r\n                                //this.catPointDict[k].pointMap[i].push([x,y])\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n            console.log(this.maxEdgeLength)\r\n            // cal positive value of edges\r\n            let edges=updateEdges[k]\r\n            edges.sort(function(a,b){\r\n                return a.flag - b.flag\r\n            })\r\n            //console.log(\"Sort Edegs:\")\r\n            //console.log(edges)\r\n            for (let i=0;i<edges.length;i++){\r\n                // cal positive value for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                let startid=edges[i].start\r\n                let endid=edges[i].end\r\n                startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToEdgeV2(realx,realy,edges[i])\r\n                        let distancetoEdge=distance[0]\r\n                        let distancetoNode=distance[1]\r\n                        let totalDistance=distance[2]\r\n\r\n                        if(distancetoNode<0){\r\n                            continue\r\n                        }\r\n\r\n                        if(distancetoEdge<edgeR1+fixdis){\r\n                            let newR1=edgeR1\r\n                            let reducefactor=edgeR1/10\r\n                            let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                            if(totalDistance>EDGELENGTH_THRESH){\r\n                                newR1=2*edgeR1/(1+factor*distancetoNode)\r\n                            }\r\n                            if(newR1>edgeR1){\r\n                                newR1=edgeR1\r\n                            }\r\n\r\n                            if(newR1>2*nodeR1){\r\n                                newR1=2*nodeR1\r\n                            }\r\n                            let energy\r\n                            if(distancetoEdge>newR1){\r\n                                energy=0\r\n                            }\r\n                            else{\r\n                                energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                            }\r\n\r\n\r\n                            if(edges[i].flag == true){\r\n                                let preenergy = this.catEnergyField[k].finalField[y][x]\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                let delflag = false\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x] == -1 && this.catEnergyField[k].edgeIndexMap2[y][x].length == 1){\r\n                                    if(this.catEnergyField[k].edgeIndexMap2[y][x][0].start == startid && this.catEnergyField[k].edgeIndexMap2[y][x][0].end == endid){\r\n                                        delflag = true\r\n                                    }\r\n                                }\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.015 || delflag){\r\n                                    this.catEnergyField[k].field[y][x]=0\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                    for(let it = this.catEnergyField[k].edgeIndexMap2[y][x].length - 1; it >= 0 ; it --){\r\n                                        let s = this.catEnergyField[k].edgeIndexMap2[y][x][it].start\r\n                                        let e = this.catEnergyField[k].edgeIndexMap2[y][x][it].end\r\n                                        if(s==startid&&e==endid){\r\n                                            this.catEnergyField[k].edgeIndexMap2[y][x].splice(it,1)\r\n                                        }\r\n                                    }\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                                //if(this.catEnergyField[k].pointIndexMap[y][x] != -1){\r\n                                //    this.catEnergyField[k].barrierMap[y][x]=this.catEnergyField[k].pointBarrierMap[y][x]\r\n                                //    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                //    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                //}\r\n                            }\r\n\r\n                        }\r\n\r\n                        /*\r\n                        let startpoint=this.pointData[startid]\r\n                        let endpoint=this.pointData[endid]\r\n\r\n                        if(startpoint.multicat&&endpoint.multicat){\r\n                            let hasSameCat=false\r\n                            let samecat=-1\r\n                            for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                let cat1=startpoint.catArray[c1]\r\n                                if(cat1!=k){\r\n                                    for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                        let cat2=endpoint.catArray[c2]\r\n                                        if(cat2!=k){\r\n                                            if(cat2==cat1){\r\n                                                hasSameCat=true\r\n                                                samecat=cat1\r\n                                                break\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                            if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                if(distancetoEdge<edgeR1+20+fixdis){\r\n                                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                    let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                    let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                    let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                    // let energyscale=100\r\n\r\n                                    if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                        this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                        this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        */\r\n\r\n                        if(edges[i].flag == true){\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField(){\r\n\r\n        //TODO: edge and node use different barrier map\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            // group attrs\r\n            this.catPointDict[k].pointMap=[]\r\n            this.catEnergyField[k].pointBarrierMap=[]\r\n            this.catEnergyField[k].edgeBarrierMap=[]\r\n            this.catEnergyField[k].pointIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap2=[]\r\n            this.catEnergyField[k].finalField = []\r\n            this.catEnergyField[k].subUpdate = []\r\n\r\n            for (let y=0;y<svgheight;y++){\r\n                this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap2.push([])\r\n                for(let x=0;x<svgwidth;x++){\r\n                    this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                }\r\n            }\r\n\r\n            //// not group attrs\r\n            //this.catPointDict[k].gpointMap=[]\r\n            //this.catEnergyField[k].gpointBarrierMap=[]\r\n            //this.catEnergyField[k].gedgeBarrierMap=[]\r\n            //this.catEnergyField[k].gpointIndexMap=[]\r\n            //this.catEnergyField[k].gedgeIndexMap=[]\r\n//\r\n            //for(let y=0;y<this.catEnergyField[k].gheight;y++){\r\n            //    this.catEnergyField[k].gpointBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gedgeBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gpointIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //    this.catEnergyField[k].gedgeIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //}\r\n\r\n\r\n        }\r\n\r\n        // cal bbox of edges\r\n        // fix to cal at this.centralizeData()\r\n\r\n        // cal the real active region\r\n        //this.LabelGroupElement()\r\n\r\n        for(var k in this.catPointDict){\r\n            let members=this.catPointDict[k]\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                            this.catEnergyField[k].field[y][x]+=energy\r\n                            if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                this.catEnergyField[k].barrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n                        }\r\n                        if(point.multicat){\r\n                            let catarr=point.catArray\r\n                            for (let c=0;c<catarr.length;c++){\r\n                                if(catarr[c]!=k&&parseInt(catarr[c])<parseInt(k)){\r\n                                    if(distance<nodeR1+10){\r\n                                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[catarr[c]].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[catarr[c]].y)/pixelGroup)\r\n                                        let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[catarr[c]].width&&relativey<this.catEnergyField[catarr[c]].height){\r\n                                            // this.catEnergyField[catarr[c]].field[relativey][relativex]+=energy\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if(distance<=barrierGap+fixdis){\r\n                            if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].barrierMap[y][x]=1\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                            }\r\n                        }\r\n\r\n                        if(distance<=fixdis){\r\n                            //inside\r\n                            this.catEnergyField[k].barrierMap[y][x]=3\r\n                            this.catPointDict[k].pointMap[i].push([x,y])\r\n                            this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                            this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            // let EDGELENGTH_THRESH=(this.maxEdgeLength+this.minEdgeLength)/3\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/2\r\n            // let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n\r\n            // cal positive value of edges\r\n            if(this.catEdgeDict.hasOwnProperty(k)){\r\n                let edges=this.catEdgeDict[k]\r\n                for (let i=0;i<edges.length;i++){\r\n                    // cal positive value for pixel group\r\n                    let startx\r\n                    let endx\r\n                    let starty\r\n                    let endy\r\n                    let startid=edges[i].start\r\n                    let endid=edges[i].end\r\n                    startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                    endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                    starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                    endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                    for (let y=starty;y<endy;y++){\r\n                        for (let x=startx;x<endx;x++){\r\n                            let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                            let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                            let distance=this.calDistanceToEdge(realx,realy,edges[i])\r\n                            let distancetoEdge=distance[0]\r\n                            let distancetoNode=distance[1]\r\n                            let totalDistance=distance[2]\r\n\r\n                            if(distancetoNode<0){\r\n                                continue\r\n                            }\r\n\r\n                            if(distancetoEdge<edgeR1+fixdis){\r\n                                let newR1=edgeR1\r\n                                // let factor=(edgeR1-2)/this.maxEdgeLength\r\n                                let reducefactor=edgeR1/10\r\n                                let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                                if(totalDistance>EDGELENGTH_THRESH){\r\n                                    newR1=2*edgeR1/(1+factor*distancetoNode)\r\n\r\n\r\n                                    // newR1=2*edgeR1/(1+factor*distancetoNode/4)\r\n\r\n                                    // weight=1-Math.pow(factor,2)\r\n                                    // let factor=2*(Math.exp(2)-1)/this.maxEdgeLength\r\n                                    // weight=1/(Math.log(1+factor*distancetoNode)+2)\r\n\r\n                                    // weight=weight*2\r\n                                }\r\n                                if(newR1>edgeR1){\r\n                                    newR1=edgeR1\r\n                                }\r\n\r\n                                if(newR1>2*nodeR1){\r\n                                    newR1=2*nodeR1\r\n                                }\r\n                                let energy\r\n                                if(distancetoEdge>newR1){\r\n                                    energy=0\r\n                                }\r\n                                else{\r\n                                    energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                }\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n\r\n                            }\r\n\r\n                            let startpoint=this.pointData[startid]\r\n                            let endpoint=this.pointData[endid]\r\n\r\n                            if(startpoint.multicat&&endpoint.multicat){\r\n                                let hasSameCat=false\r\n                                let samecat=-1\r\n                                for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                    let cat1=startpoint.catArray[c1]\r\n                                    if(cat1!=k){\r\n                                        for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                            let cat2=endpoint.catArray[c2]\r\n                                            if(cat2!=k){\r\n                                                if(cat2==cat1){\r\n                                                    hasSameCat=true\r\n                                                    samecat=cat1\r\n                                                    break\r\n                                                }\r\n                                            }\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                                if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                    if(distancetoEdge<edgeR1+20+fixdis){\r\n                                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                        let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                        // let energyscale=100\r\n\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                            this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                            this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                            this.catEnergyField[samecat].edgeIndexMap2[relativey][relativex].push({start:startpoint.id, end:endpoint.id})\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    checkEdgeCrossing(a, b, c, d){\r\n\r\n        // 三角形abc 面积的2倍\r\n        var area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\r\n\r\n        // 三角形abd 面积的2倍\r\n        var area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);\r\n\r\n        // 面积符号相同则两点在线段同侧,不相交 (对点在线段上的情况,本例当作不相交处理);\r\n        if ( area_abc*area_abd>=0 ) {\r\n            return [false];\r\n        }\r\n\r\n        // 三角形cda 面积的2倍\r\n        var area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);\r\n        // 三角形cdb 面积的2倍\r\n        // 注意: 这里有一个小优化.不需要再用公式计算面积,而是通过已知的三个面积加减得出.\r\n        var area_cdb = area_cda + area_abc - area_abd ;\r\n        if (  area_cda * area_cdb >= 0 ) {\r\n            return [false];\r\n        }\r\n\r\n        //计算交点坐标\r\n        var t = area_cda / ( area_abd- area_abc );\r\n        var dx= t*(b.x - a.x),\r\n            dy= t*(b.y - a.y);\r\n        return[true, { x: a.x + dx , y: a.y + dy }];\r\n\r\n    }\r\n\r\n    createGapInBoundary(){\r\n        let gap=this.state.gapBetween\r\n        if(gap==0)\r\n            return\r\n        for (var k in this.catEnergyField){\r\n            let field=this.catEnergyField[k].finalField\r\n            let deletePoints=[]\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    if(field[y][x]==0){\r\n                        continue\r\n                    }\r\n\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4)\r\n                        continue\r\n\r\n                    //check if it is the boundary\r\n                    let isboundary=false\r\n                    for (let i=0;i<gap;i++){\r\n                        let delta=i+1\r\n                        //right\r\n                        if(x+delta<this.catEnergyField[k].width){\r\n                            if(field[y][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left\r\n                        if(x-delta>0){\r\n                            if(field[y][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //up\r\n                        if(y-delta>0){\r\n                            if(field[y-delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //down\r\n                        if(y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-top\r\n                        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n                            if(field[y-delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-bottom\r\n                        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-top\r\n                        if(x-delta>0&&y-delta>0){\r\n                            if(field[y-delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-bottom\r\n                        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(isboundary){\r\n                        // this.catEnergyField[k].finalField[y][x]=0\r\n                        deletePoints.push([x,y])\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for (let i=0;i<deletePoints.length;i++){\r\n                let x=deletePoints[i][0]\r\n                let y=deletePoints[i][1]\r\n                this.catEnergyField[k].finalField[y][x]=0\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    removeEmptyZone(isoDict){\r\n\r\n        // for (var k in this.catEnergyField){\r\n        //     for (let y=0;y<this.catEnergyField[k].height;y++){\r\n        //         for (let x=0;x<this.catEnergyField[k].width;x++){\r\n        //             if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==4){\r\n        //                 this.catEnergyField[k].finalField[y][x]=0\r\n        //             }\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        for (var k in isoDict){\r\n            let isolines=isoDict[k]\r\n            let isolinepoints=[]\r\n            let finalField=this.catEnergyField[k].finalField\r\n            this.catEnergyField[k].isoLineMap=[]\r\n\r\n            for (let i=0;i<isolines.length;i++){\r\n                let relativepoints=[]\r\n                for (let p=0;p<isolines[i].length;p++){\r\n                    relativepoints.push({x:isolines[i][p][0], y:isolines[i][p][1]})\r\n                }\r\n                isolinepoints.push(relativepoints)\r\n            }\r\n\r\n            let isoInsidePoints=[]\r\n            for (let i=0;i<isolinepoints.length;i++){\r\n                isoInsidePoints.push([])\r\n            }\r\n\r\n            for (let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].isoLineMap.push([])\r\n                for (let x=0;x<this.catEnergyField[k].width;x++){\r\n                    this.catEnergyField[k].isoLineMap[y].push(-1)\r\n\r\n                    if(finalField[y][x]>0){\r\n                        for (let i=0;i<isolinepoints.length;i++){\r\n                            //check if it is inside the isoline\r\n                            let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},isolinepoints[i])\r\n                            if(intersect){\r\n                                isoInsidePoints[i].push([x,y])\r\n                                this.catEnergyField[k].isoLineMap[y][x]=i\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            let notDeleteIndex=[]\r\n            for (let i=0;i<this.catPointDict[k].pointMap.length;i++){\r\n                let nodePoints=this.catPointDict[k].pointMap[i]\r\n                let totalInside=true\r\n                let isolineIndex=-1\r\n\r\n                // if(k==\"5\"&&i==0){\r\n                //     console.log()\r\n                // }\r\n\r\n                for (let n=0;n<nodePoints.length;n++){\r\n                    let x=nodePoints[n][0]\r\n                    let y=nodePoints[n][1]\r\n                    if(n==0){\r\n                        if(this.catEnergyField[k].isoLineMap[y][x]>-1){\r\n                            isolineIndex=this.catEnergyField[k].isoLineMap[y][x]\r\n                        }\r\n                    }\r\n                    if(this.catEnergyField[k].isoLineMap[y][x]==-1||this.catEnergyField[k].isoLineMap[y][x]!=isolineIndex){\r\n                        totalInside=false\r\n                        break\r\n                    }\r\n\r\n                }\r\n\r\n                if(totalInside){\r\n                    notDeleteIndex.push(isolineIndex)\r\n                }\r\n\r\n            }\r\n\r\n            let deleteindex=[]\r\n\r\n            for(let i=0;i<isoInsidePoints.length;i++){\r\n                let isdelete=true\r\n                for (let j=0;j<notDeleteIndex.length;j++){\r\n                    if(i==notDeleteIndex[j]){\r\n                        isdelete=false\r\n                        break\r\n                    }\r\n                }\r\n                if(isdelete){\r\n                    deleteindex.push(i)\r\n                }\r\n            }\r\n\r\n\r\n            for (let i=0;i<deleteindex.length;i++){\r\n                let index=deleteindex[i]\r\n                let deletePoints=isoInsidePoints[index]\r\n\r\n                for(let p=0;p<deletePoints.length;p++){\r\n                    let x=deletePoints[p][0]\r\n                    let y=deletePoints[p][1]\r\n                    this.catEnergyField[k].finalField[y][x]=0\r\n                }\r\n            }\r\n\r\n            let newisolines=[]\r\n            for (let i=0;i<isolines.length;i++){\r\n                let isdelete=false\r\n                for (let j=0;j<deleteindex.length;j++){\r\n                    if(i==deleteindex[j]){\r\n                        isdelete=true\r\n                        break\r\n                    }\r\n\r\n                }\r\n                if(!isdelete){\r\n                    newisolines.push(isolines[i])\r\n                }\r\n\r\n            }\r\n\r\n            isoDict[k]=newisolines\r\n        }\r\n        console.log(isoDict)\r\n        return isoDict\r\n    }\r\n\r\n    isSameCat(catarr1,catarr2){\r\n        for(let i=0;i<catarr1.length;i++){\r\n            let cat1=catarr1[i]\r\n            for (let j=0;j<catarr2.length;j++){\r\n                let cat2=catarr2[j]\r\n                if(cat1==cat2){\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isContained(catarr,cat){\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calFinalEnergeFieldForOverlap(){\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = this.catEnergyField[k].field\r\n            for(let y in this.catNotGroup[k]){\r\n                //this.catEnergyField[k].finalField.push(new Array(this.catEnergyField[k].width).fill(0))\r\n                for(let x in this.catNotGroup[k][y]){\r\n                    y = parseInt(y);\r\n                    x = parseInt(x);\r\n                    let px = Math.ceil(x/pixelGroup)\r\n                    let py = Math.ceil(y/pixelGroup)\r\n                    let realx=x+this.catEnergyField[k].x\r\n                    let realy=y+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].gfield[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].gpointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].gedgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].gbarrierMap[y][x]==3||this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].gfield[y][x]==0){\r\n                        // drawRect(realx,realy,1,1,\"red\")\r\n                        value=1\r\n                        this.catEnergyField[k].gfield[y][x]=1\r\n                        this.catEnergyField[k].field[py][px]=1\r\n                    }\r\n\r\n\r\n                    /*                    if (!isInside&&value==0){\r\n                                            continue\r\n                                        }*/\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].x+this.catEnergyField[k2].gwidth&&realx>this.catEnergyField[k2].x&&realy<this.catEnergyField[k2].y+this.catEnergyField[k2].gheight&&realy>this.catEnergyField[k2].y){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x))\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y))\r\n\r\n                                let othervalue=this.catEnergyField[k2].gfield[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].gpointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].gedgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].gpointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].gbarrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].gbarrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[py][px]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[py][px]==4){\r\n                        this.catEnergyField[k].finalField[py][px]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateEnergyPoints(){\r\n        //update final energyfield according to this.updatedEnergyPoints\r\n        for (var k in this.updatedEnergyPoints){\r\n            for (let p=0;p<this.updatedEnergyPoints[k].length;p++){\r\n                let x=this.updatedEnergyPoints[k][p][0]\r\n                let y=this.updatedEnergyPoints[k][p][1]\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=this.catEnergyField[k].field[y][x]\r\n                // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                let finalvalue=value\r\n                let isInside=false\r\n\r\n                if(value == 0){\r\n                    continue;\r\n                }\r\n\r\n               if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    isInside=true\r\n                }\r\n\r\n                if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                    value=1\r\n                    this.catEnergyField[k].field[y][x]=1\r\n                }\r\n\r\n                if (value==0){\r\n                    // drawRect(realx,realy,1,1,\"black\")\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField){\r\n                    if(k2==k)\r\n                        continue\r\n\r\n                    if(k2!=k){\r\n                        if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                            let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                            let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                            let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                            let otherinside=false\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ){\r\n\r\n                                if(this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==1|| this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==3){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                otherinside=true\r\n                            }\r\n\r\n\r\n                            if (othervalue==0){\r\n                                // drawRect(realx,realy,1,1,\"black\")\r\n                                continue\r\n                            }\r\n\r\n                            // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                            // drawRect(realx,realy,1,1,\"blue\")\r\n                            if(!isInside&&!otherinside){\r\n\r\n                                if(othervalue>value){\r\n                                    finalvalue=0\r\n                                    // drawRect(realx,realy,2,2,\"red\")\r\n                                    // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                    break\r\n                                }\r\n                                else{\r\n                                    finalvalue=value\r\n                                }\r\n                                // finalvalue=0\r\n                                // finalvalue=value\r\n\r\n                            }\r\n                            else if(isInside&&!otherinside){\r\n                                // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                //pass\r\n\r\n                                finalvalue=value\r\n                            }\r\n                            else if(!isInside&&otherinside){\r\n                                // drawRect(realx,realy,2,2,\"black\")\r\n                                // drawRect(realx,realy,1,1,\"orange\")\r\n                                finalvalue=0\r\n                                break\r\n                            }\r\n                            else if(isInside&&otherinside){\r\n\r\n                                // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else{\r\n                                    finalvalue=0\r\n                                }\r\n                                // finalvalue=0\r\n\r\n\r\n                            }\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                            //     finalvalue=0\r\n                            // }\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                //if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                //    this.catEnergyField[k].finalField[y][x]=10000\r\n                //}\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calFinalEnergeField_Part(){\r\n\r\n        this.updateIdx = new Set(this.updateIdx)\r\n        //console.log(\"calFinalEnergeField_Part:\")\r\n        //console.log(this.updateIdx)\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = clone(this.catEnergyField[k].field)\r\n            for(let updateidx of this.updateIdx){\r\n\r\n\r\n                    let realx=parseInt(updateidx[1])\r\n                    let realy=parseInt(updateidx[0])\r\n\r\n\r\n                    //console.log(\"(\" + realx + \", \" + realy + \")\")\r\n\r\n                    let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                    let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n\r\n                    x = Math.min(x, this.catEnergyField[k].width - 1)\r\n                    y = Math.min(y, this.catEnergyField[k].height - 1)\r\n                    x = Math.max(x, 0)\r\n                    y = Math.max(y, 0)\r\n\r\n                    //d3.select('g').append('circle')\r\n                    //    .attr('id','final')\r\n                    //    .attr('cx',realx)\r\n                    //    .attr('cy',realy)\r\n                    //    .attr('r',1)\r\n                    //    .attr('fill','red')\r\n\r\n                    //console.log(\"(\" + this.catEnergyField[k].width + \", \" + this.catEnergyField[k].height + \")\")\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    //if(value == 0){\r\n                    //    continue\r\n                    //}\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside && this.catEnergyField[k].field[y][x] <= 0.015 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        value=1\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n        }\r\n\r\n    }\r\n\r\n    calFinalEnergeField(){\r\n\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n        for (var k in this.catEnergyField){\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        value=1\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<=this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>=this.catEnergyField[k2].boundingX&&realy<=this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>=this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n                                }\r\n\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    recalFinalEnergeField(preK){\r\n\r\n        let bounding = {}\r\n        for(let k in this.catEnergyField){\r\n            bounding[k] = {\r\n                minX : Number.MAX_VALUE,\r\n                minY : Number.MAX_VALUE,\r\n                maxX : Number.MIN_VALUE,\r\n                maxY : Number.MIN_VALUE\r\n            }\r\n        }\r\n\r\n        for (var k in this.catEnergyField){\r\n            if(k == preK){\r\n                continue\r\n            }\r\n            for(let p=0;p<this.updatedEnergyPoints[preK].length;p++) {\r\n\r\n                let realx = this.updatedEnergyPoints[preK][p][0] * pixelGroup + this.catEnergyField[preK].x\r\n                let realy = this.updatedEnergyPoints[preK][p][1] * pixelGroup + this.catEnergyField[preK].y\r\n\r\n                let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup);\r\n                let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup);\r\n\r\n\r\n                bounding[k].minX = Math.min(bounding[k].minX, x)\r\n                bounding[k].minY = Math.min(bounding[k].minY, y)\r\n                bounding[k].maxX = Math.max(bounding[k].maxX, x)\r\n                bounding[k].maxY = Math.max(bounding[k].maxY, y)\r\n\r\n                let value = this.catEnergyField[k].field[y][x]\r\n                let finalvalue = value\r\n                let isInside = false\r\n\r\n                let thisPointID = this.catEnergyField[k].pointIndexMap[y][x]\r\n                let thisEdgeID = this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                let thiscat\r\n\r\n                if (thisEdgeID == -1 && thisPointID == -1) {\r\n                    continue\r\n                }\r\n\r\n                if (thisEdgeID > -1) {\r\n                    if (this.pointData[thisEdgeID].multicat) {\r\n                        thiscat = this.pointData[thisEdgeID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisEdgeID].cat]\r\n                    }\r\n                }\r\n\r\n                if (thisPointID > -1) {\r\n                    if (this.pointData[thisPointID].multicat) {\r\n                        thiscat = this.pointData[thisPointID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisPointID].cat]\r\n                    }\r\n                }\r\n\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 3 || this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    isInside = true\r\n                }\r\n\r\n                if (isInside && this.catEnergyField[k].field[y][x] == 0) {\r\n                    this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                    this.catEnergyField[k].edgeIndexMap2[y][x].push({\r\n                        start: this.edges[thisEdgeID].start,\r\n                        end: this.edges[thisEdgeID].end\r\n                    })\r\n                    value = 1\r\n                    this.catEnergyField[k].field[y][x] = 1\r\n                }\r\n\r\n                if (value == 0) {\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField) {\r\n\r\n                    if (k2 == k)\r\n                        continue\r\n\r\n                    if(k2 == preK){\r\n                        // TODO : compare final value\r\n\r\n\r\n                        continue\r\n                    }\r\n\r\n                    if (realx <= this.catEnergyField[k2].boundingX + this.catEnergyField[k2].boundingWidth * pixelGroup && realx >= this.catEnergyField[k2].boundingX && realy <= this.catEnergyField[k2].boundingY + this.catEnergyField[k2].boundingHeight * pixelGroup && realy >= this.catEnergyField[k2].boundingY) {\r\n                        let relativex = Math.floor((realx - this.catEnergyField[k2].x) / pixelGroup)\r\n                        let relativey = Math.floor((realy - this.catEnergyField[k2].y) / pixelGroup)\r\n\r\n                        let othervalue = this.catEnergyField[k2].field[relativey][relativex]\r\n                        let otherinside = false\r\n                        let otherPointID = this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                        let otherEdgeID = this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                        let othercat\r\n\r\n                        if (otherPointID == -1 && otherEdgeID == -1) {\r\n                            continue\r\n                        }\r\n\r\n                        if (otherEdgeID > -1) {\r\n                            if (this.pointData[otherEdgeID].multicat) {\r\n                                othercat = this.pointData[otherEdgeID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherEdgeID].cat]\r\n                            }\r\n                        }\r\n\r\n                        if (otherPointID > -1) {\r\n                            if (this.pointData[otherPointID].multicat) {\r\n                                othercat = this.pointData[otherPointID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherPointID].cat]\r\n                            }\r\n                        }\r\n\r\n\r\n                        // if(aim){\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        // if(k==\"11\"&&k2==\"0\"){\r\n                        //         drawRect(realx,realy,1,1,\"red\")\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        if (this.isContained(othercat, k)) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // if(k==\"11\"&&k2==\"0\"){\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // }\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n                        }\r\n\r\n\r\n                        if (this.isContained(thiscat, k2) && this.catEnergyField[k2].pointBarrierMap[relativey][relativex] != 3) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n\r\n                        }\r\n\r\n                        if (this.catEnergyField[k2].barrierMap[relativey][relativex] == 3 || this.catEnergyField[k2].barrierMap[relativey][relativex] == 4) {\r\n                            otherinside = true\r\n                        }\r\n\r\n                        if (othervalue == 0) {\r\n                            continue\r\n                        }\r\n\r\n                        if (!isInside && !otherinside) {\r\n                            if (othervalue > value) {\r\n                                finalvalue = 0\r\n                                break\r\n                            } else {\r\n                                finalvalue = value\r\n                            }\r\n                        } else if (isInside && !otherinside) {\r\n                            finalvalue = value\r\n                        } else if (!isInside && otherinside) {\r\n                            finalvalue = 0\r\n                            break\r\n                        } else if (isInside && otherinside) {\r\n                           if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                                finalvalue = value\r\n                            } else {\r\n                                finalvalue = 0\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x] = finalvalue\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    this.catEnergyField[k].finalField[y][x] = 10000\r\n                }\r\n            }\r\n        }\r\n\r\n        this.smoothEnergyField(bounding)\r\n\r\n    }\r\n\r\n    updateFinalField(idx,k,val){\r\n\r\n        let id = parseInt(idx);\r\n        let sz = control_points[k].length;\r\n        //console.log([id,sz]);\r\n        let points = []\r\n        let miny = Number.MAX_VALUE\r\n        let maxy = Number.MIN_VALUE\r\n        for(let j = -1;j <= 1;j ++ ){\r\n            points.push({\r\n                x:control_points[k][(id + j) % sz][0],\r\n                y:control_points[k][(id + j) % sz][1]\r\n            })\r\n            miny = Math.min(miny,control_points[k][(id + j) % sz][1]);\r\n            maxy = Math.max(maxy,control_points[k][(id + j) % sz][1]);\r\n        }\r\n//\r\n        let lines = []\r\n//\r\n        for(let j = 0;j < 3;j ++){\r\n            let p1 = points[j]\r\n            let p2 = points[(j+1)%3]\r\n            let tmp = {}\r\n            tmp.y1 = Math.min(p1.y,p2.y);\r\n            tmp.y2 = Math.max(p1.y,p2.y);\r\n            if(p1.y == p2.y){\r\n                tmp.flag = true;\r\n                tmp.val1 = Math.min(p1.x,p2.x);\r\n                tmp.val2 = Math.max(p1.x,p2.x);\r\n            }\r\n            else{\r\n                tmp.flag = false;\r\n                tmp.val1 = (p2.x - p1.x) / (p2.y - p1.y);\r\n                tmp.val2 = (p1.x * p2.y - p2.x * p1.y) / (p2.y - p1.y);\r\n            }\r\n            lines.push(tmp);\r\n        }\r\n//\r\n        for(let y = miny;y < maxy;y ++){\r\n//\r\n            let x1 = Number.MAX_VALUE;\r\n            let x2 = Number.MIN_VALUE;\r\n            let flag = false;\r\n//\r\n            for(let j = 0; j < 3;j ++){\r\n                if(y >= lines[j].y1 && y <= lines[j].y2){\r\n                    if(lines[j].flag == true){\r\n                        x1 = lines[j].val1;\r\n                        x2 = lines[j].val2;\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                    else{\r\n                        let tmpx = lines[j].val1 * y + lines[j].val2;\r\n                        x1 = Math.min(x1, tmpx);\r\n                        x2 = Math.max(x2,tmpx);\r\n                    }\r\n                }\r\n            }\r\n//\r\n            if(flag==true && val == 0){\r\n                continue;\r\n            }\r\n            else{\r\n                x1 = parseInt(x1)\r\n                x2 = parseInt(x2)\r\n                for(let x = x1;x <= x2;x ++){\r\n                    //console.log(\"(\" + this.catEnergyField[k].x + \", \" + this.catEnergyField[k].y + \", \"+ pixelGroup + \")\");\r\n                    //console.log(\"(\" + this.catEnergyField[k].height + \", \" + this.catEnergyField[k].width + \")\")\r\n                    let uy = Math.min(parseInt((y - this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                    let ux = Math.min(parseInt((x - this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                    uy = Math.max(uy,0)\r\n                    ux = Math.max(ux,0)\r\n                    //alert(\"(\" + x + \", \" + y + \")\");\r\n                    // this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].field[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.updatedEnergyPoints[k].push([parseInt(ux),parseInt(uy)])\r\n                }\r\n            }\r\n//\r\n        }\r\n        //console.log(this.catEnergyField[k].finalField)\r\n    }\r\n\r\n    drawEnergyField(k){\r\n        colors = this.props.colorArray\r\n\r\n        let field=this.catEnergyField[k].finalField\r\n        //let field = this.catEnergyField[k].field\r\n        for(let y=0;y<field.length;y++){\r\n            for (let x=0;x<field[y].length;x++){\r\n                if(field[y][x]<0.0001)\r\n                    continue\r\n                let that=this\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=field[y][x]\r\n\r\n                g.append(\"rect\")\r\n                    .attr(\"x\",realx-0.5)\r\n                    .attr(\"y\",realy-0.5)\r\n                    .attr(\"width\",1)\r\n                    .attr(\"height\",1)\r\n                    .attr(\"class\",\"energyfieldrect\")\r\n                    .attr(\"fill\", function(){\r\n                        // if(value==-1){\r\n                        //     return \"red\"\r\n                        // }\r\n                        // if(value==-2){\r\n                        //     return \"green\"\r\n                        // }\r\n                        return colors[parseInt(k)]\r\n                    })\r\n                    .attr(\"opacity\",1)\r\n                    .attr(\"fieldvalue\",value)\r\n                    .on(\"mouseover\",function(d){\r\n                        console.log(d3.select(d.target).attr(\"fieldvalue\"))\r\n                        // console.log(\"2: \"+that.catEnergyField[\"2\"].finalField[y][x])\r\n                        // console.log(x,y)\r\n                        // console.log(\"1: \"+that.catEnergyField[\"1\"].barrierMap[y][x])\r\n\r\n                    })\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawBarrierMap(){\r\n        for(var k in this.catEnergyField){\r\n\r\n\r\n            let map=this.catEnergyField[k].barrierMap\r\n            for(let i=0;i<this.catEnergyField[k].height;i++){\r\n                for(let j=0;j<this.catEnergyField[k].width;j++){\r\n                    let realy=i+this.catEnergyField[k].y\r\n                    let realx=j+this.catEnergyField[k].x\r\n                    if(map[i][j]==3){\r\n                        drawRect(realx,realy,1,1,\"red\")\r\n                    }\r\n                    if(map[i][j]==4){\r\n                        drawRect(realx,realy,1,1,\"green\")\r\n                    }\r\n                    if(map[i][j]==1){\r\n                        drawRect(realx,realy,1,1,\"yellow\")\r\n                    }\r\n                    if(map[i][j]==2){\r\n                        drawRect(realx,realy,1,1,\"orange\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    drawBSpline(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            if(i==0){\r\n                console.log(lines[i]);\r\n            }\r\n            g.append(\"path\")\r\n                .style(\"fill\", color)\r\n                .style(\"stroke\",\"none\")\r\n                // .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 0.5)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0];\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1];\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                    console.log(i)\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', color)\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n    }\r\n\r\n    drawBSplineV2(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        g.append(\"path\")\r\n            .style(\"fill\", color)\r\n            .style(\"stroke\",\"none\")\r\n            // .style(\"stroke-width\", 0.5)\r\n            .style('opacity', 0.5)\r\n            .attr(\"d\", function () {\r\n                var p = \"\";\r\n                p += (d3.line()\r\n                        .x(function (dat) {\r\n                            return dat[0];\r\n                        })\r\n                        .y(function (dat) {\r\n                            return dat[1];\r\n                        })\r\n                )(lines)+ \"\";\r\n                return p;\r\n            })\r\n            .on('mouseover', function () {\r\n                d3.select(this)\r\n                    .style('stroke', \"red\")\r\n                    .style(\"stroke-width\", 3);\r\n            })\r\n            .on('mouseout', function () {\r\n                d3.select(this)\r\n                    .style('stroke', color)\r\n                    .style(\"stroke-width\", 0.5);\r\n            });\r\n\r\n    }\r\n\r\n    fillPolygonForEdge(Polygon, k, field, othercat){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n\r\n                //......\r\n                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                //d3.select('g').append('circle')\r\n                //    .attr('cx',realx)\r\n                //    .attr('cy',realy)\r\n                //    .attr('r',1)\r\n                //    .attr('fill','green')\r\n\r\n                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n\r\n                                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                //d3.select('g').append('circle')\r\n                                //    .attr('cx',realx)\r\n                                //    .attr('cy',realy)\r\n                                //    .attr('r',1)\r\n                                //    .attr('fill','green')\r\n\r\n                                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                                        //d3.select('g').append('circle')\r\n                                        //    .attr('cx',realx)\r\n                                        //    .attr('cy',realy)\r\n                                        //    .attr('r',1)\r\n                                        //    .attr('fill','blue')\r\n                                    }\r\n                                }\r\n\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    fillPolygon(Polygon,k,val,cut = false){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                if(!cut){\r\n                    this.catEnergyField[k].field[fy][fx] = val;\r\n                }\r\n                this.updatedEnergyPoints[k].push([fx,fy])\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n                                //console.log((x_begin,i));\r\n                                //canvas[parseInt(x_begin)][parseInt(i)] = val;\r\n                                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                                if(!cut){\r\n                                    this.catEnergyField[k].field[fy][fx] = val;\r\n                                }\r\n                                this.updatedEnergyPoints[k].push([fx,fy])\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    drawISOLinesV2(k,that,curdata){\r\n\r\n\r\n        for(let i = 0;i < 4;i ++){\r\n            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n        }\r\n        for(let i = 0;i < control_points[k].length; i ++){\r\n            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n            }\r\n        }\r\n        for(let i in control_points){\r\n            if(i == k){\r\n                continue;\r\n            }\r\n            d3.select(\"#path\"+i)\r\n                .attr('fill-opacity', 0.5)\r\n        }\r\n        is_selected[k]=false\r\n        that.editMode=false\r\n\r\n\r\n        colors = this.props.colorArray\r\n\r\n        editSeg[k] = []\r\n\r\n        let len;\r\n\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                console.log(\"dragged control point\")\r\n                console.log(\"(\" + iidx + \", \" + jidx + \")\")\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                            //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                       // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][0], control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 3) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                let p1 = [ control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1] ]\r\n                                let p2 = [ control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1] ]\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                let r1_idx = 0\r\n                                let dis1 = Number.MAX_VALUE\r\n                                let r2_idx = totLen / 5\r\n                                let dis2 = Number.MAX_VALUE\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n\r\n                                    let tmpdis1 = calDistance(p1[0], p1[1], tmp_p.x, tmp_p.y)\r\n                                    let tmpdis2 = calDistance(p2[0], p2[1], tmp_p.x, tmp_p.y)\r\n\r\n                                    if(tmpdis1 < dis1){\r\n                                        r1_idx = p\r\n                                        dis1 = tmpdis1\r\n                                    }\r\n\r\n                                    if(tmpdis2 < dis2){\r\n                                        r2_idx = p\r\n                                        dis2 = tmpdis2\r\n                                    }\r\n\r\n                                    //tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                for(let p = r1_idx; p <= r2_idx; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                    //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n                //    .remove()\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        g.append(\"path\")\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                }\r\n                // .style(\"stroke-width\", 0.5);\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    console.log(\"click!\")\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    reDraw(k,that,curdata){\r\n\r\n        colors = this.props.colorArray\r\n\r\n        let len = control_points[k].length;\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                console.log(\"dragged control point\")\r\n                console.log(\"(\" + iidx + \", \" + jidx + \")\")\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                        //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                        //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        d3.select(\"#path\"+k)\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                    // .style(\"stroke-width\", 0.5);\r\n                }\r\n\r\n\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    console.log(\"click!\")\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    drawOutline(points,color){\r\n\r\n        let SetAreas = new Array();\r\n\r\n        var lineFunction = d3.line()\r\n            .x(function(d) { return d[0]; })\r\n            .y(function(d) { return d[1]; })\r\n            .curve(d3.curveCardinalClosed);\r\n\r\n        let pointpath=lineFunction(points);\r\n\r\n        g.append('path')\r\n            .attr('d', pointpath)\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill',color)\r\n            .attr('fill-rule',\"evenodd\");\r\n    }\r\n\r\n    drawISOLines(lines, intervals,dx,dy,color) {\r\n\r\n        var marginBottomLabel = 0;\r\n\r\n\r\n\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            g.append(\"path\")\r\n                .style(\"fill\", \"none\")\r\n                .style(\"stroke\",color)\r\n                .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 1.0)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0]+dx;\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1]+dy;\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                    console.log(i)\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"black\")\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calOneISOLine(intervals,k){\r\n\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n            let data=this.catEnergyField[k].finalField\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n        return isoLines[0]\r\n    }\r\n\r\n    calISOLine(intervals, fieldData){\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n\r\n\r\n            let data=fieldData[k]\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n        return isoLineDict\r\n    }\r\n\r\n    BSplineInterpolate(points){\r\n        let tpoints=[]\r\n        let splinePoints=[]\r\n        let gap=5\r\n        for (let i=0;i<points.length;i++){\r\n            let remainLength=points.length-i\r\n\r\n            if(remainLength>gap){\r\n                if(i%gap==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n                if(i>0&&i%(3*gap)==0){\r\n                    var spline = new BSpline(tpoints,3)\r\n                    for(var t = 0.01;t<=1;t+=0.01){\r\n                        var p = spline.calcAt(t);\r\n                        splinePoints.push(p)\r\n                    }\r\n                    tpoints=[]\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n            else{\r\n                if(i%3==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        var spline = new BSpline(tpoints,3)\r\n        for(var t = 0.01;t<=1;t+=0.01){\r\n            var p = spline.calcAt(t);\r\n            splinePoints.push(p)\r\n        }\r\n\r\n\r\n        return splinePoints\r\n    }\r\n\r\n    normalizeKernel(kernel){\r\n        let sum=0\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                sum+=kernel[i][j]\r\n            }\r\n        }\r\n\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                kernel[i][j]=kernel[i][j]/sum\r\n            }\r\n        }\r\n        return kernel\r\n    }\r\n\r\n    getGaussianKernel(theta,kernelsize){\r\n        let scale=1\r\n        let kernel=[]\r\n        for (let i=0;i<kernelsize;i++){\r\n            kernel.push([])\r\n            for (let j=0;j<kernelsize;j++){\r\n                kernel[i].push(0)\r\n            }\r\n        }\r\n        let anchor=parseInt(kernelsize/2)/scale\r\n        let C=1/(Math.PI*2*theta*theta)\r\n\r\n        for (let i=0;i<kernelsize;i++){\r\n            for (let j=0;j<kernelsize;j++){\r\n                let ny=i/scale\r\n                let nx=j/scale\r\n                let y=Math.pow(ny-anchor,2)\r\n                let x=Math.pow(nx-anchor,2)\r\n                kernel[i][j]=C*Math.exp(-(x*x+y*y)/(2*theta*theta))\r\n            }\r\n        }\r\n\r\n        kernel=this.normalizeKernel(kernel)\r\n        return kernel\r\n    }\r\n\r\n    checkSingularPoint(k,x,y){\r\n        let delta=1\r\n        let field=this.catEnergyField[k].finalField\r\n        let isSingular=true\r\n        //right\r\n        if(x+delta<this.catEnergyField[k].width){\r\n            if(field[y][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left\r\n        if(x-delta>0){\r\n            if(field[y][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //up\r\n        if(y-delta>0){\r\n            if(field[y-delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //down\r\n        if(y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-top\r\n        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n            if(field[y-delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-bottom\r\n        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-top\r\n        if(x-delta>0&&y-delta>0){\r\n            if(field[y-delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-bottom\r\n        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n\r\n        return isSingular\r\n    }\r\n\r\n    fillCrossingEdge_Part(edges){\r\n\r\n\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<edges.length;i++){\r\n            let cat1=edges[i].cat\r\n            let start1=this.pointData[edges[i].start]\r\n            let end1=this.pointData[edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual && edges[i].virtrualNodes.length > 0){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:edges[i].virtrualNodes[0][0],y:edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:edges[i].virtrualNodes[v][0],y:edges[i].virtrualNodes[v][1]},{x:edges[i].virtrualNodes[v+1][0],y:edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:edges[i].virtrualNodes[vlength-1][0],y:edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=0;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual && this.edges[j].virtrualNodes.length > 0){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    fillCrossingEdge(){\r\n\r\n        //return\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat1=this.edges[i].cat\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:this.edges[i].virtrualNodes[0][0],y:this.edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<this.edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<this.edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:this.edges[i].virtrualNodes[v][0],y:this.edges[i].virtrualNodes[v][1]},{x:this.edges[i].virtrualNodes[v+1][0],y:this.edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=this.edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:this.edges[i].virtrualNodes[vlength-1][0],y:this.edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=i+1;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                // let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                    // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                    // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            for (var k2 in this.catEdgeDict) {\r\n                                let othercat = k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for(var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    smoothEnergyField(bounding){\r\n        let kernelsize = 3\r\n        let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n        let anchor = parseInt(kernelsize/2)\r\n        // console.log(kernel)\r\n        for (var k in this.catEnergyField){\r\n\r\n            let sx = bounding[k].minX;\r\n            let ex = bounding[k].maxX;\r\n            let sy = bounding[k].minY;\r\n            let ey = bounding[k].maxY;\r\n\r\n            let cur_width = ex - sx + 1;\r\n            let cur_height = ey - sy + 1;\r\n\r\n            let newField=[]\r\n            for (let y = 0;y < cur_height + 10;y ++){\r\n                newField.push(new Array(cur_width + 10).fill(0))\r\n            }\r\n\r\n            for (let y = sy; y <= ey; y ++){\r\n                for (let x = sx; x <= ex; x ++){\r\n\r\n                    let newvalue = 0\r\n                    for (let i = 0;i < kernelsize;i ++){\r\n                        for (let j = 0;j < kernelsize;j ++){\r\n                            let dy = i - anchor\r\n                            let dx = j - anchor\r\n                            let ny = y + dy\r\n                            let nx = x + dx\r\n                            if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                                newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                            }\r\n                        }\r\n                    }\r\n                    if(newvalue > 0){\r\n                        newField[y - sy][x - sx] = newvalue\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let y = sy; y <= ey; y ++){\r\n                for(let x = sx; x <= ex; x ++){\r\n                    //console.log(\"(\" + y + \", \" + x + \")\")\r\n                    //console.log(this.catEnergyField[k].finalField)\r\n                    this.catEnergyField[k].finalField[y][x] = newField[y - sy][x - sx]\r\n                }\r\n            }\r\n\r\n            //this.catEnergyField[k].finalField=newField\r\n        }\r\n    }\r\n\r\n    saveOutline(isoLineDict){\r\n        let res=[]\r\n        for (var k in isoLineDict){\r\n            for (let i=0;i<isoLineDict[k].length;i++){\r\n                let formatpoints=[]\r\n                for(let p=0;p<isoLineDict[k][i].length;p++){\r\n                    formatpoints.push({x:isoLineDict[k][i][p][0],y:isoLineDict[k][i][p][1]})\r\n                }\r\n                res.push({\r\n                    cat:k,\r\n                    id:i,\r\n                    isInterior:false,\r\n                    parentID:-1,\r\n                    points:formatpoints\r\n                })\r\n            }\r\n        }\r\n        console.log(JSON.stringify(res))\r\n    }\r\n\r\n    removeOverlaps(){\r\n\r\n        this.updateEnergyPoints()\r\n\r\n        //for(var k in this.catEnergyField){\r\n        //    this.drawEnergyField(k);\r\n        //}\r\n\r\n\r\n        //this.smoothEnergyField()\r\n\r\n        d3.select(\"svg\")\r\n            .selectAll(\"path\")\r\n            .remove()\r\n\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        /*\r\n        intervals=[0.01]\r\n        let isoDict=this.calISOLine(intervals)\r\n\r\n        //for (var k in isoDict){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {}\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    tmp_polygon[k].selectidx = tmp_polygon[k].length - 1;\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        //console.log(tmp_polygon)\r\n        for(var k in isoDict){\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                if(i == sidx){\r\n                    continue;\r\n                }\r\n                let flag = true;\r\n                for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                    flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx]);\r\n                    if(flag == false){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n                    if(tmp_polygon[k][i].length < 30){\r\n                        continue;\r\n                    }\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j += 10){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n            }\r\n        }\r\n\r\n        //console.log(\"hhhh\")\r\n        //console.log(isoDict)\r\n        /*\r\n        for (var k in isoDict){\r\n\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    //console.log(isoDict[k][i])\r\n                    if(!polygontest.hasOwnProperty(k)){\r\n                        polygontest[k] = [];\r\n                    }\r\n                    let tmppolygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        tmppolygon.push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    polygontest[k].push(tmppolygon)\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n\r\n        // re-cal the energy field for inner outline\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].tfinalField = []\r\n            for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                    let val = this.catEnergyField[k].finalField[y][x];\r\n                    let flag = false;\r\n                    for(let idx = 0; idx < polygontest[k].length; idx ++){\r\n                        flag = IsoInsideTest([x, y], polygontest[k][idx])\r\n                        if(flag){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        //console.log(\"test!!\")\r\n                        if(val > 0){\r\n                            this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                        }\r\n                        else{\r\n                            this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.catEnergyField[k].finalField[y][x] = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(this.catEnergyField[k].tfinalField,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n\r\n        for (var k in isoLineDict){\r\n            //console.log(isoLineDict[k])\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                if(isoLineDict[k][i].length < 30){\r\n                    continue;\r\n                }\r\n                let curlen = control_points[k].length;\r\n                control_points[k][curlen] = [];\r\n                for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                    control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let meandis = 0;\r\n                let sz = control_points[k][curlen].length;\r\n                for(let j = 0; j < sz; j ++){\r\n                    meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                        control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                }\r\n                meandis /= sz\r\n                control_points[k][curlen].meandis = meandis;\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        */\r\n\r\n        /*\r\n        for(var k in this.catEnergyField){\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            //this.drawEnergyField(k);\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n        */\r\n\r\n        //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n        //    .remove()\r\n\r\n        for(var k in this.catEnergyField){\r\n            // this.drawEnergyField(k);\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    onChangeEdgeWidth = value => {\r\n        edgeWidth = value\r\n        this.setState({\r\n            edgeWidth:value\r\n        })\r\n        this.changeEdgeWidth(this.selectedEdge,value)\r\n    };\r\n\r\n\r\n    onChangeNodeR0 = value => {\r\n        nodeR0 = value\r\n        this.setState({\r\n            nodeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeNodeR1 = value => {\r\n        nodeR1 = value\r\n        nodeR0=nodeR1-5\r\n        this.setState({\r\n            nodeR1: value,\r\n            nodeR0:nodeR1-5\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR0 = value => {\r\n        edgeR0 = value\r\n        this.setState({\r\n            edgeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR1 = value => {\r\n        edgeR1 = value\r\n        edgeR0=edgeR1-5\r\n        this.setState({\r\n            edgeR1: value,\r\n            edgeR0:edgeR0\r\n        });\r\n    };\r\n\r\n    onChangePixelGroup = value => {\r\n        pixelGroup = value\r\n        this.setState({\r\n            pixelGroup: value,\r\n        });\r\n    };\r\n\r\n    onChangeGap = value => {\r\n        gapBetween = value\r\n        this.setState({\r\n            gapBetween: value,\r\n        });\r\n    };\r\n\r\n    render(){\r\n        return(\r\n\r\n            <div id={\"Sliders\"}>\r\n                <br/>\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>nodeR0</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR0}\r\n                        value={typeof nodeR0 === 'number' ? nodeR0 : 10}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR0}\r\n                        onChange={this.onChangeNodeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Node Radius</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR1}\r\n                        value={typeof nodeR1 === 'number' ? nodeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR1}\r\n                        onChange={this.onChangeNodeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>edgeR0</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR0}\r\n                        value={typeof edgeR0 === 'number' ? edgeR0 : 15}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR0}\r\n                        onChange={this.onChangeEdgeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Global Edge Width</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR1}\r\n                        value={typeof edgeR1 === 'number' ? edgeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR1}\r\n                        onChange={this.onChangeEdgeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Pixel Group</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangePixelGroup}\r\n                            value={typeof pixelGroup === 'number' ? pixelGroup : 2}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={pixelGroup}\r\n                            onChange={this.onChangePixelGroup}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Gap Between Different Groups</h4>\r\n                        <Slider\r\n                            min={0}\r\n                            max={5}\r\n                            onChange={this.onChangeGap}\r\n                            value={typeof gapBetween === 'number' ? gapBetween : 1}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={0}\r\n                            max={5}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={gapBetween}\r\n                            onChange={this.onChangeGap}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Edge Width</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            value={this.state.edgeWidth}\r\n                        disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={this.state.edgeWidth}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                </Row>\r\n\r\n                <br/>\r\n                <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Draw Bubbles\r\n                </Button>\r\n\r\n                <Button onClick = {this.removeOverlaps.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Remove Overlaps\r\n                </Button>\r\n\r\n        </div>)\r\n\r\n    }\r\n}\r\n\r\nexport default AdaptiveIsovalue","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport * as d3 from \"d3\"\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport {Button, Switch} from 'antd';\r\nimport {PointToSegDist} from \"./util\"\r\n\r\nvar FileSaver = require('file-saver');\r\n//import Quadtree from '@timohausmann/quadtree-js'\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\n// var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\n// var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n// var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=10\r\nvar DBSCAN_EPS=40\r\nvar VirtrualNodeBuffer=50\r\n\r\n\r\nvar clustering = require('density-clustering');\r\nvar weightCross=1\r\nvar weightDistance=1\r\nvar weightMess=1\r\n\r\nvar maxCross=Number.MIN_VALUE\r\nvar DISTANCE_THRESHHOLD=Number.MAX_VALUE\r\n\r\nvar priority_queue = require('./priority_queue.js');\r\nvar svgid = \"#mainsvg\"\r\nvar opsvgid = \"#leftsvg\"\r\nvar svg;\r\nvar g;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\n\r\nvar subOldPoints = []\r\nvar addNewPoints = []\r\nvar subOldEdges = []\r\nvar addNewEdges = []\r\nvar editPoints = []\r\nvar editEdges = []\r\nvar preEdges = []\r\nvar tmpEditEdges = []\r\nvar prePoint\r\nvar preEdgeDict\r\nvar curEdgeDict\r\nvar editView = false\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//var Quadtree = require('./quadtree.js');\r\n\r\nclass HierarchicalCluster extends Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            read: false,\r\n            pointData:[],\r\n            edges:[],\r\n            hasinit:false,\r\n            hasEdit:false,\r\n            hascreated:false,\r\n            editV:false,\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        }\r\n        this.issplit=false\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedIndex=-1\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n    }\r\n\r\n    init(){\r\n\r\n        colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n\r\n        POINT_EDGE_EPS = 10\r\n        DBSCAN_EPS = 40\r\n        VirtrualNodeBuffer = 50\r\n\r\n        weightCross = 1\r\n        weightDistance = 1\r\n        weightMess = 1\r\n\r\n        maxCross = Number.MIN_VALUE\r\n        DISTANCE_THRESHHOLD = Number.MAX_VALUE\r\n\r\n        svgid = \"#mainsvg\"\r\n        opsvgid = \"#leftsvg\"\r\n\r\n        subOldPoints = []\r\n        addNewPoints = []\r\n        subOldEdges = []\r\n        addNewEdges = []\r\n        editPoints = []\r\n        editEdges = []\r\n        preEdges = []\r\n        tmpEditEdges = []\r\n        editView = false\r\n\r\n        this.setState({\r\n            read: false,\r\n            pointData:[],\r\n            edges:[],\r\n            hasinit:false,\r\n            hasEdit:false,\r\n            hascreated:false,\r\n            editV:false,\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        })\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n\r\n        this.componentWillMount()\r\n        this.render()\r\n        this.componentDidMount()\r\n\r\n        this.child.init_all()\r\n\r\n    }\r\n\r\n    searchFather(x){\r\n        while(x!=this.f[x]){\r\n            this.f[x] = this.f[this.f[x]];\r\n            x = this.f[x];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    unionFather(x,y){\r\n        this.f[this.searchFather(y)] = this.searchFather(x);\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        // this.setState({\r\n        //     hasLoadData:this.props.hasLoadData\r\n        // })\r\n        //V1\r\n        //this.QTree = new Quadtree({\r\n        //    x: 0,\r\n        //    y: 0,\r\n        //    width: this.canvasWidth,\r\n        //    height: this.canvasHeight\r\n        //});\r\n        //this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n\r\n        d3.select(\"#leftsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        offsetX = minx-20;\r\n        offsetY = miny-20;\r\n        viewWidth = maxx-minx+40;\r\n        viewHeight = maxy-miny+40\r\n\r\n    }\r\n\r\n    calEPS(){\r\n        // POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        let dissum=0\r\n        let disnum=0\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let dis=this.calDistance(this.pointData[i],this.pointData[j])\r\n                dissum+=dis\r\n                disnum+=1\r\n                if(dis>maxDis){\r\n                    maxDis=dis\r\n                }\r\n            }\r\n        }\r\n        POINT_EDGE_EPS=maxDis*0.035\r\n        // DBSCAN_EPS=POINT_EDGE_EPS\r\n        this.maxDis=maxDis\r\n        /*                d3.select(svgid)\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",POINT_EDGE_EPS)\r\n                    .attr(\"cy\",POINT_EDGE_EPS)\r\n                    .attr(\"r\",POINT_EDGE_EPS)\r\n                    .attr(\"fill\",\"black\")*/\r\n\r\n        DISTANCE_THRESHHOLD=dissum/disnum-10\r\n        //console.log(POINT_EDGE_EPS)\r\n        //console.log(\"avreage distance: \"+dissum/disnum)\r\n        //console.log(\"max distance: \"+this.maxDis)\r\n\r\n\r\n    }\r\n\r\n    addNewPoints(point){\r\n\r\n        console.log(\"addNewPoints\")\r\n        point.x=parseFloat(point.x)\r\n        point.y=parseFloat(point.y)\r\n        point.id=this.pointData.length\r\n        point.cat=point.cat.toString()\r\n        let cats=point.cat.split(\",\")\r\n        let catarray=[]\r\n        if (cats.length>1){\r\n            point.multicat=true\r\n            for (let c=0;c<cats.length;c++){\r\n                catarray.push(cats[c])\r\n            }\r\n        }\r\n        else{\r\n            point.multicat=false\r\n            catarray.push(point.cat)\r\n        }\r\n        point.catArray=catarray\r\n\r\n        for (let c=0;c<point.catArray.length;c++){\r\n            let nowcat=point.catArray[c]\r\n            if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                this.catPointDict[nowcat]=[]\r\n            }\r\n            this.catPointDict[nowcat].push(point)\r\n        }\r\n\r\n        this.pointData.push(point)\r\n\r\n        let tmpp1 = clone(this.pointData[this.pointData.length - 1])\r\n        tmpp1.flag = true\r\n        tmpp1.id = this.pointData.length - 1\r\n        editPoints.push(tmpp1)\r\n\r\n        //this.centralizeData()\r\n\r\n        this.calEPS()\r\n\r\n        this.drawPointData()\r\n\r\n        this.optimizeMST(true)\r\n\r\n        this.setState({\r\n            pointData: this.pointData\r\n        })\r\n        this.setState({\r\n            edges: this.edges\r\n        })\r\n\r\n\r\n    }\r\n\r\n    getData(){\r\n\r\n        colors = this.props.colorArray\r\n        this.setState({\r\n            colorArray:colors\r\n        })\r\n\r\n        //let that=this\r\n        //fetch('/data/BubbleSetExample1.txt',{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n        //console.log(data)\r\n\r\n        // if(!this.props.hasLoadData){\r\n        //     return\r\n        // }\r\n\r\n        if(this.state.hasinit){\r\n            this.applyEdit()\r\n        }\r\n        else{\r\n            if(this.props.pointData){\r\n                this.init();\r\n\r\n                if(this.props.edges){\r\n                    this.edges=this.props.edges\r\n                }\r\n                console.log(this.edges.length)\r\n\r\n                // alert(\"Finish input and start creating spanning tree!\");\r\n                this.pointData=this.props.pointData\r\n                //this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                //console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n                    this.pointData[i].id=i\r\n                    this.pointData[i].cat=this.pointData[i].cat.toString()\r\n                    let cats=this.pointData[i].cat.split(\",\")\r\n                    let catarray=[]\r\n                    if (cats.length>1){\r\n                        this.pointData[i].multicat=true\r\n                        for (let c=0;c<cats.length;c++){\r\n                            catarray.push(cats[c])\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.pointData[i].multicat=false\r\n                        catarray.push(this.pointData[i].cat)\r\n                    }\r\n                    this.pointData[i].catArray=catarray\r\n                    for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                        let nowcat=this.pointData[i].catArray[c]\r\n                        if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                            this.catPointDict[nowcat]=[]\r\n                        }\r\n                        this.catPointDict[nowcat].push(this.pointData[i])\r\n                    }\r\n                }\r\n                console.log(this.catPointDict)\r\n                //console.log(this.pointData)\r\n                //console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                this.calEPS()\r\n                d3.select(svgid).selectAll(\"*\").remove();\r\n                this.drawPointData()\r\n                var beginTime = +new Date();\r\n                this.generateTreeWithHierarchical()\r\n                var endTime = +new Date();\r\n\r\n                console.log(\"Spanning tree: \"+(endTime-beginTime)+\"ms\");\r\n\r\n                // console.log(this.edges)\r\n                this.drawEdges()\r\n                this.countEdgeCrossingWithRouting()\r\n                this.props.hasCreate();\r\n\r\n                console.log(this.edges);\r\n                this.setState({\r\n                    pointData: this.pointData\r\n                })\r\n                this.setState({\r\n                    edges: this.edges\r\n                })\r\n                this.setState({\r\n                    hasinit:true\r\n                })\r\n                //})\r\n            }\r\n\r\n        }\r\n        //console.log(this.pointData)\r\n\r\n        return [this.pointData, this.edges, colors]\r\n\r\n    }\r\n\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    checkConnectBetweenAllClusterV2(){\r\n        for(let k in this.clusterDict){\r\n            let m = this.clustergraphInfo[k].edgesnum;\r\n            let n = this.clustergraphInfo[k].nodesnum;\r\n            if (m != n - 1){\r\n                return false;\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    checkConnectBetweenAllCluster(){\r\n        for(let k in this.clusterDict){\r\n            let start=this.clusterDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n            for (let i=1;i<this.clusterDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.clusterDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n\r\n    checkConnectBetweenTwoClusterV2(id1,id2){\r\n        return (this.searchFather(id1)==this.searchFather(id2));\r\n    }\r\n\r\n    checkConnectBetweenTwoCluster(id1,id2){\r\n        var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, id1);\r\n        if (!dfs.hasPathTo(id2)){\r\n            return false\r\n        }\r\n        else{\r\n            return true\r\n        }\r\n    }\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(svgid).append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for(let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n            that.edges[i].SVGElement=[]\r\n        }\r\n\r\n        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        if(d3.select(opsvgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(opsvgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        /*        function dragstartControlpoint(){\r\n                }\r\n                function draggedControlPoint(event){\r\n                    let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n                    that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n                    d3.select(this)\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                        })\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                        })\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n                }\r\n\r\n                var dragControlPoint = d3.drag()\r\n                    .on(\"start\",dragstartControlpoint)\r\n                    .on(\"drag\",draggedControlPoint)\r\n\r\n                function dragstartEdge(event){\r\n                    // console.log(\"start!\")\r\n                    let index=parseInt(d3.select(this).attr(\"index\"))\r\n                    let start=that.pointData[that.edges[index].start]\r\n                    let end=that.pointData[that.edges[index].end]\r\n\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n\r\n                    if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                        let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                        that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=segindex\r\n                    }\r\n                    else{\r\n                        that.edges[index].virtrual=true\r\n                        that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=0\r\n                    }\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .remove()\r\n\r\n                    let vpoints=that.edges[index].virtrualNodes\r\n                    let nowp=[start.x,start.y]\r\n                    let nextp=[]\r\n                    for(let i=0;i<vpoints.length;i++){\r\n                        nextp=vpoints[i]\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .append(\"line\")\r\n                            .attr(\"x1\",nowp[0])\r\n                            .attr(\"y1\",nowp[1])\r\n                            .attr(\"x2\",nextp[0])\r\n                            .attr(\"y2\",nextp[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"index\",index)\r\n                            .attr(\"isvirtrual\",true)\r\n                            .attr(\"segindex\",i)\r\n                            .on(\"mouseover\",function(d,i){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"red\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"black\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mousedown\",handleMouseDown)\r\n                            .call(dragEdge)\r\n\r\n                        nowp=nextp\r\n                    }\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .append(\"line\")\r\n                        .attr(\"x1\",nowp[0])\r\n                        .attr(\"y1\",nowp[1])\r\n                        .attr(\"x2\",end.x)\r\n                        .attr(\"y2\",end.y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",index)\r\n                        .attr(\"isvirtrual\",true)\r\n                        .attr(\"segindex\",vpoints.length)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"red\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mouseout\",function(){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"black\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mousedown\",handleMouseDown)\r\n\r\n                        .call(dragEdge)\r\n\r\n                    for (let v=0;v<vpoints.length;v++){\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .append(\"circle\")\r\n                            .attr(\"class\",\"controlPoints\")\r\n                            .attr(\"cx\",vpoints[v][0])\r\n                            .attr(\"cy\",vpoints[v][1])\r\n                            .attr(\"r\",5)\r\n                            .attr(\"fill\",\"red\")\r\n                            .attr(\"opacity\",0)\r\n                            .attr(\"edgeindex\",index)\r\n                            .attr(\"segindex\",v)\r\n                            // .attr(\"display\",\"none\")\r\n                            .on(\"mouseover\",function(){\r\n                                d3.select(this).attr(\"opacity\",1)\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                d3.select(this).attr(\"opacity\",0)\r\n                            })\r\n                            .call(dragControlPoint)\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n                function draggedEdge(event){\r\n                    // console.log(\"drag!\")\r\n                    if(that.draggedEdgeIndex==-1)\r\n                        return\r\n                    event.sourceEvent.stopPropagation();\r\n                    let edgeIndex=that.draggedEdgeIndex\r\n                    let segIndex=that.draggedEdgeSeg\r\n\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n\r\n                }\r\n\r\n                function dragendEdge(event){\r\n                    // console.log(\"end!\")\r\n                    that.draggedEdgeSeg=-1\r\n                    that.draggedEdgeIndex=-1\r\n                }\r\n\r\n                var dragEdge = d3.drag()\r\n                    .on(\"start\",dragstartEdge)\r\n                    .on(\"drag\",draggedEdge)\r\n                    .on(\"end\",dragendEdge)\r\n\r\n                function handleMouseDown(event){\r\n                    if(event.button==2){\r\n                        let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                            })\r\n                            .attr(\"edgeindex\",function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                            })\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                            })\r\n                            .attr(\"index\",function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))-1\r\n                            })\r\n                        that.edges.splice(deleteindex,1)\r\n\r\n                        for (let i=0;i<that.edges.length;i++){\r\n                            that.edges[i].id=i\r\n                        }\r\n                    }\r\n                }*/\r\n\r\n        d3.selectAll(\"line\").remove()\r\n\r\n        d3.selectAll(\".controlPoints\").remove()\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            /*            let start=this.edges[i].start\r\n                        let end=this.edges[i].end\r\n\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        let index=i\r\n                        if(this.edges[i].virtrual){\r\n                            let vpoints=this.edges[i].virtrualNodes\r\n                            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                            let vend\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                vend=vpoints[v]\r\n                                let newline=d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"line\")\r\n                                    .attr(\"x1\",vstart[0])\r\n                                    .attr(\"y1\",vstart[1])\r\n                                    .attr(\"x2\",vend[0])\r\n                                    .attr(\"y2\",vend[1])\r\n                                    .attr(\"stroke-width\",2)\r\n                                    .attr(\"stroke\",\"black\")\r\n                                    .attr(\"index\",i)\r\n                                    .attr(\"isvirtrual\",true)\r\n                                    .attr(\"segindex\",v)\r\n                                    .on(\"mouseover\",function(d,i){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"red\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"black\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                                    .call(dragEdge)\r\n                                vstart=vend\r\n                                if(v==0){\r\n                                    this.nodeStartDict[start].push(newline)\r\n                                }\r\n                            }\r\n                            vend=[this.pointData[end].x,this.pointData[end].y]\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",vstart[0])\r\n                                .attr(\"y1\",vstart[1])\r\n                                .attr(\"x2\",vend[0])\r\n                                .attr(\"y2\",vend[1])\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",true)\r\n                                .attr(\"segindex\",vpoints.length)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeEndDict[end].push(newline)\r\n                            // console.log()\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"circle\")\r\n                                    .attr(\"class\",\"controlPoints\")\r\n                                    .attr(\"cx\",vpoints[v][0])\r\n                                    .attr(\"cy\",vpoints[v][1])\r\n                                    .attr(\"r\",5)\r\n                                    .attr(\"edgeindex\",i)\r\n                                    .attr(\"segindex\",v)\r\n                                    .attr(\"fill\",\"red\")\r\n                                    .attr(\"opacity\",0)\r\n                                    // .attr(\"display\",\"none\")\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"opacity\",1)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"opacity\",0)\r\n                                    })\r\n                                    .call(dragControlPoint)\r\n\r\n                            }\r\n                        }\r\n                        else{\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",this.pointData[start].x)\r\n                                .attr(\"y1\",this.pointData[start].y)\r\n                                .attr(\"x2\",this.pointData[end].x)\r\n                                .attr(\"y2\",this.pointData[end].y)\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",false)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeStartDict[start].push(newline)\r\n                            this.nodeEndDict[end].push(newline)\r\n                        }*/\r\n\r\n            this.drawOneEdge(i)\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        // console.log(this.edges)\r\n        // d3.selectAll(\"line\").remove()\r\n        // let that=this\r\n        // for(let i=0;i<this.edges.length;i++){\r\n        //     let node1=this.edges[i].start\r\n        //     let node2=this.edges[i].end\r\n        //\r\n        //     d3.select(svgid).append(\"line\")\r\n        //         .attr(\"x1\",this.pointData[node1].x)\r\n        //         .attr(\"y1\",this.pointData[node1].y)\r\n        //         .attr(\"x2\",this.pointData[node2].x)\r\n        //         .attr(\"y2\",this.pointData[node2].y)\r\n        //         .attr(\"stroke-width\",2)\r\n        //         .attr(\"stroke\",\"black\")\r\n        //         .attr(\"index\",i)\r\n        //         .on(\"click\",function(){\r\n        //             let removeindex=d3.select(this).attr(\"index\")\r\n        //             that.edges[removeindex].isdelete=true\r\n        //             d3.select(this).remove()\r\n        //             console.log(that.edges)\r\n        //         })\r\n        // }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/manuallyDataEdge.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    optimizeMST(isedit){\r\n\r\n        this.clustergraphInfo={}\r\n        let newGraph=new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<newGraph.V;i++){\r\n            newGraph.node(i).label=this.pointData[i].cat\r\n        }\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let cat=this.edges[i].cat\r\n            newGraph.addEdge(start,end)\r\n            // this.clustergraphInfo[cat].edgesnum+=1\r\n        }\r\n\r\n        this.graph=newGraph\r\n        //find Connected Components\r\n        var cc = new jsgraphs.ConnectedComponents(newGraph);\r\n        console.log(cc.componentCount());\r\n\r\n\r\n\r\n        //create new clusterDict with connected components\r\n        let newClusterDict={}\r\n        for (let k in this.catPointDict){\r\n            newClusterDict[k]=[]\r\n        }\r\n        let clusterArr=[]\r\n        for (let i=0;i<cc.componentCount();i++){\r\n            clusterArr.push([])\r\n        }\r\n        for (var v = 0; v < newGraph.V; v++) {\r\n            let point=this.pointData[v]\r\n            let comid=cc.componentId(v)\r\n            clusterArr[comid].push(point)\r\n        }\r\n        for(let i=0;i<clusterArr.length;i++){\r\n            let cat=clusterArr[i][0].cat\r\n            newClusterDict[cat].push(clusterArr[i])\r\n        }\r\n        this.clusterDict=newClusterDict\r\n        // console.log(newClusterDict)\r\n\r\n        for (let k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n        }\r\n\r\n        clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n            }\r\n\r\n        }\r\n\r\n        this.clusterArr=clusterArr\r\n        // console.log(this.clusterArr)\r\n        let g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n\r\n        //update boundingbox of points\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n        if(!isedit){\r\n            let newEdges=this.recalculateSpanningTree()\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n\r\n            // this.drawEdges()\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdge(newEdges[i])\r\n                this.edges[newEdges[i]].new = true\r\n                //let tmpe = clone(this.edges[newEdges[i]])\r\n                //tmpe.id = newEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                //addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            this.countEdgeCrossing()\r\n            this.draggedIndex=-1\r\n            this.deletedEdge=[]\r\n            this.addedEdge=[]\r\n            this.setState({\r\n                pointData:this.pointData,\r\n                edges:this.edges\r\n            })\r\n        }\r\n        else{\r\n            let tempedges=[]\r\n            for (let i=0;i<this.edges.length;i++){\r\n                /*                tempedges.push(\r\n                                    {\r\n                                        start:this.edges[i].start,\r\n                                        end:this.edges[i].end,\r\n                                        weight:this.edges[i].weight,\r\n                                        cat:this.edges[i].cat,\r\n                                        dis:this.edges[i].dis,\r\n                                        virtrual:this.edges[i].virtrual,\r\n                                        virtrualNodes:this.edges[i].virtrualNodes,\r\n                                        isLocalTree:this.edges[i].isLocalTree\r\n                                    }\r\n                                )*/\r\n                tempedges.push(this.edges[i])\r\n            }\r\n\r\n            let newEdges=this.recalculateSpanningTreeAfterEdit(tempedges)\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n            // this.drawEdges()\r\n            d3.selectAll(\".deleteOpEdge\")\r\n                .remove()\r\n\r\n            tmpEditEdges = []\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdgeAfterEdit(tempedges,newEdges[i])\r\n                //console.log(\"newEdges:\")\r\n                //console.log(this.edges)\r\n                //console.log(tempedges)\r\n                //console.log(newEdges[i])\r\n                let tmpe = clone(tempedges[newEdges[i]])\r\n                tmpe.id = newEdges[i]\r\n                tmpe.flag = true\r\n                tmpEditEdges.push(tmpe)\r\n            }\r\n            this.tempEdges=tempedges\r\n            // console.log(this.edges.length,this.tempEdges.length)\r\n\r\n        }\r\n\r\n    }\r\n\r\n    sufaceRoutingAll(){\r\n        for (let ei=0;ei<this.edges.length;ei++){\r\n            let thisedge=this.edges[ei]\r\n            let startp=this.pointData[thisedge.start.id]\r\n            let endp=this.pointData[thisedge.end.id]\r\n            let pcat=this.pointData[thisedge.start.id].cat\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[ei].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[ei].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[ei].virtrualNodes=virtrualNodes\r\n        }\r\n\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        if(virtrualNodes.length==0){\r\n            edge.virtrual=false\r\n        }\r\n        return edge\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n\r\n        let crossnum=0\r\n        let start = this.pointData[index1]\r\n        let end = this.pointData[index2]\r\n        for(let e=0;e<this.edges.length;e++){\r\n            let e1=this.pointData[this.edges[e].start]\r\n            let e2=this.pointData[this.edges[e].end]\r\n            if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                crossnum+=1\r\n            }\r\n        }\r\n        //cal distance\r\n        let distance=this.calDistance(start, end)\r\n        //cal num of other points\r\n        let mess=this.calEdgeMess(start, end)\r\n        let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n        newedge.score = score\r\n\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function dragstartControlpoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag start control point!\")\r\n            //console.log(index)\r\n            editEdges = []\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(that.pointData[that.edges[index].start])\r\n            tmpe.endpoint = clone(that.pointData[that.edges[index].end])\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n        }\r\n        function draggedControlPoint(event){\r\n            let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n            that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n            that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n            let idx = \"#\" + d3.select(this).attr(\"id\")\r\n            //console.log(\"dragged control point\")\r\n            //console.log(idx)\r\n            d3.selectAll(idx)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                })\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                })\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n        }\r\n        function dragendControlPoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag end control point!\")\r\n            //console.log(index)\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.id = index\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var dragControlPoint = d3.drag()\r\n            .on(\"start\",dragstartControlpoint)\r\n            .on(\"drag\",draggedControlPoint)\r\n            .on(\"end\",dragendControlPoint)\r\n\r\n        function dragstartEdge(event){\r\n            console.log(\"drag start edge!\")\r\n            // console.log(\"start!\")\r\n            let index=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            let start=that.pointData[that.edges[index].start]\r\n            let end=that.pointData[that.edges[index].end]\r\n\r\n            editEdges = []\r\n//\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(start)\r\n            tmpe.endpoint = clone(end)\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n\r\n            if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=segindex\r\n            }\r\n            else{\r\n                that.edges[index].virtrual=true\r\n                that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=0\r\n            }\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .remove()\r\n\r\n            /*            for (let j=0;j<that.edges[index].SVGElement.length;j++){\r\n                            that.edges[index].SVGElement[j].remove()\r\n                        }*/\r\n\r\n            that.edges[index].SVGElement=[]\r\n\r\n            let vpoints=that.edges[index].virtrualNodes\r\n            let nowp=[start.x,start.y]\r\n            let nextp=[]\r\n            for(let i=0;i<vpoints.length;i++){\r\n                nextp=vpoints[i]\r\n                let newedge=d3.select(svgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n\r\n                d3.select(opsvgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n                that.edges[index].SVGElement.push(newedge)\r\n                nowp=nextp\r\n            }\r\n            let newline=d3.select(svgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n\r\n            that.edges[index].SVGElement.push(newline)\r\n\r\n\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function draggedEdge(event){\r\n            // console.log(\"drag!\")\r\n            if(that.draggedEdgeIndex==-1)\r\n                return\r\n            event.sourceEvent.stopPropagation();\r\n            let edgeIndex=that.draggedEdgeIndex\r\n            let segIndex=that.draggedEdgeSeg\r\n\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n\r\n            d3.selectAll(\".controlPoints\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n\r\n        }\r\n\r\n        function dragendEdge(event){\r\n            // console.log(\"end!\")\r\n            let i = that.draggedEdgeIndex\r\n            let tmpe = clone(that.edges[i])\r\n            tmpe.id = i\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n//\r\n//\r\n            editPoints = []\r\n            editEdges = []\r\n\r\n\r\n            that.draggedEdgeSeg=-1\r\n            that.draggedEdgeIndex=-1\r\n            //that.child.getData()\r\n        }\r\n\r\n        var dragEdge = d3.drag()\r\n            .on(\"start\",dragstartEdge)\r\n            .on(\"drag\",draggedEdge)\r\n            .on(\"end\",dragendEdge)\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                that.setState({\r\n                    hasEdit:true\r\n                })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n\r\n                let tmpe = clone(that.edges[deleteindex])\r\n                tmpe.startpoint = clone(that.pointData[start])\r\n                tmpe.endpoint = clone(that.pointData[end])\r\n                tmpe.flag = false\r\n                editEdges.push(tmpe)\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n                if(that.child.bubbleState()){\r\n                    //console.log(\"delete one edge\")\r\n                    //console.log(editEdges)\r\n                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                }\r\n\r\n\r\n                editPoints = []\r\n                editEdges = []\r\n\r\n                that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n\r\n                that.optimizeMST(true)\r\n\r\n                for (var k in that.catPointDict){\r\n                    that.findCircle(k)\r\n                }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n            //else if(event.button == 1){\r\n            //    that.child.handleEdgeWidth(event, this)\r\n            //}\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    applyEdit(){\r\n        this.edges=this.tempEdges\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n\r\n        this.drawEdges()\r\n        this.setState({\r\n            hasEdit:false,\r\n            edges:this.edges,\r\n            pointData:this.pointData\r\n        })\r\n\r\n        //console.log(\"applyEdit\")\r\n        //console.log(tmpEditEdges)\r\n        //console.log(this.edges)\r\n\r\n        //let tmprealEditEdges = []\r\n//\r\n        //for(let i = 0; i < this.edges.length;i ++){\r\n        //    for(let j = 0; j < tmpEditEdges.length; j ++){\r\n        //        if(this.edges[i].start == tmpEditEdges[j].start && this.edges[i].end == tmpEditEdges[j].end){\r\n        //            let tmpe = clone(this.edges[i])\r\n        //            tmpe.flag = true\r\n        //            tmpe.id = i\r\n        //            tmprealEditEdges.push(tmpe)\r\n        //            break;\r\n        //        }\r\n        //    }\r\n        //}\r\n\r\n        if(this.child.bubbleState()){\r\n            this.child.editReDraw([], tmpEditEdges, this.pointData, this.edges)\r\n        }\r\n\r\n        tmpEditEdges = []\r\n    }\r\n\r\n    drawOneEdgeAfterEdit(edges,index){\r\n\r\n        edges[index].SVGElement=[]\r\n        let oneEdge=edges[index]\r\n        let that=this\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                d3.selectAll(\".deleteOpEdge\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                    })\r\n                    .remove()\r\n                let start=edges[deleteindex].start\r\n                let end=edges[deleteindex].end\r\n                that.deletedEdge.push([start,end])\r\n\r\n                // that.deleteEdge(deleteindex)\r\n                that.optimizeMST(true)\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            // console.log()\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    checkCircle(k){\r\n        let catEdges=[]\r\n        let nodeDegree={}\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(this.edges[i].cat==k){\r\n                catEdges.push(this.edges[i])\r\n                let start=this.edges[i].start\r\n                let end=this.edges[i].end\r\n                if(!nodeDegree.hasOwnProperty(start)){\r\n                    nodeDegree[start]=[]\r\n                }\r\n                nodeDegree[start].push(i)\r\n                if(!nodeDegree.hasOwnProperty(end)){\r\n                    nodeDegree[end]=[]\r\n                }\r\n                nodeDegree[end].push(i)\r\n            }\r\n        }\r\n        let finish=false\r\n        while(!finish){\r\n            finish=true\r\n            for(var p in nodeDegree){\r\n                if(nodeDegree[p].length==1){\r\n                    finish=false\r\n                    let index=nodeDegree[p][0]\r\n                    let start=this.edges[index].start\r\n                    let end=this.edges[index].end\r\n                    for (let i=0;i<nodeDegree[start].length;i++){\r\n                        if(nodeDegree[start][i]==index){\r\n                            nodeDegree[start].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                    for (let i=0;i<nodeDegree[end].length;i++){\r\n                        if(nodeDegree[end][i]==index){\r\n                            nodeDegree[end].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let circleEdges=[]\r\n        for (var p in nodeDegree){\r\n            if(nodeDegree[p].length>0){\r\n                for (let i=0;i<nodeDegree[p].length;i++){\r\n                    let edgeindex=nodeDegree[p][i]\r\n                    let has=false\r\n                    for (let j=0;j<circleEdges.length;j++){\r\n                        if(circleEdges[j]==edgeindex){\r\n                            has=true\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!has){\r\n                        circleEdges.push(edgeindex)\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        // console.log(nodeDegree,circleEdges)\r\n        return circleEdges\r\n    }\r\n\r\n    findCircle(lastcat){\r\n        let that=this\r\n        let circleEdges=that.checkCircle(lastcat)\r\n        if(circleEdges.length>0){\r\n            let scores=[]\r\n            for (let i=0;i<circleEdges.length;i++){\r\n                let index=circleEdges[i]\r\n\r\n                let start=that.pointData[that.edges[index].start]\r\n                let end=that.pointData[that.edges[index].end]\r\n                let crossnum=0\r\n                if(that.isAdded(that.edges[index].start,that.edges[index].end)){\r\n                    scores.push(-1)\r\n                }\r\n                else{\r\n                    for (let e=0;e<that.edges.length;e++){\r\n                        let e1=that.pointData[that.edges[e].start]\r\n                        let e2=that.pointData[that.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&that.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //cal distance\r\n                    let distance=that.calDistance(start,end)\r\n                    //cal num of other points\r\n                    let mess=that.calEdgeMess(start,end)\r\n                    let score=weightCross*crossnum+weightDistance*distance/that.maxDis+weightMess*mess\r\n                    scores.push(score)\r\n                }\r\n\r\n                /*                                    d3.select(svgid)\r\n                                                        .select(\"#edgeGroup\")\r\n                                                        .selectAll(\"line\")\r\n                                                        .filter(function(){\r\n                                                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                                                        })\r\n                                                        .attr(\"stroke\",\"blue\")\r\n                                                        .on(\"mouseover\",function(){\r\n                                                            console.log(scores[i])\r\n                                                        })*/\r\n            }\r\n\r\n            let worstindex=-1\r\n            let worstscore=-100\r\n            for (let i=0;i<scores.length;i++){\r\n                if(scores[i]>worstscore){\r\n                    worstscore=scores[i]\r\n                    worstindex=i\r\n                }\r\n            }\r\n            let worstEdge=that.edges[circleEdges[worstindex]]\r\n\r\n            //let tmpe = clone(worstEdge)\r\n            //tmpe.startpoint = clone(worstEdge.start)\r\n            //tmpe.endpoint = clone(worstEdge.end)\r\n            //tmpe.flag = false\r\n            //tmpEditEdges.push(tmpe)\r\n\r\n\r\n            //console.log(\"WorstEdge: \")\r\n            //console.log(circleEdges)\r\n            //console.log(worstEdge)\r\n            //console.log(that.edges)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==worstEdge.id\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-width\",5)\r\n            // console.log(weightMess)\r\n\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        colors = this.props.colorArray\r\n        this.setState({\r\n            colorArray:colors\r\n        })\r\n\r\n        d3.selectAll(\"circle\").remove();\r\n        d3.selectAll(\"rect\").remove();\r\n        svg = d3.select(svgid);\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        var reroutingEPS=80\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            console.log(\"dragging points......\")\r\n            let svg=d3.select(svgid)\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            // console.log(POINT_EDGE_EPS,DBSCAN_EPS)\r\n            if(that.itemShape==\"circle\"){\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n            //let tmpp1 = clone(that.pointData[nodeindex])\r\n            //tmpp1.flag = false;\r\n            //editPoints.push(tmpp1)\r\n            //subOldPoints.push(tmpp1)\r\n\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n\r\n            //let tmpp = clone(that.pointData[nodeindex])\r\n            //tmpp.id = nodeindex\r\n            //tmpp.flag = true\r\n            //editPoints.push(tmpp)\r\n            //addNewPoints.push(tmpp)\r\n\r\n            let deleteEdges=[]\r\n            let reroutingEdges=[]\r\n            let thiscat=that.pointData[nodeindex].cat\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let startpoint=that.pointData[that.edges[i].start]\r\n                let endpoint=that.pointData[that.edges[i].end]\r\n                let pointedgedis=PointToSegDist(event.x,event.y,startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(that.edges[i].start==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(tmpp1)\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(that.edges[i].end==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(tmpp1)\r\n                    //tmpe.flag = false;\r\n                    ////subOldEdges.push(tmpe)\r\n                    //editEdges.push(tmpe)\r\n                }\r\n                else if((thiscat==that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2)){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n                else if(thiscat!=that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2){\r\n                    reroutingEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // console.log(deleteEdges)\r\n\r\n            for(let i=0;i<deleteEdges.length;i++){\r\n                that.deleteEdge(deleteEdges[i])\r\n                for(let j=i+1;j<deleteEdges.length;j++){\r\n                    if(deleteEdges[i]<deleteEdges[j]){\r\n                        deleteEdges[j]=deleteEdges[j]-1\r\n                    }\r\n                }\r\n                for(let j=i+1;j<reroutingEdges.length;j++){\r\n                    if(deleteEdges[i]<reroutingEdges[j]){\r\n                        reroutingEdges[j]=reroutingEdges[j]-1\r\n                    }\r\n                }\r\n            }\r\n\r\n            that.optimizeMST(false)\r\n\r\n            for (let i=0;i<reroutingEdges.length;i++){\r\n\r\n\r\n                let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                tmpe.startpoint = clone(that.pointData[tmpe.start])\r\n                tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                tmpe.flag = false\r\n                that.edges[reroutingEdges[i]].preEdge = clone(tmpe)\r\n                that.edges[reroutingEdges[i]].new = true\r\n                that.edges[reroutingEdges[i]].rerouting = true\r\n\r\n\r\n                that.surfaceRoutingEdge(that.edges[reroutingEdges[i]])\r\n                d3.selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n                d3.selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n\r\n                that.drawOneEdge(reroutingEdges[i])\r\n\r\n\r\n\r\n                //let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                //tmpe.id = reroutingEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                // addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            //that.child.getData()\r\n            //for(let idx1 = 0; idx1 < addNewPoints.length; idx1 ++){\r\n            //    for(let idx2 = 0; idx2 < that.edges.length; idx2 ++){\r\n            //        if(that.edges[idx2].start == addNewPoints[idx1].id || that.edges[idx2].end == addNewPoints[idx1].id){\r\n            //            let tmpe = clone(that.edges[idx2])\r\n            //            tmpe.id = idx2\r\n            //            addNewEdges.push(tmpe)\r\n            //            //console.log(\"flagflagflag\")\r\n            //        }\r\n            //    }\r\n            //}\r\n\r\n\r\n\r\n\r\n\r\n            // d3.select(this).attr(\"stroke\",\"none\")\r\n\r\n        }\r\n\r\n        function dragstart() {\r\n            console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            // that.draggedIndex=parseInt(d3.select(this).attr(\"index\"))\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n            that.draggedIndex=nodeindex\r\n\r\n            preEdgeDict = {}\r\n            preEdges = []\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                that.edges[i].new = false;\r\n                that.edges[i].rerouting = false;\r\n                that.edges[i].startpoint = clone(that.pointData[st])\r\n                that.edges[i].endpoint = clone(that.pointData[en])\r\n\r\n                if(!preEdgeDict.hasOwnProperty(st)){\r\n                    preEdgeDict[st] = {}\r\n                }\r\n                preEdgeDict[st][en] = i\r\n\r\n                preEdges.push(clone(that.edges[i]))\r\n            }\r\n\r\n            // add old point\r\n            let tmpp1 = clone(that.pointData[nodeindex])\r\n            prePoint = tmpp1\r\n            tmpp1.flag = false\r\n            editPoints.push(tmpp1)\r\n\r\n            //preEdges = clone(that.edges)\r\n\r\n            //delete linked edges\r\n            /*            let newedges=[]\r\n            let deleteindex=[]\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let start=that.edges[i].start\r\n                let end=that.edges[i].end\r\n                if(start==nodeindex||end==nodeindex){\r\n                    console.log(i)\r\n                    d3.select(svgid)\r\n                        .select(\"#edgeGroup\")\r\n                        .selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==i\r\n                        })\r\n                        // .attr(\"stroke\",\"red\")\r\n                        .remove()\r\n                    deleteindex.push(i)\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))==i\r\n                        })\r\n                        // .attr(\"opacity\",1)\r\n                        .remove()\r\n                }\r\n                else{\r\n                    newedges.push(that.edges[i])\r\n                }\r\n            }\r\n            let influencedEdges=[]\r\n            let influencedControlPoints=[]\r\n            for (let i=0;i<deleteindex.length;i++) {\r\n                let idx=deleteindex[i]\r\n                let inflines=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))>idx\r\n                    })\r\n                influencedEdges.push(inflines)\r\n\r\n                let infpoints=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))>idx\r\n                    })\r\n                influencedControlPoints.push(infpoints)\r\n            }\r\n                for (let i=0;i<influencedEdges.length;i++){\r\n                    let infedges=influencedEdges[i]\r\n                    infedges.attr(\"index\",function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                    })\r\n            }\r\n                for(let i=0;i<influencedControlPoints.length;i++){\r\n                    let infcpoints=influencedControlPoints[i]\r\n                    infcpoints.attr(\"edgeindex\",function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                        })\r\n                }\r\n\r\n            that.edges=newedges\r\n            for(let i=0;i<that.edges.length;i++){\r\n                that.edges[i].id=i\r\n            }*/\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        function dragend(){\r\n            console.log(\"end!\")\r\n            let nodeindex = parseInt(d3.select(this).attr(\"index\"))\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"none\")\r\n\r\n            // add new point\r\n            let tmpp = clone(that.pointData[nodeindex])\r\n            tmpp.id = nodeindex\r\n            tmpp.flag = true\r\n            editPoints.push(tmpp)\r\n\r\n            /*\r\n            // delete old edges\r\n            let thiscat = that.pointData[nodeindex].cat\r\n            let ex = that.pointData[nodeindex].x\r\n            let ey = that.pointData[nodeindex].y\r\n            //let updateidx = {}\r\n            for(let i = 0;i < preEdges.length; i ++){\r\n                let startpoint=that.pointData[preEdges[i].start]\r\n                let endpoint=that.pointData[preEdges[i].end]\r\n                let pointedgedis=PointToSegDist(ex, ey, startpoint.x, startpoint.y, endpoint.x, endpoint.y)\r\n                if(preEdges[i].start==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = clone(prePoint)\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(preEdges[i].end==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = clone(prePoint)\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if((thiscat == preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2)){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false;\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                    //    updateidx[preEdges[i].start] = {}\r\n                    //}\r\n//\r\n                    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n\r\n                }\r\n\r\n                //else if(thiscat != preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2){\r\n//\r\n                //    let tmpe = clone(preEdges[i])\r\n                //    tmpe.startpoint = that.pointData[tmpe.start]\r\n                //    tmpe.endpoint = that.pointData[tmpe.end]\r\n                //    tmpe.flag = false;\r\n                //    editEdges.push(tmpe)\r\n                //    //subOldEdges.push(tmpe)\r\n//\r\n                //    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                //    //    updateidx[preEdges[i].start] = {}\r\n                //    //}\r\n////\r\n                //    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n//\r\n                //}\r\n\r\n\r\n            }\r\n\r\n            // add new edges and rerouting edges\r\n            for(let i = 0;i < that.edges.length; i ++){\r\n\r\n                //if(that.edges[i].hasOwnProperty(\"new\")){\r\n                if(that.edges[i].new == true){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    if(that.edges[i].rerouting == true){\r\n                        let tmpe = clone(that.edges[i].preEdge)\r\n                        tmpe.flag = false\r\n                        editEdges.push(tmpe)\r\n                    }\r\n                }\r\n                //}\r\n\r\n\r\n                //let s = that.edges[i].start\r\n                //let e = that.edges[i].end\r\n                //let flag = false;\r\n                //if(s == nodeindex || e == nodeindex){\r\n                //    flag = true\r\n                //}\r\n//\r\n                //for(let st in updateidx){\r\n                //    for(let en in updateidx[st]){\r\n                //        if(s == st && e == en){\r\n                //            flag = true\r\n                //            break\r\n                //        }\r\n                //    }\r\n                //}\r\n//\r\n                //if(flag){\r\n                //    let tmpe = clone(that.edges[i])\r\n                //    tmpe.id = i\r\n                //    tmpe.flag = true\r\n                //    editEdges.push(tmpe)\r\n                //}\r\n\r\n\r\n            }\r\n\r\n             */\r\n\r\n            editEdges = []\r\n            curEdgeDict = {}\r\n\r\n            // Add New Edges\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                if(!curEdgeDict.hasOwnProperty(st)){\r\n                    curEdgeDict[st] = {}\r\n                }\r\n                curEdgeDict[st][en] = i\r\n                let vnodes1 = clone(that.edges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                // same flag\r\n                let flag = true\r\n                // exist flag\r\n                let flag1 = true\r\n                // judge st --> en\r\n                if(preEdgeDict.hasOwnProperty(st)){\r\n                    if(preEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag point?\r\n                        // startpoint\\endpoint\\control points\r\n                        let idx = preEdgeDict[st][en]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].startpoint\r\n                        let en2_p = preEdges[idx].endpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                //judge en --> st\r\n                if(preEdgeDict.hasOwnProperty(en)){\r\n                    if(preEdgeDict[en].hasOwnProperty(st)){\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag poing?\r\n                        flag1 = false\r\n                        let idx = preEdgeDict[en][st]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].endpoint\r\n                        let en2_p = preEdges[idx].startpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // Delete Old Edges\r\n            for(let i = 0; i < preEdges.length; i ++){\r\n                let st = preEdges[i].start\r\n                let en = preEdges[i].end\r\n                let vnodes1 = clone(preEdges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                let flag = true\r\n                let flag1 = true\r\n                if(curEdgeDict.hasOwnProperty(st)){\r\n                    if(curEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[st][en]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                if(curEdgeDict.hasOwnProperty(en)){\r\n                    if(curEdgeDict[en].hasOwnProperty(st)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[en][st]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",dragend)\r\n\r\n\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2 && !that.props.isedit){\r\n                console.log(\"click\")\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                    let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                    d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                        let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n\r\n                                let tmpe = clone(that.edges[that.edges.length - 1])\r\n                                tmpe.id = that.edges.length - 1\r\n                                tmpe.flag = true\r\n                                editEdges.push(tmpe)\r\n                                that.setState({\r\n                                    pointData: that.pointData\r\n                                })\r\n\r\n                                that.setState({\r\n                                    edges: that.edges\r\n                                })\r\n\r\n                                //console.log(that.edges)\r\n\r\n                                if(that.child.bubbleState()){\r\n                                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                                }\r\n\r\n                                editPoints = []\r\n                                editEdges = []\r\n\r\n\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n\r\n                            idx = \"#\" + d3.select(this).attr(\"id\")\r\n\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n                                .attr(\"id\",d3.select(this).attr(\"id\"))\r\n\r\n\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(event.button==2 && that.props.isedit){\r\n\r\n                let idx = parseInt(d3.select(event.path[0]).attr(\"index\"))\r\n\r\n                // delete node and edges\r\n                let catarray = that.pointData[idx].catArray\r\n                for(let c = 0; c < catarray.length; c ++){\r\n                    let nowcat = catarray[c]\r\n                    for(let j = 0; j < that.catPointDict[nowcat].length; j ++){\r\n                        if(that.catPointDict[nowcat][j].id == idx){\r\n                            that.catPointDict[nowcat].splice(j, 1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for(let i = that.edges.length - 1; i >= 0; i --){\r\n                    let st = that.edges[i].start\r\n                    let en = that.edges[i].end\r\n                    if(st == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                    else if(en == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                }\r\n\r\n                that.pointData.splice(idx, 1);\r\n\r\n                // modify svg index and data index\r\n                d3.selectAll(\"#edgeGroup\").remove()\r\n                d3.selectAll(\"#pointGroup\").remove()\r\n\r\n                for(let i = 0; i < that.pointData.length; i ++){\r\n                    if(that.pointData[i].id > idx){\r\n                        that.pointData[i].id -= 1\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < that.edges.length; i ++){\r\n                    if(that.edges[i].start > idx){\r\n                        that.edges[i].start -= 1\r\n                    }\r\n                    if(that.edges[i].end > idx){\r\n                        that.edges[i].end -= 1\r\n                    }\r\n                }\r\n\r\n                that.drawPointData()\r\n                that.drawEdges()\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n\r\n                console.log(\"delete pointdata!\")\r\n\r\n            }\r\n        }\r\n\r\n        let items=[]\r\n        d3.select(svgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        d3.select(opsvgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        // this.itemShape=\"circle\"\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    countEdgeCrossingWithRouting(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let lines1=[]\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vnodes=this.edges[i].virtrualNodes\r\n                lines1.push([start1.x,start1.y])\r\n                for (let p=0;p<vnodes.length;p++){\r\n                    lines1.push(vnodes[p])\r\n                }\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            else{\r\n                lines1.push([start1.x,start1.y])\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let lines2=[]\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat==start2.cat){\r\n                    continue\r\n                }\r\n                if(this.edges[j].virtrual){\r\n                    let vnodes=this.edges[j].virtrualNodes\r\n                    lines2.push([start2.x,start2.y])\r\n                    for (let p=0;p<vnodes.length;p++){\r\n                        lines2.push(vnodes[p])\r\n                    }\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                else{\r\n                    lines2.push([start2.x,start2.y])\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                for (let l1=0;l1<lines1.length-1;l1++){\r\n                    let p1={x:lines1[l1][0],y:lines1[l1][1]}\r\n                    let p2={x:lines1[l1+1][0],y:lines1[l1+1][1]}\r\n                    for (let l2=0;l2<lines2.length-1;l2++){\r\n                        let p3={x:lines2[l2][0],y:lines2[l2][1]}\r\n                        let p4={x:lines2[l2+1][0],y:lines2[l2+1][1]}\r\n                        if(this.checkEdgeCrossing(p1,p2,p3,p4)){\r\n                            count+=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n        console.log(\"num of edge crossing:\" +count)\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    createLocalTree(points){\r\n\r\n        //1. find center point\r\n        //2. generate tree\r\n        let midx=0\r\n        let midy=0\r\n        for (let i=0;i<points.length;i++){\r\n            midx+=points[i].x\r\n            midy+=points[i].y\r\n        }\r\n        midx=midx/points.length\r\n        midy=midy/points.length\r\n        let midnode={\r\n            x:midx,\r\n            y:midy\r\n        }\r\n        let minDis=Number.MAX_VALUE\r\n        let minindex=-1\r\n        for (let i=0;i<points.length;i++){\r\n            let dis=this.calDistance(midnode,points[i])\r\n            if(dis<minDis){\r\n                minDis=dis\r\n                minindex=i\r\n            }\r\n        }\r\n\r\n\r\n\r\n        for (let i=0;i<points.length;i++){\r\n            if(i!=minindex){\r\n                this.edges.push({\r\n                    start:points[minindex].id,\r\n                    end:points[i].id,\r\n                    virtrual:false,\r\n                    virtrualNodes:[],\r\n                    cat:points[i].cat,\r\n                    isLocalTree:true\r\n                })\r\n                this.graph.addEdge(points[minindex].id,points[i].id)\r\n            }\r\n        }\r\n\r\n\r\n\r\n        // console.log(this.edges)\r\n        /*        var g = new jsgraphs.Graph(this.pointData.length);\r\n                for (let i=0;i<g.V;i++){\r\n                    g.node(i).label=this.pointData[i].cat\r\n                }*/\r\n\r\n    }\r\n\r\n    initWithNoCluster(){\r\n        for(var k in this.catPointDict){\r\n            this.clusterDict[k]=[]\r\n            for (let i=0;i<this.catPointDict[k].length;i++){\r\n                this.clusterDict[k].push([this.catPointDict[k][i]])\r\n            }\r\n        }\r\n        console.log(this.clusterDict)\r\n    }\r\n\r\n    generateTreeWithHierarchical(){\r\n        // this.findCluster()\r\n        this.initWithNoCluster()\r\n        //merging clusters according to this.edges\r\n\r\n        let preAddedClusters=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            let cat=start.cat\r\n            let catclusters=this.clusterDict[cat]\r\n            let startclusterid=-1\r\n            let endclusterid=-1\r\n            for(let c=0;c<catclusters.length;c++){\r\n                for (let p=0;p<catclusters[c].length;p++){\r\n                    if(catclusters[c][p].id==start.id){\r\n                        startclusterid=c\r\n                    }\r\n                    if(catclusters[c][p].id==end.id){\r\n                        endclusterid=c\r\n                    }\r\n                    if(startclusterid!=-1&&endclusterid!=-1){\r\n                        break\r\n                    }\r\n                }\r\n                if(startclusterid!=-1&&endclusterid!=-1){\r\n                    break\r\n                }\r\n\r\n            }\r\n            if(startclusterid!=-1&&endclusterid!=-1&&startclusterid!=endclusterid){\r\n                // console.log(this.clusterDict[cat].length)\r\n\r\n                //merge two cluster\r\n                let merged=catclusters[startclusterid]\r\n                for(let p=0;p<catclusters[endclusterid].length;p++){\r\n                    merged.push(catclusters[endclusterid][p])\r\n                }\r\n                let newclusterdict=[]\r\n                for (let c=0;c<catclusters.length;c++){\r\n                    if(c!=startclusterid&&c!=endclusterid){\r\n                        newclusterdict.push(catclusters[c])\r\n                    }\r\n                }\r\n                newclusterdict.push(merged)\r\n                this.clusterDict[cat]=newclusterdict\r\n                preAddedClusters.push([cat,newclusterdict.length-1])\r\n                console.log(cat)\r\n            }\r\n\r\n        }\r\n\r\n        this.createGraphWithCluster()\r\n\r\n        for (var k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let iscontinue=false\r\n                for (let c=0;c<preAddedClusters.length;c++){\r\n                    let cat=preAddedClusters[c][0]\r\n                    let id=preAddedClusters[c][1]\r\n                    if(k==cat&&id==i){\r\n                        iscontinue=true\r\n                    }\r\n                }\r\n                if(iscontinue){\r\n                    continue\r\n                }\r\n                else{\r\n                    this.createLocalTree(this.clusterDict[k][i])\r\n                }\r\n            }\r\n        }\r\n        // console.log(this.clusterDict)\r\n        // console.log(this.edges.length)\r\n\r\n        this.drawEdges()\r\n        this.hierarchicalMergeV2()\r\n        // console.log(this.edges.length)\r\n    }\r\n\r\n    findCluster(){\r\n\r\n        for (var k in this.catPointDict){\r\n            // console.log(k)\r\n\r\n            var dbscan = new clustering.DBSCAN();\r\n            let dataset=[]\r\n            let pointDataSet=[]\r\n// parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster\r\n\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                // if(this.pointData[this.catPointDict[k][i].id].multicat){\r\n                //     let catarr=this.pointData[this.catPointDict[k][i].id].catArray\r\n                //     catarr=catarr.map((val)=> parseInt(val) )\r\n                //     let minCatIndex=Math.min.apply(null,catarr)\r\n                //     if(parseInt(k)==minCatIndex){\r\n                //         dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                //         pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                //     }\r\n                // }\r\n                // else{\r\n                dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                // }\r\n\r\n            }\r\n            // console.log(dataset)\r\n            // console.log(pointDataSet)\r\n\r\n            if(dataset.length>0){\r\n                this.clusterDict[k]=[]\r\n                this.noiseDict[k]=[]\r\n                var clusters = dbscan.run(dataset, DBSCAN_EPS, 2);\r\n                // console.log(clusters, dbscan.noise);\r\n                let point\r\n                for(let i=0;i<clusters.length;i++){\r\n                    let clusterPoints=[]\r\n                    for (let j=0;j<clusters[i].length;j++){\r\n                        clusterPoints.push(pointDataSet[clusters[i][j]])\r\n                        // console.log(point)\r\n                        /*                    let point=dataset[clusters[i][j]]\r\n                                            d3.select(svgid)\r\n                                                .append(\"circle\")\r\n                                                .attr(\"cx\",point[0])\r\n                                                .attr(\"cy\",point[1])\r\n                                                .attr(\"r\",10)\r\n                                                .attr(\"fill\",\"none\")\r\n                                                .attr(\"stroke\",\"red\")\r\n                                                .attr(\"stroke-width\",2)*/\r\n                    }\r\n                    // this.createLocalTree(clusterPoints)\r\n                    this.clusterDict[k].push(clusterPoints)\r\n                }\r\n                for (let i=0;i<dbscan.noise.length;i++){\r\n                    this.clusterDict[k].push([pointDataSet[dbscan.noise[i]]])\r\n                }\r\n            }\r\n\r\n        }\r\n        //console.log(this.clusterDict)\r\n        // console.log(this.noiseDict)\r\n    }\r\n\r\n    createGraph(){\r\n\r\n    }\r\n\r\n    createGraphWithCluster(){\r\n        let clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n\r\n\r\n            }\r\n\r\n        }\r\n        this.clusterArr=clusterArr\r\n        //console.log(this.clusterDict)\r\n        var g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n        console.log(g.V)\r\n\r\n        var g2 = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g2.V;i++){\r\n            g2.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g2\r\n        //console.log(g,g2)\r\n        for (let i=0;i<this.edges.length;i++){\r\n            this.graph.addEdge(this.edges[i].start,this.edges[i].end)\r\n        }\r\n\r\n    }\r\n\r\n    calClusterDistance(cluster1,cluster2){\r\n        let dissum=0\r\n        let num=0\r\n        let mindis=Number.MAX_VALUE\r\n        for(let i=0;i<cluster1.length;i++){\r\n            for (let j=0;j<cluster2.length;j++){\r\n                // dissum+=this.calDistance(cluster1[i],cluster2[j])\r\n                // num+=1\r\n                let dis=this.calDistance(cluster1[i],cluster2[j])\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                }\r\n            }\r\n        }\r\n        return mindis\r\n    }\r\n\r\n    sortEdgesGlobalWithCluster(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.clusterDict){\r\n            for(let i=0;i<this.clusterDict[k].length;i++){\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let dis=this.calClusterDistance(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    // let mess=this.calEdgeMess(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    disArray.push(dis)\r\n                    // messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    // tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                    tempedges.push([this.clusterDict[k][i].id,this.clusterDict[k][j].id,dis])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            // let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            // edges.push([start,end,weight,dis,mess])\r\n            edges.push([start,end,weight,dis])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    findLinkBetweenCluster(cluster1,cluster2){\r\n        let mindis=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                if(!this.checkNewEdge(start,end)){\r\n                    flag=true\r\n                    let dis=this.calDistance(start,end)\r\n                    if(dis<mindis){\r\n                        mindis=dis\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return [flag,minstart,minend,mindis]\r\n    }\r\n\r\n    /*    findOptimalLink(cluster1,cluster2){\r\n            //let crossedge = []\r\n            let minScore=Number.MAX_VALUE\r\n            let bestStart=null\r\n            let bestEnd=null\r\n\r\n            let minScoreWithDis=Number.MAX_VALUE\r\n            let bestStartWithDis=null\r\n            let bestEndWithDis=null\r\n\r\n            let hasBest=false\r\n            for (let i=0;i<cluster1.length;i++){\r\n                let start=cluster1[i]\r\n                for(let j=0;j<cluster2.length;j++){\r\n                    let end=cluster2[j]\r\n                    //cal cross num\r\n                    let crossnum=0\r\n                    for (let e=0;e<this.edges.length;e++){\r\n                        let e1=this.pointData[this.edges[e].start]\r\n                        let e2=this.pointData[this.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //let tmpcross = [];\r\n\r\n                    //let elements = this.QTree.retrieve({\r\n                    //    x: Math.min(start.x,end.x),\r\n                    //    y: Math.min(start.y,end.y),\r\n                    //    width: Math.abs(start.x-end.x),\r\n                    //    height: Math.abs(start.y-end.y)\r\n                    //});\r\n\r\n                    //for (let e = 0;e < elements.length;e ++){\r\n                    //    let e1 = this.pointData[elements[e].start];\r\n                    //    let e2 = this.pointData[elements[e].end];\r\n                    //    if(e1.cat != start.cat && e1.cat != end.cat && this.checkEdgeCrossing(start,end,e1,e2)){\r\n                    //        crossnum += 1\r\n                    //        //tmpcross.push({start:this.edges[e].start,end:this.edges[e].end})\r\n                    //        //tmpcross.push({start:this.edges[e].end,end:this.edges[e].start})\r\n                    //    }\r\n                    //}\r\n                    //crossnum = 5;\r\n\r\n                    //cal distance\r\n                    let distance=this.calDistance(start,end)\r\n\r\n\r\n                    //cal num of other points\r\n                    let mess=this.calEdgeMess(start,end)\r\n\r\n                    if(crossnum>maxCross){\r\n                        maxCross=crossnum\r\n                    }\r\n\r\n                    let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                    if(score<minScore){\r\n                        bestStart=start\r\n                        bestEnd=end\r\n                        minScore=score\r\n                        //crossedge = tmpcross\r\n                    }\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        if(score<minScoreWithDis){\r\n                            bestStartWithDis=start\r\n                            bestEndWithDis=end\r\n                            minScoreWithDis=score\r\n                            hasBest=true\r\n                            //crossedge = tmpcross\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            /!*      if(hasBest){\r\n                        // console.log(\"edge under threshhold\")\r\n                        return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                    }\r\n                    else{\r\n                        // console.log(\"no edge under threshhold\")\r\n                        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                    }*!/\r\n            return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n        }*/\r\n\r\n    findOptimalLink(cluster1,cluster2){\r\n        let minScore=Number.MAX_VALUE\r\n        let bestStart=null\r\n        let bestEnd=null\r\n\r\n        let minScoreWithDis=Number.MAX_VALUE\r\n        let bestStartWithDis=null\r\n        let bestEndWithDis=null\r\n\r\n        let hasBest=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n\r\n\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n\r\n                if(crossnum>maxCross){\r\n                    maxCross=crossnum\r\n                }\r\n\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                if(score<minScore){\r\n                    bestStart=start\r\n                    bestEnd=end\r\n                    minScore=score\r\n                }\r\n                if(distance<DISTANCE_THRESHHOLD){\r\n                    if(score<minScoreWithDis){\r\n                        bestStartWithDis=start\r\n                        bestEndWithDis=end\r\n                        minScoreWithDis=score\r\n                        hasBest=true\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /*        if(hasBest){\r\n                    // console.log(\"edge under threshhold\")\r\n                    return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                }\r\n                else{\r\n                    // console.log(\"no edge under threshhold\")\r\n                    return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                }*/\r\n        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n    }\r\n\r\n    /*    findMinScore(links){\r\n            let minScore=Number.MAX_VALUE\r\n            let minIndex=-1\r\n\r\n            let minScoreWithDistance=Number.MAX_VALUE\r\n            let minIndexWithDistance=-1\r\n            let hasBest=false\r\n            for(let i=0;i<links.length;i++){\r\n                if(links[i].score<minScore){\r\n                    minScore=links[i].score\r\n                    minIndex=i\r\n                }\r\n                if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                    minScoreWithDistance=links[i].score\r\n                    minIndexWithDistance=i\r\n                    hasBest=true\r\n                }\r\n            }\r\n            if(hasBest){\r\n                // console.log(\"yes\")\r\n                return links[minIndexWithDistance]\r\n            }\r\n            else{\r\n                // console.log(\"no\")\r\n                return links[minIndex]\r\n\r\n            }\r\n\r\n            // return links[minIndex]\r\n\r\n        }*/\r\n\r\n    findMinScoreTest(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=links.length-1;i>=0;i--) {\r\n            let id1 = links[i].clusterid1\r\n            let id2 = links[i].clusterid2\r\n            if(this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                continue;\r\n            }\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findMinScore(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=0;i<links.length;i++){\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isAdded(start,end){\r\n        for (let i=0;i<this.addedEdge.length;i++){\r\n            if(this.addedEdge[i][0]==start&&this.addedEdge[i][1]==end||this.addedEdge[i][0]==end&&this.addedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isDeleted(start,end){\r\n        for (let i=0;i<this.deletedEdge.length;i++){\r\n            if(this.deletedEdge[i][0]==start&&this.deletedEdge[i][1]==end||this.deletedEdge[i][0]==end&&this.deletedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    addLinksTest(id1,id2,k,cluster1,cluster2,e){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                let crossnum=0\r\n                let distance=this.calDistance(start,end)\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n                e.push(tmp)\r\n                this.idx++;\r\n            }\r\n        }\r\n    }\r\n\r\n    addLinks(id1,id2,k,cluster1,cluster2,e1,e2){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n\r\n                if(this.isDeleted(start.id,end.id)){\r\n                    tmp.score=Number.MAX_VALUE\r\n                    e2._d[this.idx] = tmp;\r\n                    e2.enq(this.idx);\r\n                    this.idx++;\r\n\r\n                }\r\n                else if(this.isAdded(start.id,end.id)){\r\n                    tmp.score=-1\r\n                    e1._d[this.idx] = tmp;\r\n                    e1.enq(this.idx);\r\n                    this.idx++;\r\n                }\r\n                else{\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        //V1\r\n                        //tmp.pid = e1._elements.length;\r\n\r\n                        e1._d[this.idx] = tmp;\r\n                        e1.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                    else{\r\n                        //V1\r\n                        //tmp.pid = e2._elements.length;\r\n\r\n                        e2._d[this.idx] = tmp;\r\n                        e2.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                }\r\n                //let nodetmp = {\r\n                //    x:Math.min(start.x,end.x),\r\n                //    y:Math.min(start.y,end.y),\r\n                //    width:Math.abs(start.x - end.x),\r\n                //    height:Math.abs(start.y - end.y),\r\n                //    idx:this.idx\r\n                //}\r\n                //this.edgesdict.push(nodetmp);\r\n                //this.QTree.insert(this.edgesdict[this.idx]);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    findBestLink(e){\r\n        let minScore = Number.MAX_VALUE;\r\n        let tmp;\r\n        for(let i = e.length - 1;i >= 0;i --){\r\n            let id1 = e[i].clusterid1;\r\n            let id2 = e[i].clusterid2;\r\n            if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                if(minScore > e[i].score){\r\n                    tmp = e[i];\r\n                    minScore = e[i].score;\r\n                }\r\n            }\r\n            else{\r\n                e.splice(i, 1);\r\n            }\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    recalculateSpanningTreeAfterEdit(edges){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                edges[edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        edges[edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<edges.length;i++){\r\n                                let start1=this.pointData[edges[i].start]\r\n                                let end1=this.pointData[edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            edges[edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    recalculateSpanningTree(){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(this.edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    hierarchicalMergeV2(){\r\n\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllClusterV2()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            this.drawEdges()\r\n            console.log()\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n/*                        d3.selectAll(\"line\")\r\n                            .remove()\r\n                        // .attr(\"stroke\",\"black\")\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",startp[0])\r\n                            .attr(\"y1\",startp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",endp[0])\r\n                            .attr(\"y1\",endp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")*/\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",endp[0])\r\n                    .attr(\"y1\",endp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n            this.drawOneEdge(this.edges.length-1)\r\n            console.log()\r\n        }\r\n        //console.log(maxCross)\r\n    }\r\n\r\n    hierarchicalMerge(){\r\n        // console.log(this.calDistance(this.pointData[120],this.pointData[171]))\r\n        // console.log(this.calDistance(this.pointData[47],this.pointData[188]))\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            let optimalLinks=[]\r\n            for (var k in this.clusterDict){\r\n                for (let i=0;i<this.clusterDict[k].length;i++){\r\n                    let id1=this.clusterDict[k][i].id\r\n                    for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                        let id2=this.clusterDict[k][j].id\r\n                        if(!this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                            let link=this.findOptimalLink(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                            optimalLinks.push({\r\n                                clusterid1:id1,\r\n                                clusterid2:id2,\r\n                                start:link[0],\r\n                                end:link[1],\r\n                                score:link[2],\r\n                                distance:link[3],\r\n                                cat:k\r\n                            })\r\n                        }\r\n                        else{\r\n                            continue\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            let bestLink=this.findMinScore(optimalLinks)\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2)\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n\r\n            // this.drawEdges()\r\n\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        //     // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n        }\r\n        console.log(maxCross)\r\n    }\r\n\r\n    mergeCluster(){\r\n        //average distance as distance between clusters\r\n        //find an optimal link with least crossing\r\n\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithCluster()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            // let mess=sortedEdges[i][4]\r\n\r\n\r\n\r\n            if(this.clusterArr[start].cat!=this.clusterArr[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n\r\n                let link=this.findLinkBetweenCluster(this.clusterArr[start].points,this.clusterArr[end].points)\r\n\r\n                if(link[0]){\r\n                    this.clustergraph.addEdge(start,end)\r\n                    this.graph.addEdge(link[1].id,link[2].id)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:link[1].id,\r\n                        end:link[2].id,\r\n                        weight:link[3],\r\n                        dis:link[3],\r\n                        // mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        // mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n        // this.drawEdges()\r\n\r\n        while(!this.checkConnectBetweenCluster()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.findOptimalLink(this.clusterArr[start].points,this.clusterArr[end].points)\r\n                    removeEdggeList[i].weight=scores[3]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push({\r\n                        clusterstart:start,\r\n                        clusterend:end,\r\n                        start:scores[0].id,\r\n                        end:scores[1].id,\r\n                        weight:scores[2],\r\n                        crossnum:scores[2]\r\n                    })\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.clustergraph.addEdge(tempEdgeList[maxindex].clusterstart,tempEdgeList[maxindex].clusterend)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                // dis:tempEdgeList[maxindex].dis,\r\n                // mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // this.drawEdges()\r\n            console.log()\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n\r\n    }\r\n\r\n    editBackbone(){\r\n\r\n        editView = !editView\r\n        this.setState({\r\n            editV:editView\r\n        })\r\n\r\n        if(editView){\r\n            d3.select(\"svg\")\r\n                .selectAll(\".dataPoint\")\r\n                .remove()\r\n//\r\n            d3.select(\"svg\")\r\n                .selectAll(\"line\")\r\n                .remove()\r\n\r\n            //offsetX = 20;\r\n            //offsetY = 20;\r\n            //viewWidth = 40;\r\n            //viewHeight = 40\r\n//\r\n            //this.child.setViewBox(offsetX, offsetY, viewWidth, viewHeight)\r\n            //d3.select(\"#mainsvg\")\r\n            //    .attr(\"viewBox\",offsetX+\" \"+offsetY+\" \"+viewWidth+\" \"+viewHeight)\r\n\r\n            /*\r\n            let tx,ty,s\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                for(let i = 0; i < infostr.length; i ++){\r\n                    if(infostr[i] == '('){\r\n                        i ++\r\n                        while(infostr[i] != ','){\r\n                            tx += infostr[i ++]\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            ty += infostr[i ++]\r\n                        }\r\n                        while(infostr[i] != '('){\r\n                            i ++\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            s += infostr[i ++]\r\n                        }\r\n                        break\r\n                    }\r\n                }\r\n                tx = parseFloat(tx)\r\n                ty = parseFloat(ty)\r\n                s = parseFloat(s)\r\n            }\r\n\r\n             */\r\n\r\n\r\n            // d3.select(svgid).selectAll(\"*\").remove();\r\n            this.drawPointData()\r\n            this.drawEdges()\r\n\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                d3.selectAll('g').attr(\"transform\", infostr);\r\n            }\r\n\r\n            this.props.handleManually(false)\r\n            //this.child.getData()\r\n        }\r\n        else{\r\n            d3.selectAll(\"#edgeGroup\")\r\n                .remove()\r\n            d3.selectAll(\"#pointGroup\")\r\n                .remove()\r\n            this.child.afterEditReDraw()\r\n            //d3.selectAll(\"\")\r\n        }\r\n    }\r\n\r\n    editMST(){\r\n\r\n        this.issplit = !this.issplit;\r\n\r\n        if(this.issplit == true){\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n                .attr(\"style\",\"border:1px solid #000000\")\r\n\r\n            svgid = \"#leftsvg\"\r\n            opsvgid = '#mainsvg'\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n\r\n            this.drawPointData()\r\n\r\n            this.drawEdges()\r\n\r\n            this.props.handleManually(false)\r\n\r\n            //this.setState({\r\n            //    pointData: this.pointData\r\n            //})\r\n            //this.setState({\r\n            //    edges: this.edges\r\n            //})\r\n            //this.setState({\r\n            //    hasinit:true\r\n            //})\r\n//\r\n            //this.child.getData()\r\n\r\n        }\r\n        else{\r\n\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n            d3.selectAll(\"#edgeGroup\")\r\n                .remove()\r\n            d3.selectAll(\"#pointGroup\")\r\n                .remove()\r\n            this.child.afterEditReDraw()\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",1200 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",0)\r\n                .attr(\"height\",0)\r\n                .attr(\"style\",\"border:0px solid #000000\")\r\n\r\n\r\n\r\n            svgid = \"#mainsvg\"\r\n            opsvgid = '#leftsvg'\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleCreated(){\r\n        this.setState({\r\n            hascreated:true\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    saveSVG(){\r\n\r\n    }\r\n\r\n    saveData(){\r\n        let data\r\n        if(!this.state.hasinit){\r\n            data=this.props.pointData\r\n        }\r\n        else{\r\n            data=this.pointData\r\n        }\r\n        let content = JSON.stringify(data);\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"data.json\");\r\n\r\n    }\r\n\r\n    render(){\r\n        //return (\r\n        //    <div id={\"svgcontainer\"}>\r\n        //        <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n        //        </svg>\r\n        //        <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n        //        <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n        //    </div>)\r\n        return (\r\n            <div>\r\n                <div>\r\n                    {/*<Button onClick={this.saveData.bind(this)}>Save Data</Button>*/}\r\n                    {/*<Button onClick={this.saveSVG}>Save SVG</Button>*/}\r\n\r\n                </div>\r\n                <div style={{marginTop: 20 * ScreenHeight / BeforeHeight}}>\r\n                        <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData&&!this.state.hasinit||this.state.hasEdit? false:true}>\r\n                        {\r\n                            this.state.hasinit? \"Apply Changes\":\"Create Backbone\"\r\n                        }\r\n                    </Button>\r\n                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Switch checkedChildren=\"Edit Backbone\" unCheckedChildren=\"Edit Backbone\"  onClick={this.editBackbone.bind(this)} checked={this.state.editV} disabled={this.state.hascreated? false:true}/>\r\n                    </div>\r\n\r\n                <AdaptiveIsovalue pointData={this.state.pointData} hasLoadData={this.props.hasLoadData} edges={this.state.edges} handleCreated={this.handleCreated.bind(this)} createMST={this.getData.bind(this)} onRef={this.onRef} colorArray={this.props.colorArray}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default HierarchicalCluster","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport * as d3 from \"d3\"\r\nimport \"./scale-canvas\"\r\nimport scaleCanvas from \"./scale-canvas\";\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass BMOAlgo extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.itemShape=\"rectangle\"\r\n        this.catPointDict={}\r\n        this.context=null\r\n        this.canvasWidth=1500\r\n        this.canvasHeight=1200\r\n        this.canvasRatio=1\r\n    }\r\n\r\n    componentDidMount() {\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n\r\n\r\n                this.init()\r\n                this.centralizeData()\r\n                this.drawPointData()\r\n                this.loadEdgeData()\r\n                    .then(res=>res.json())\r\n                    .then(data=>{\r\n                        console.log(data)\r\n                        this.edges=data\r\n                        for (let i=0;i<this.edges.length;i++){\r\n                            this.edges[i].start=parseInt(this.edges[i].start)\r\n                            this.edges[i].end=parseInt(this.edges[i].end)\r\n\r\n                        }\r\n                        this.drawEdges()\r\n                        this.getPixelImage()\r\n\r\n                    })\r\n\r\n            })\r\n\r\n    }\r\n\r\n    getPixelImage(){\r\n        console.log(this.canvasRatio)\r\n\r\n        // this.context.strokeStyle=\"red\"\r\n        // this.context.lineWidth=2\r\n        // this.context.rect(imageX,imageY,imageWidth,imageHeight)\r\n        // this.context.stroke()\r\n\r\n        // console.log(imageWidth,imageHeight)\r\n        let imageData=this.context.getImageData(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n        this.context.clearRect(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n        // let data=imageData.data\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n\r\n\r\n\r\n        for (let i=0;i<imageData.data.length;i+=4){\r\n            // if(imageData.data[i]>0||imageData.data[i+1]>0||imageData.data[i+2]>0){\r\n                if(imageData.data[i+3]>0){\r\n\r\n                    // console.log(imageData.data[i],imageData.data[i+1],imageData.data[i+2])\r\n                // console.log(i)\r\n                // imageData.data[i]=255\r\n                // imageData.data[i+1]=0\r\n                // imageData.data[i+2]=0\r\n                let index=i/4\r\n                let x=index%imageData.width\r\n                let y=parseInt(index/imageData.width)\r\n                // imageData.data[i+3]=0\r\n                if(y<miny){\r\n                    miny=y\r\n                }\r\n            if(y>maxy){\r\n                maxy=y\r\n            }\r\n            if(x<minx){\r\n                minx=x\r\n            }\r\n            if(x>maxx){\r\n                maxx=x\r\n            }\r\n            }\r\n        }\r\n        // this.context.strokeStyle=\"red\"\r\n        // this.context.lineWidth=2\r\n        // this.context.rect(minx,miny,maxx-minx,maxy-miny)\r\n        // this.context.stroke()\r\n\r\n        this.context.putImageData(imageData,0,0)\r\n\r\n        console.log(imageData)\r\n\r\n        let width=maxx-minx\r\n        let height=maxy-miny\r\n        let newImageData=[]\r\n        for(let i=miny;i<maxy+1;i++){\r\n            let oneline=[]\r\n\r\n            for (let j=minx;j<maxx+1;j++){\r\n                let index=i*imageData.width+j\r\n                if(imageData.data[index*4+3]>0){\r\n                    oneline.push(1)\r\n                }\r\n                else{\r\n                    oneline.push(0)\r\n                }\r\n            }\r\n            newImageData.push(oneline)\r\n        }\r\n        console.log(newImageData)\r\n\r\n        fetch('http://localhost:3001/processImage',{\r\n            method:'post',//改成post\r\n            mode: 'cors',//跨域\r\n            headers: {//请求头\r\n                'Content-Type': 'application/x-www-form-urlencoded'\r\n            },\r\n            body:'image='+JSON.stringify(newImageData)//向服务器发送的数据\r\n        })\r\n            .then(res=>res.text())\r\n            .then(data=>{\r\n                console.log(data)\r\n\r\n            })\r\n        \r\n        // this.context.clearRect(0,0,this.canvasWidth,this.canvasHeight)\r\n        // this.context.clearRect(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,width,color){\r\n        this.context.lineWidth = width;          //设置线宽状态\r\n        this.context.strokeStyle = color ;  //设置线的颜色状态\r\n        this.context.moveTo (x1,y1);       //设置起点状态\r\n        this.context.lineTo (x2,y2);       //设置末端状态\r\n\r\n        this.context.stroke();\r\n    }\r\n\r\n    drawEdges(){\r\n        // d3.selectAll(\"line\").remove()\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            this.drawLine(this.pointData[start].x,this.pointData[start].y,this.pointData[end].x,this.pointData[end].y,2,\"black\")\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    loadEdgeData(){\r\n        let that=this\r\n        return fetch('/data/BubbleSetEdge1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n\r\n    }\r\n\r\n    init(){\r\n        this.context=document.getElementById(\"maincanvas\").getContext(\"2d\")\r\n        this.canvasRatio=scaleCanvas(document.getElementById(\"maincanvas\"),this.context,this.canvasWidth,this.canvasHeight)\r\n        // console.log(this.context)\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n                let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }\r\n        this.maxX=maxx+move[0]\r\n        this.minX=minx+move[0]\r\n        this.maxY=maxy+move[1]\r\n        this.minY=miny+move[1]\r\n        // this.drawRect(this.minX,this.minY,this.maxX-this.minX,this.maxY-this.minY,\"red\")\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n    }\r\n\r\n    drawPointData(){\r\n        for(let i=0;i<this.pointData.length;i++){\r\n            this.drawPoint(this.pointData[i].x,this.pointData[i].y,this.pointData[i].radius,colors[this.pointData[i].cat])\r\n        }\r\n    }\r\n\r\n\r\n    drawPoint(x,y,r,color){\r\n\r\n        this.context.beginPath()\r\n        this.context.fillStyle=color\r\n        this.context.arc(x, y, r, 0, Math.PI * 2, false);\r\n        this.context.fill()\r\n        this.context.closePath()\r\n    }\r\n\r\n    drawRect(x,y,w,h,color){\r\n        this.context.lineWidth=2\r\n        this.context.strokeStyle=color\r\n        this.context.rect(x-w/2,y-h/2,w,h)\r\n        this.context.stroke()\r\n    }\r\n\r\n    deletePoint(e){\r\n        e.stopPropagation()\r\n        let el=e.target\r\n        let index=d3.select(el).attr(\"index\")\r\n        this.points[index]=-1\r\n        d3.select(el).remove()\r\n        console.log(index)\r\n        d3.selectAll(\"text\")\r\n            .filter(function(d,i){\r\n                return d3.select(this).attr(\"index\")==index\r\n            })\r\n            .remove()\r\n        // console.log(this.points)\r\n    }\r\n\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <canvas id={\"maincanvas\"} width={\"1500\"} height={\"1200\"} >\r\n                </canvas>\r\n                {/*<button onClick={this.addCategory.bind(this)}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"800px\"}}>Add Category</button>*/}\r\n                {/*<input ref={(input)=>this.input=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"750px\"}}></input>*/}\r\n                {/*<button onClick={this.switchCategory.bind(this)}  style={{width:200,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"750px\",marginLeft:10}}>Change Category</button>*/}\r\n                {/*<button onClick={this.savePoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"700px\",marginLeft:10}}>Save</button>*/}\r\n                {/*<button onClick={this.loadPoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"700px\",marginLeft:10}}>Load</button>*/}\r\n                {/*<input ref={(input)=>this.input2=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"650px\"}}></input>*/}\r\n                {/*<button onClick={this.changeWidthHeight.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"650px\",marginLeft:10}}>Change Width and Height</button>*/}\r\n                {/*<label ref={(jsonoutput)=>this.jsonoutput=jsonoutput} style={{width:300,height:200,fontSize:\"10px\",position:\"absolute\",left:\"1550px\",bottom:\"300px\",marginLeft:10,overflow:\"scroll\"}}>*/}\r\n\r\n                {/*</label>*/}\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default BMOAlgo","import React, {Component} from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nclass AlgorithmEntry extends Component{\r\n\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[]\r\n    }\r\n\r\n    // eslint-disable-next-line\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    finishInput(){\r\n        if(this.props.pointData){\r\n            alert(\"Finish input and start creating spanning tree!\");\r\n            console.log(this.props.pointData);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <button onClick = {this.finishInput.bind(this)}>\r\n                Create MST\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport default AlgorithmEntry;","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport {drag} from \"d3\";\r\nimport AlgorithmEntry from \"./AlgorithmEntry\";\r\nimport './index.css';\r\nimport HierarchicalCluster from \"./HierarchicalCluster\";\r\nimport { Layout } from 'antd';\r\nimport { Button } from 'antd';\r\nimport { Select } from 'antd';\r\nimport { Menu } from 'antd';\r\nimport { Dropdown} from 'antd';\r\nimport { DownOutlined } from '@ant-design/icons';\r\nimport { Table, Radio, Divider } from 'antd';\r\nimport { Tag, Space } from 'antd'\r\nimport { Switch } from 'antd';\r\nimport { CloseOutlined, CheckOutlined } from '@ant-design/icons';\r\nimport { Pagination } from 'antd';\r\nimport {calDistance} from \"./util\";\r\nconst svgsaver=require(\"save-svg-as-png\")\r\n\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\nconst { Option } = Select;\r\nconst { Header, Footer, Sider, Content } = Layout;\r\n\r\n\r\n\r\nconst columns = [\r\n    {\r\n        title: 'Group',\r\n        dataIndex: 'name',\r\n        render: (text) => <a>{text}</a>,\r\n    },\r\n    {\r\n        title: 'Color',\r\n        key: 'tags',\r\n        dataIndex: 'tags',\r\n        render: tags => (\r\n            <>\r\n                {tags.map(tag => {\r\n                    let color = tag\r\n                    return (\r\n                        <Tag color={color} key={tag} >\r\n                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                        </Tag>\r\n                    );\r\n                })}\r\n            </>\r\n        ),\r\n    }\r\n];\r\n\r\nvar keynum = 1\r\nvar GroupDict = {}\r\nGroupDict['Group 0'] = 1\r\nvar cur_set = 0;\r\nvar FileSaver = require('file-saver');\r\n\r\n\r\nvar svgid=\"#mainsvg\"\r\nconst rowSelection = {\r\n    onChange: (selectedRowKeys, selectedRows) => {\r\n        cur_set = selectedRowKeys;\r\n        //console.log(`selectedRowKeys: ${selectedRowKeys}`, 'selectedRows: ', selectedRows);\r\n    },\r\n    getCheckboxProps: (record) => ({\r\n        disabled: record.name === 'Disabled User',\r\n        // Column configuration not to be checked\r\n        name: record.name,\r\n    }),\r\n};\r\n// var colorArray=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar colorArray=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colorArray=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colorArray=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar is_input = false;\r\nvar g;\r\nvar svg;\r\n\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nclass IndexUI extends Component{\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            updateview: false,\r\n            is_input:false,\r\n            GroupData:[{key:'0',name:'Group 0',tags:[]}],\r\n            pointData:[],\r\n            edges:[],\r\n            hasLoadData:false,\r\n            dataFile:[],\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        }\r\n        this.shape = \"circle\";\r\n        this.cur_idx = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.offsetY = 0;\r\n        this.offsetX = 0;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.selValue = ''\r\n        this.maxX=0\r\n        this.maxY=0\r\n        this.minX=0\r\n        this.minY=0\r\n        this.pointData = [];\r\n        this.edges=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.itemBBox=[]\r\n        this.hasCreateMST=false\r\n\r\n\r\n        this.menu = (\r\n            <Menu>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.savePNG.bind(this)}>\r\n                        PNG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveSVG.bind(this)}>\r\n                        SVG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveData.bind(this)}>\r\n                        JSON\r\n                    </a>\r\n                </Menu.Item>\r\n            </Menu>\r\n        );\r\n\r\n    }\r\n\r\n    init(){\r\n\r\n        d3.select(\"svg\").selectAll(\"*\").remove()\r\n\r\n        this.setState({\r\n            updateview: false,\r\n            is_input:false,\r\n            GroupData:[{key:'0',name:'Group 0',tags:[]}],\r\n            pointData:[],\r\n            edges:[],\r\n            hasLoadData:false,\r\n            dataFile:[],\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        })\r\n\r\n        keynum = 1\r\n        GroupDict = {}\r\n        GroupDict['Group 0'] = 1\r\n        cur_set = 0;\r\n\r\n        svgid=\"#mainsvg\"\r\n        colorArray=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n\r\n        is_input = false;\r\n\r\n        this.shape = \"circle\";\r\n        this.cur_idx = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.offsetY = 0;\r\n        this.offsetX = 0;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.selValue = ''\r\n        this.maxX=0\r\n        this.maxY=0\r\n        this.minX=0\r\n        this.minY=0\r\n        this.pointData = [];\r\n        this.edges=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.itemBBox=[]\r\n        this.hasCreateMST=false\r\n\r\n\r\n        this.menu = (\r\n            <Menu>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.savePNG.bind(this)}>\r\n                        PNG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveSVG.bind(this)}>\r\n                        SVG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveData.bind(this)}>\r\n                        JSON\r\n                    </a>\r\n                </Menu.Item>\r\n            </Menu>\r\n        );\r\n\r\n        this.child.init()\r\n\r\n\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        var box=document.getElementById('mainsvg');\r\n        this.width = box.getBoundingClientRect().width;\r\n        this.height = box.getBoundingClientRect().height;\r\n        //console.log([this.width,this.height])\r\n\r\n        svg = d3.select('svg');\r\n\r\n        g = d3.select('svg').append(\"g\")\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        //svg.on('mousedown',this.handleMousedown.bind(this));\r\n        svg.call(d3.zoom()\r\n            .extent([[0, 0], [this.width, this.height]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        fetch('/data/datalist.json',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    dataFile:data\r\n                })\r\n            })\r\n\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        this.offsetX = minx - 20;\r\n        this.offsetY = miny - 20;\r\n        this.scaleX = (maxx-minx+40)/this.width;\r\n        this.scaleY = (maxy-miny+40)/this.height;\r\n\r\n        svg = d3.select('svg');\r\n        svg.call(d3.zoom()\r\n            .extent([[this.offsetX, this.offsetY], [this.scaleX, this.scaleY]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //console.log([this.offsetX,this.offsetY,this.scaleX,this.scaleY])\r\n\r\n    }\r\n\r\n    handleMousedown(event){\r\n        //left click\r\n        if(event.button === 0 && is_input){\r\n\r\n            //console.log(\"IndexUI Click!\")\r\n            //console.log(g)\r\n\r\n            //let x = event.offsetX;\r\n            //let y = event.offsetY;\r\n            //console.log([x,y])\r\n            let cx = d3.pointer(event)[0]\r\n            let cy = d3.pointer(event)[1]\r\n            let attributes = g._groups[0][0].attributes\r\n            if(attributes.transform != undefined){\r\n                let val = attributes.transform.value\r\n                let offsetX = \"\";\r\n                let offsetY = \"\";\r\n                let Scale = \"\";\r\n                for(let j = 9; j < val.length; j ++){\r\n                    if(val[j]=='('){\r\n                        j++;\r\n                        if(offsetX==\"\"){\r\n                            while(val[j]!=','){\r\n                                offsetX+=val[j++];\r\n                            }\r\n                            j++;\r\n                            while(val[j]!=')'){\r\n                                offsetY+=val[j++];\r\n                            }\r\n                        }\r\n                        else{\r\n                            while(val[j]!=')'){\r\n                                Scale+=val[j++];\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                offsetX = parseFloat(offsetX)\r\n                offsetY = parseFloat(offsetY)\r\n                Scale = parseFloat(Scale)\r\n                //console.log(\"(\" + offsetX + \", \" + offsetY + \", \" + Scale +\")\")\r\n                cx = (cx - offsetX) / Scale\r\n                cy = (cy - offsetY) / Scale\r\n            }\r\n\r\n\r\n            if(this.shape === 'circle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('circle')\r\n                    .attr('r', 10)\r\n                    .attr('cx', cx)\r\n                    .attr('cy', cy)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('rect')\r\n                    .attr('x', cx - 5)\r\n                    .attr('y', cy - 5)\r\n                    .attr('width', 10)\r\n                    .attr('height', 10)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            let tmp = {};\r\n            tmp.radius = 10;\r\n            tmp.width = 10;\r\n            tmp.height = 10;\r\n            tmp.x = cx;\r\n            tmp.y = cy;\r\n            tmp.cat = cur_set;\r\n            tmp.id = this.cur_idx++;\r\n            tmp.shape = this.shape\r\n\r\n            if(this.hasCreateMST == true){\r\n                this.child.addNewPoints(tmp)\r\n            }\r\n            else{\r\n                this.pointData.push(tmp);\r\n            }\r\n\r\n            this.setState({pointData:this.pointData})\r\n            console.log(this.pointData)\r\n        }\r\n    }\r\n\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        return edge\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                // that.setState({\r\n                //     hasEdit:true\r\n                // })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n                // that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n                // that.optimizeMST(true)\r\n\r\n                // for (var k in that.catPointDict){\r\n                //     that.findCircle(k)\r\n                // }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=g\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                    g\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this).attr(\"opacity\",0)\r\n                    })\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    handleDeleteNode(e){\r\n        if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                this.pointData.splice(this.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n\r\n    }\r\n\r\n    drawInit(){\r\n\r\n        this.centralizeData();\r\n        let data = this.pointData;\r\n        console.log(data)\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            let svg=d3.select(\"svg\")\r\n            let nodeindex=parseInt(d3.select(this).attr(\"idx\"))\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n            if(that.shape==\"circle\"){\r\n                d3.select(this)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                d3.select(this)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            d3.select(this).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",function(){\r\n                d3.select(this).attr(\"stroke\",\"none\")\r\n            })\r\n\r\n        function handleMouseDown(event){\r\n\r\n        }\r\n\r\n        function handleDeleteNode(e){\r\n            if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                that.pointData.splice(that.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n            else if(e.button==2 && !is_input){\r\n                console.log(\"click\")\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                // that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                // that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            // that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        var GroupCat = {}\r\n        for(let i = 0;i < data.length;i ++){\r\n\r\n            let curcat = -1;\r\n            let tmpcat = data[i].cat.toString()\r\n            let cats = tmpcat.split(\",\")\r\n            if (cats.length > 1){\r\n                for (let c = 0;c < cats.length;c ++){\r\n                    GroupCat[parseInt(cats[c])] = 1\r\n                    //GroupDict['Group '+ cats[c].toString()] = 1\r\n                    curcat = Math.max(parseInt(cats[c]), curcat);\r\n                }\r\n            }\r\n            else{\r\n                GroupCat[parseInt(tmpcat)] = 1\r\n                //GroupDict['Group '+ tmpcat.toString()] = 1\r\n                curcat = Math.max(parseInt(tmpcat), curcat);\r\n            }\r\n\r\n            cur_set = Math.max(curcat,cur_set);\r\n\r\n            if(this.shape === 'circle'){\r\n                g.append('circle')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('r', data[i].radius)\r\n                    .attr('cx', data[i].x)\r\n                    .attr('cy', data[i].y)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx',i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                g.append('rect')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('x', data[i].x - 0.5 * data[i].width)\r\n                    .attr('y', data[i].y - 0.5 * data[i].height)\r\n                    .attr('width', data[i].width)\r\n                    .attr('height', data[i].height)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx', i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n\r\n        }\r\n\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n/*        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }*/\r\n\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        keynum = 0\r\n\r\n        GroupDict = {}\r\n        for(var c in GroupCat){\r\n            GroupDict['Group '+ c.toString()] = 1\r\n        }\r\n\r\n        for(var k in GroupDict){\r\n            console.log(k)\r\n            if(keynum == 0){\r\n                tmpGroupData[0].tags = [colorArray[parseInt(keynum)]]\r\n            }\r\n            else{\r\n                tmpGroupData.push({\r\n                    key:keynum.toString(),\r\n                    name:k,\r\n                    tags:[colorArray[parseInt(keynum)]]\r\n                })\r\n            }\r\n            keynum++;\r\n        }\r\n\r\n        this.setState({GroupData:tmpGroupData})\r\n\r\n        console.log(\"GroupData!!!\")\r\n        console.log(GroupDict)\r\n        console.log(this.state.GroupData)\r\n\r\n        this.cur_idx = data.length\r\n        cur_set = keynum;\r\n\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 40)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 814)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n\r\n    }\r\n\r\n    addNewSet(){\r\n        keynum = 0\r\n        for(var k in GroupDict){\r\n            keynum ++;\r\n        }\r\n        //cur_set = keynum;\r\n        GroupDict['Group '+ keynum.toString()] = 1\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        tmpGroupData.push({\r\n            key:keynum.toString(),\r\n            name:'Group '+ keynum.toString(),\r\n            tags:[colorArray[parseInt(keynum.toString())]]\r\n        })\r\n        keynum ++;\r\n        this.setState({GroupData:tmpGroupData})\r\n        alert(\"Succellfully add new set \" + (keynum-1)  + \" !\");\r\n    }\r\n\r\n    scaleData(){\r\n\r\n        let minX = Number.MAX_VALUE\r\n        let minY = Number.MAX_VALUE\r\n        let maxX = Number.MIN_VALUE\r\n        let maxY = Number.MIN_VALUE\r\n        let scale_ratio_x = 1\r\n        let scale_ratio_y = 1\r\n        let transform_dx = 0\r\n        let transform_dy = 0\r\n\r\n        if(this.pointData.length <= 0){\r\n            return\r\n        }\r\n\r\n        if(this.pointData[0].shape == \"rectangle\"){\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].width / 2\r\n                let x2 = this.pointData[i].x + this.pointData[i].width / 2\r\n                let y1 = this.pointData[i].y - this.pointData[i].height / 2\r\n                let y2 = this.pointData[i].y + this.pointData[i].height / 2\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n        else{\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].radius\r\n                let x2 = this.pointData[i].x + this.pointData[i].radius\r\n                let y1 = this.pointData[i].y - this.pointData[i].radius\r\n                let y2 = this.pointData[i].y + this.pointData[i].radius\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n\r\n\r\n        let cur_width = maxX - minX\r\n        let cur_height = maxY - minY\r\n\r\n        // let svgwidth1 = 1200\r\n        // let svgheight1 = 1200\r\n\r\n        let svgwidth1 = 1500\r\n        let svgheight1 = 1500\r\n\r\n        //let svgwidth2 = 2000\r\n        //let svgheight2 = 2000\r\n\r\n        //if(cur_width > svgwidth1){\r\n            scale_ratio_x = svgwidth1 / cur_width\r\n        //}\r\n\r\n        //if(cur_height > svgheight1){\r\n            scale_ratio_y = svgheight1 / cur_height\r\n        //}\r\n\r\n        let ratio = Math.min(scale_ratio_x, scale_ratio_y)\r\n\r\n        transform_dx = 0 - minX\r\n        transform_dy = 0 - minY\r\n\r\n        //let ddx = (svgwidth2 / 2)  - ( (minX + transform_dx) * ratio + (maxX + transform_dx) * ratio ) / 2\r\n        //let ddy = (svgheight2 / 2) - ( (minY + transform_dy) * ratio + (maxY + transform_dy) * ratio ) / 2\r\n\r\n        for(let i = 0; i < this.pointData.length; i ++){\r\n\r\n            this.pointData[i].x = (this.pointData[i].x + transform_dx) * ratio\r\n            this.pointData[i].y = (this.pointData[i].y + transform_dy) * ratio\r\n            this.pointData[i].radius *= ratio\r\n            this.pointData[i].width *= ratio\r\n            this.pointData[i].height *= ratio\r\n            //this.pointData[i].shape = \"rectangle\"\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleUpload(){\r\n\r\n\r\n        let filename = this.selValue\r\n\r\n        this.init()\r\n        this.componentWillMount()\r\n        this.render()\r\n        this.componentDidMount()\r\n\r\n        if(filename == \"Manhattan.txt\"){\r\n            colorArray = ['#f16b22','#7e519f','#713e3a']\r\n        }\r\n        else if(filename == \"simpleScatterplot.json\"){\r\n            colorArray = ['#d35d6d','#0885c2','#4aa15f']\r\n        }\r\n\r\n        this.setState({\r\n            colorArray:colorArray\r\n        })\r\n\r\n        console.log(\"filename:\")\r\n        console.log(filename)\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    hasLoadData:true\r\n                })\r\n                this.pointData = data;\r\n                //for(let i = 0; i < this.pointData.length; i ++){\r\n                //    this.pointData[i].shape = \"rectangle\"\r\n                //}\r\n                //this.scaleData()\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    // this.pointData[i].width=this.pointData[i].width*1.5\r\n                    // this.pointData[i].height=this.pointData[i].height*1.5\r\n                    this.pointData[i].radius=10\r\n\r\n                }\r\n                //this.setState({\r\n                //    upload: true\r\n                //})\r\n\r\n                this.setState({pointData:this.pointData})\r\n                this.shape = data[0].shape;\r\n\r\n\r\n                this.drawInit();\r\n                this.setState({\r\n                    edges:this.edges\r\n                })\r\n            })\r\n\r\n    }\r\n\r\n    changeSel(e){\r\n        this.selValue = e;\r\n    }\r\n\r\n    handleInput(){\r\n        is_input = !is_input;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    hasCreate(){\r\n        this.hasCreateMST = true;\r\n    }\r\n    saveData(){\r\n        this.child.saveData()\r\n    }\r\n    savePNG(){\r\n        svgsaver.saveSvgAsPng(document.getElementById(\"mainsvg\"), \"result.png\");\r\n    }\r\n    saveSVG(){\r\n        let svg=d3.select(\"#mainsvg\")\r\n        let width=svg.attr(\"width\")\r\n        let height=svg.attr(\"height\")\r\n        let viewbox=svg.attr(\"viewBox\")\r\n        let svgstr=svg.html()\r\n        let xmlns=\"http://www.w3.org/2000/svg\"\r\n        svgstr=\"<svg xmlns=\\\"\"+xmlns+\"\\\" width=\\\"\"+width+\"\\\" height=\\\"\"+height+\"\\\" viewBox=\\\"\"+viewbox+\"\\\" >\\n\"+svgstr+\"\\n</svg>\"\r\n        let content = svgstr;\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"result.svg\");\r\n        // console.log(svgstr)\r\n    }\r\n\r\n    handleManually(flag){\r\n        is_input = flag;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    render(){\r\n        let options=this.state.dataFile.map((d)=>{return <option value={d}>{d}</option> })\r\n        console.log(\"Ratio\")\r\n        console.log(ScreenHeight/BeforeHeight)\r\n        console.log(ScreenWidth/BeforeWidth)\r\n        let p1 = 20 * ScreenHeight / BeforeHeight\r\n        let p2 = 50 * ScreenWidth / BeforeWidth\r\n        let p3 = 20 * ScreenHeight / BeforeHeight\r\n        let p4 = 20 * ScreenWidth / BeforeWidth\r\n        let p5 = 25 * ScreenHeight / BeforeHeight\r\n        let pad1 = p1.toString() + \"px \" + p2.toString() + \"px \" + p3.toString() + \"px \" + p4.toString() + \"px\"\r\n        let pad2 = p5.toString() + \"px \" + p4.toString() + \"px\"\r\n        return (\r\n            <>\r\n                <Layout>\r\n                    <Header style={{background: 'rgb(255, 255, 255, 0.1)',textAlign: 'center', fontFamily:\"Segoe UI\",fontWeight:\"bold\",fontSize: '25px', color:\"black\"}}>F2-Bubbles</Header>\r\n                    <Layout>\r\n                        <Content theme={'light'} style={{ padding: pad1, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\" style={{float: \"right\"}}>\r\n                                <svg id=\"mainsvg\" width={1200 * ScreenWidth / BeforeWidth} height={750 * ScreenHeight / BeforeHeight} style={{border:\"1px solid #000000\"}}></svg>\r\n                            </div>\r\n                            <div className=\"left\" style={{float: \"left\"}}>\r\n                                <svg id=\"leftsvg\" width={0} height={0}></svg>\r\n                            </div>\r\n                        </Content>\r\n                        <Sider theme={'light'} width={600 * ScreenWidth / BeforeWidth} className=\"site-layout-background\" style={{ padding: pad2, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\">\r\n                                <Select showSearch style={{ width: 320 * ScreenWidth / BeforeWidth }} placeholder=\"Select an example data..\" onChange={this.changeSel.bind(this)}>\r\n                                    {options}\r\n{/*                                    <Option value='BubbleSetExample1.txt'>example1</Option>\r\n                                    <Option value='BubbleSetExample2.txt'>example2</Option>\r\n                                    <Option value='BubbleSetExample3.txt'>Manually Made Data</Option>\r\n                                    <Option value='test.txt'>test</Option>\r\n                                    <Option value='test(1).txt'>test(1).txt</Option>\r\n                                        <Option value='co2_gdppercapita.txt'>co2_gdppercapita.txt</Option>\r\n                                    <Option value='life_children.txt'>life_children.txt</Option>\r\n                                    <Option value='co2_income.txt'>co2_income.txt</Option>\r\n                                    <Option value='life_income.txt'>life_income.txt</Option>*/}\r\n\r\n\r\n\r\n\r\n\r\n                                </Select>\r\n                                <Button onClick={this.handleUpload.bind(this)}>Load Example Data</Button>\r\n                                <br/>\r\n                                <br/>\r\n                                <p>\r\n                                    <Dropdown overlay={this.menu} arrow>\r\n                                        <Button>Save As <DownOutlined /></Button>\r\n                                    </Dropdown>\r\n                                </p>\r\n\r\n                                <div style={{width:\"80%\"}}>\r\n                                    <Table pagination={{disabled:true, position: ['none', 'none'] }}\r\n                                           scroll={{ y: 200 * ScreenHeight / BeforeHeight }}\r\n                                           columns={columns}\r\n                                           dataSource={this.state.GroupData}\r\n                                    />\r\n                                </div>\r\n                                <br/>\r\n                                <HierarchicalCluster pointData={this.state.pointData} hasLoadData={this.state.hasLoadData} isedit={this.state.is_input} edges={this.state.edges} hasCreate={this.hasCreate.bind(this)} handleManually={this.handleManually.bind(this)} onRef={this.onRef} colorArray = {this.state.colorArray}/>\r\n                            </div>\r\n                        </Sider>\r\n                    </Layout>\r\n                    <Footer style={{background: 'rgb(255, 255, 255, 0.1)', textAlign: 'center' ,fontSize: '16px'}}>F2-Bubbles ©2021</Footer>\r\n                </Layout>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default IndexUI;","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport MainSvg from \"./MainSvg\"\r\nimport DataHacker from \"./dataHacker\"\r\nimport CSVData from \"./CSVData\"\r\nimport GapMinderNew from \"./GapMinderNew\";\r\nimport ManuallyTree from \"./ManuallyTree\";\r\nimport Example1 from\"./Example1\"\r\nimport LocalCluster from\"./LocalCluster\"\r\nimport HierarchicalCluster from \"./HierarchicalCluster\";\r\nimport BMOAlgo from \"./BMOAlgo\";\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport IndexUI from \"./IndexUI\";\r\n\r\nclass BubbleDemo extends  Component{\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    render(){\r\n        // return(<MainSvg></MainSvg>)\r\n        // return(<DataHacker></DataHacker>)\r\n        // return(<CSVData></CSVData>)\r\n        // return(<GapMinderNew ></GapMinderNew>)\r\n        // return(<ManuallyTree ></ManuallyTree>)\r\n        // return(<LocalCluster ></LocalCluster>)\r\n         //return(<HierarchicalCluster ></HierarchicalCluster>)\r\n        //return(<AdaptiveIsovalue ></AdaptiveIsovalue>)\r\n\r\n        return(<IndexUI></IndexUI>)\r\n\r\n        // return(<Example1 ></Example1>)\r\n\r\n    }\r\n}\r\n\r\nexport default BubbleDemo","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport './index.css';\r\nimport {\r\n    drawPolygon,\r\n    drawCircle,\r\n    drawLine,\r\n    calDistance,\r\n    calCommonTanPoint,\r\n    getDegreeTwoVec,\r\n    crossMul,\r\n    calTanPoint, drawArc, rotatePoint\r\n} from \"./util\";\r\nimport * as turf from '@turf/turf'\r\n\r\n\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\nvar d3Voronoi = require(\"d3-voronoi\")\r\nvar jsgraphs = require('js-graph-algorithms');\r\n// var colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\nvar colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar re=20\r\nvar bt=5\r\nvar tanPointsNum=0\r\n\r\nvar cd=1\r\nvar calpha=1\r\nvar ci=100\r\n\r\nvar deltaDeg=10/180*Math.PI\r\n\r\n\r\nclass KelpDiagram extends Component{\r\n    constructor(){\r\n        super()\r\n        this.pointData = [];\r\n        this.itemShape=\"circle\"\r\n        this.maxX=Number.MIN_VALUE\r\n        this.minX=Number.MAX_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.itemBBox=[]\r\n        this.catPointDict={}\r\n        this.voronoiPolygons=[]\r\n        this.elementSpace=[]\r\n        this.elementPoly=[]\r\n        this.pathString=[]\r\n        this.VI=[]\r\n        this.tanGraphEdges=[]\r\n        this.tanGraphPoints=[]\r\n        this.edges=[]\r\n        this.newVI=[]\r\n        // this.graph=null\r\n    }\r\n\r\n    componentDidMount() {\r\n        // let filename=\"newExample1.txt\"\r\n        let filename=\"BubbleSetExample1.txt\"\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.pointData = data;\r\n                this.itemShape = data[0].shape;\r\n                this.centralizeData()\r\n                this.drawPointData()\r\n                console.time(\"total time\")\r\n                this.calVoronoiDiagram()\r\n                this.calElementSpace()\r\n                this.approxArcWithPolygon()\r\n                this.drawSpacePathWithPolygon()\r\n                this.calTanGraphWithPolygon()\r\n                console.log(this.tanGraphPoints)\r\n                console.log(this.tanGraphEdges)\r\n                // this.calSpacePath()\r\n                // this.calTangentGraph()\r\n                // this.splitCircularEdge()\r\n                this.calShortestPath()\r\n                console.timeEnd(\"total time\")\r\n\r\n\r\n                // this.drawSplitEdge()\r\n                // this.drawTanPoint()\r\n                // this.drawTangentEdges()\r\n                // this.createGraph()\r\n\r\n            })\r\n    }\r\n\r\n    addCircularEdge(tanPoints){\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for (let i=0;i<tanPoints.length;i++){\r\n            let points=tanPoints[i]\r\n            for(let e=0;e<this.elementSpace[i].length;e++){\r\n                let eseg=this.elementSpace[i][e]\r\n                if(eseg.type==\"arc\"){\r\n                    let onpoints=[]\r\n                    let dearray=[]\r\n                    for(let p=0;p<points.length;p++){\r\n                        if(this.isPointOnArc([points[p].x,points[p].y],eseg)){\r\n                            onpoints.push(points[p])\r\n                        }\r\n                    }\r\n                    //sort the points according to degree\r\n\r\n                    let startpoint=this.tanGraphPoints[eseg.startid]\r\n                    let endpoint=this.tanGraphPoints[eseg.endid]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n\r\n                    for (let p=0;p<onpoints.length;p++){\r\n                        let pointvec=[onpoints[p].x-eseg.center[0],onpoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n\r\n                    dearray.push({\r\n                        index:p,\r\n                        degree:degree\r\n                    })\r\n                    }\r\n                    dearray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<dearray.length;d++){\r\n                        nextd=onpoints[dearray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n/*                    if(this.tanGraphEdges.length>=60036){\r\n                        console.log()\r\n                    }*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n    findApproxPointOnArc(point,arc){\r\n        let polypoints=arc.polysegment\r\n        let startpoint=arc.start\r\n        let center=arc.center\r\n        let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let degree=getDegreeTwoVec(startvec,pointvec)\r\n        let crossmul1=crossMul(startvec,pointvec)\r\n        if(crossmul1>0){\r\n            degree=2*Math.PI-degree\r\n        }\r\n        if(degree<0.000001){\r\n            return 0\r\n        }\r\n        let index=parseInt(degree/deltaDeg)\r\n\r\n/*        if(index>polypoints.length-1){\r\n            d3.select(\"svg\").selectAll(\"circle\").remove()\r\n            drawCircle(point[0],point[1],5,\"red\",\"none\")\r\n            drawCircle(polypoints[polypoints.length-1][0],polypoints[polypoints.length-1][1],5,\"blue\",\"none\")\r\n            drawCircle(polypoints[0][0],polypoints[0][1],5,\"black\",\"none\")\r\n\r\n        }*/\r\n\r\n        return index\r\n    }\r\n\r\n    isExist(p,points){\r\n        for(let i=0;i<points.length;i++){\r\n            if(p[0]==points[i].x&&p[1]==points[i].y){\r\n                return points[i].id\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n\r\n    calTanGraphWithPolygon(){\r\n        let tempTanEdges=[]\r\n        let tempTanPoints=[]\r\n        let pointsOnSameArc=[]\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            pointsOnSameArc.push([])\r\n        }\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            tempTanPoints.push(this.newVI[i])\r\n        }\r\n        console.log(this.catPointDict)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    let arc1\r\n                    let arc2\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    arc1=eleSpace1[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                        arc1=eleSpace1[0]\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    arc2=eleSpace2[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        arc2=eleSpace2[0]\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        let polyindex1=this.findApproxPointOnArc(linestart,arc1)\r\n                        let tanpoint1=arc1.polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        // drawCircle(tanpoint1[0],tanpoint1[1],2,\"green\",\"none\")\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex2=this.findApproxPointOnArc(lineend,arc2)\r\n\r\n                        let tanpoint2=arc2.polysegment[polyindex2]\r\n                        // drawCircle(tanpoint2[0],tanpoint2[1],2,\"green\",\"none\")\r\n\r\n                        let existindex2=this.isExist(tanpoint2,tempTanPoints)\r\n                        if(existindex2==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint2[0],\r\n                                y:tanpoint2[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex2=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:existindex1,\r\n                            endid:existindex2,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],[this.tanGraphPoints[existindex2].x,this.tanGraphPoints[existindex2].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                if(this.pointData[i].cat==this.pointData[j].cat){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n                }\r\n\r\n                if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                    //p to q\r\n                    let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    if(eleSpace2.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace2[0])\r\n                        let tanpoint0=eleSpace2[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace2[0])\r\n                        let tanpoint1=eleSpace2[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:existindex0,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:existindex1,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints.length;p++){\r\n                            for (let e=0;e<eleSpace2.length;e++){\r\n                                if(eleSpace2[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])\r\n                                        let tanpoint=eleSpace2[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:index2,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index1,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    //q to p\r\n                    let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                    tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                    if(eleSpace1.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints2[0].x,tanPoints2[0].y],eleSpace1[0])\r\n                        let tanpoint0=eleSpace1[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints2[1].x,tanPoints2[1].y],eleSpace1[0])\r\n                        let tanpoint1=eleSpace1[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                        }\r\n\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:existindex0,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:existindex1,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints2.length;p++){\r\n                            for (let e=0;e<eleSpace1.length;e++){\r\n                                if(eleSpace1[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])\r\n                                        let tanpoint=eleSpace1[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:index1,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index2,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.newVI[i].dataindex[0]\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].cat\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n                this.tanGraphEdges.push({\r\n                    type:\"line\",\r\n                    startid:this.newVI[i].id,\r\n                    endid:this.pointData[p].id,\r\n                    // startpoint:[points[j].x,points[j].y],\r\n                    // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                })\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace[0])\r\n                        let tanpoint0=eleSpace[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace[0])\r\n                        let tanpoint1=eleSpace[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex0,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex1,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[t].x,tanPoints[t].y],eleSpace[e])\r\n                                        let tanpoint=eleSpace[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:p,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:this.newVI[i].id,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        this.addCircularEdge(pointsOnSameArc)\r\n    }\r\n\r\n\r\n\r\n    above(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) > 0\r\n    }\r\n\r\n    below(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) < 0\r\n    }\r\n\r\n    isLeft(  P0,  P1,  P2 )\r\n{\r\n    return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);\r\n}\r\n\r\n    RLtangent_PolyPolyC(V,   W) {\r\n        let  ix1, ix2;      // search indices for polygons 1 and 2\r\n\r\n        // first get the initial vertex on each polygon\r\n        // ix1 = this.Rtangent_PointPolyC(W[0], V);   // right tangent from W[0] to V\r\n        ix1=this.tangent_PointPoly(W[0],V)[1]\r\n        // ix2 = this.Ltangent_PointPolyC(V[ix1], W); // left tangent from V[ix1] to W\r\n\r\n        ix2=this.tangent_PointPoly(V[ix1],W)[0]\r\n\r\n        // ping-pong linear search until it stabilizes\r\n        let done = false                    // flag when done\r\n        while (done == false) {\r\n            done = true;                     // assume done until...\r\n            while (this.isLeft(W[(ix2+W.length)%W.length], V[ix1], V[ix1+1]) <= 0){\r\n                ++ix1;                       // get Rtangent from W[ix2] to V\r\n            }\r\n\r\n            while (this.isLeft(V[ix1], W[(ix2+W.length)%W.length], W[(ix2-1+W.length)%W.length]) >= 0){\r\n                --ix2;                       // get Ltangent from V[ix1] to W\r\n                done = false;                // not done if had to adjust this\r\n            }\r\n        }\r\n        let t1 = ix1;\r\n        let t2 = ix2;\r\n        if(t1<0){\r\n            t1=t1+V.length\r\n        }\r\n        if(t2<0){\r\n            t2=t2+W.length\r\n        }\r\n\r\n        return[t1,t2]\r\n    }\r\n\r\n\r\n\r\n    drawSpacePathWithPolygon(){\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let espace=this.elementPoly[i]\r\n            let nowp=espace[0]\r\n            let nextp\r\n            for (let e=1;e<espace.length;e++){\r\n                nextp=espace[e]\r\n                drawLine([nowp.x,nowp.y],[nextp.x,nextp.y],\"red\",2)\r\n                nowp=nextp\r\n            }\r\n        }\r\n    }\r\n\r\n    approxArcWithPolygon(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            for (let e=0;e<espace.length;e++){\r\n\r\n                let center=espace[e].center\r\n                let radius=espace[e].radius\r\n                if(espace[e].type==\"arc\"){\r\n                    let startpoint=espace[e].start\r\n                    let endpoint=espace[e].end\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    let endvec=[endpoint[0]-center[0],endpoint[1]-center[1]]\r\n                    // let vecstart=[espace[e].]\r\n                    let degree=getDegreeTwoVec(startvec,endvec)\r\n\r\n                    let crossmul1=crossMul(startvec,endvec)\r\n                    if(crossmul1>0){\r\n                        degree=2*Math.PI-degree\r\n                    }\r\n\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n\r\n                    polySegs.push(startpoint)\r\n                    while(d<degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n                else if(espace[e].type==\"circle\"){\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    let endpoint=startpoint\r\n                    espace[e].start=startpoint\r\n                    espace[e].end=endpoint\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n                    let degree=Math.PI*2\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n                    polySegs.push(startpoint)\r\n                    while(d<=degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            let newespace=[]\r\n            for (let e=0;e<espace.length;e++){\r\n                if(espace[e].type==\"line\"){\r\n                    newespace.push(espace[e])\r\n                }\r\n                else{\r\n                    //arc segments\r\n                    let nowp=espace[e].polysegment[0]\r\n                    for (let s=1;s<espace[e].polysegment.length;s++){\r\n                        let nextp=espace[e].polysegment[s]\r\n                        newespace.push({\r\n                            type:\"line\",\r\n                            center:espace[e].center,\r\n                            radius:re,\r\n                            start:nowp,\r\n                            end:nextp\r\n                        })\r\n                        nowp=nextp\r\n                    }\r\n                }\r\n            }\r\n            this.elementPoly.push(newespace)\r\n        }\r\n\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let eseg=this.elementPoly[i]\r\n            let newsegs=[]\r\n            newsegs.push({\r\n                x:eseg[0].start[0],\r\n                y:eseg[0].start[1],\r\n                degree:0\r\n            })\r\n            for (let e=0;e<eseg.length;e++){\r\n                let point=eseg[e].end\r\n                newsegs.push({\r\n                    x:point[0],\r\n                    y:point[1],\r\n                    degree:0\r\n                })\r\n            }\r\n            this.elementPoly[i]=newsegs\r\n        }\r\n\r\n        console.log(this.elementPoly)\r\n\r\n    }\r\n\r\n    calVoronoiDiagram(){\r\n        let that=this\r\n        let diagram=d3Voronoi.voronoi()\r\n            .extent([[that.minX-50,that.minY-50],[that.maxX+50,that.maxY+50]])\r\n            .x(function(d){\r\n                return d.x\r\n            })\r\n            .y(function(d){\r\n                return d.y\r\n            })\r\n        let polygons=diagram.polygons(this.pointData)\r\n        this.voronoiPolygons=polygons\r\n        //Polygons are also counterclockwise\r\n/*        for (let i=0;i<polygons.length;i++){\r\n            drawPolygon(polygons[i],0,0,\"red\")\r\n        }*/\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            drawCircle(this.pointData[i].x,this.pointData[i].y,re,\"none\",\"black\")\r\n        }*/\r\n\r\n        console.log(polygons)\r\n\r\n    }\r\n\r\n    calElementSpace(){\r\n        for (let i=0;i<this.voronoiPolygons.length;i++){\r\n         let polypoints=this.voronoiPolygons[i]\r\n            let pointnum=polypoints.length\r\n            let data=polypoints.data\r\n            let id=polypoints.data.id\r\n            let eleSpace=[]\r\n            let insideLines=[]\r\n            let circle=ShapeInfo.circle({cx: data.x, cy: data.y, r: re})\r\n            let vi=[]\r\n         for (let p=0;p<polypoints.length;p++){\r\n             let thisp=polypoints[p]\r\n             let nextp=polypoints[(p+1)%pointnum]\r\n             // drawLine(thisp,nextp,\"blue\")\r\n             //check intersection between line and circle\r\n             let inside=IntersectionQuery.pointInCircle( {x:thisp[0],y:thisp[1]}, {x:data.x,y:data.y} ,  re)\r\n             if(inside){\r\n                 let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                 if(inside2){\r\n                     insideLines.push([thisp,nextp])\r\n                 }\r\n         else{\r\n             let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                    let point=intersections.points[0]\r\n                     vi.push([point.x,point.y])\r\n                     insideLines.push([thisp,[point.x,point.y]])\r\n                 }\r\n             }\r\n        else{\r\n                 let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                 if(inside2){\r\n                     let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                     let point=intersections.points[0]\r\n                     vi.push([point.x,point.y])\r\n                     insideLines.push([[point.x,point.y],nextp])\r\n                 }\r\n        else{\r\n                     let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                     if(intersections.status==\"Intersection\"){\r\n                         let points=intersections.points\r\n                         let dis1=calDistance(thisp[0],thisp[1],points[0].x,points[0].y)\r\n                         let dis2=calDistance(thisp[0],thisp[1],points[1].x,points[1].y)\r\n                         if(dis1<dis2){\r\n                             insideLines.push([[points[0].x,points[0].y],[points[1].x,points[1].y]])\r\n                             vi.push([points[0].x,points[0].y])\r\n                             vi.push([points[1].x,points[1].y])\r\n                         }\r\n                     else{\r\n                             insideLines.push([[points[1].x,points[1].y],[points[0].x,points[0].y]])\r\n                             vi.push([points[1].x,points[1].y])\r\n                             vi.push([points[0].x,points[0].y])\r\n                         }\r\n                     }\r\n                     else{\r\n                         //no intersection with the circle\r\n                     }\r\n\r\n                 }\r\n             }\r\n         }\r\n\r\n         this.VI.push(vi)\r\n        if(insideLines.length>0){\r\n            for (let l=0;l<insideLines.length;l++){\r\n                // drawLine(insideLines[l][0],insideLines[l][1],\"blue\")\r\n                eleSpace.push({\r\n                    type:\"line\",\r\n                    start:insideLines[l][0],\r\n                    end:insideLines[l][1],\r\n                    center:[data.x,data.y],\r\n                    radius:re\r\n                })\r\n                let point1=insideLines[l][1]\r\n                let point2=insideLines[(l+1)%insideLines.length][0]\r\n                if(point1[0]==point2[0]&&point1[1]==point2[1]){\r\n\r\n                }\r\n                else{\r\n                    //insert an arc\r\n                    eleSpace.push({\r\n                        type:\"arc\",\r\n                        start:point1,\r\n                        end:point2,\r\n                        center:[data.x,data.y],\r\n                        radius:re\r\n                    })\r\n                }\r\n\r\n            }\r\n        }\r\n        else{\r\n            eleSpace.push({\r\n                type:\"circle\",\r\n                start:[],\r\n                end:[],\r\n                center:[data.x,data.y],\r\n                radius:re\r\n            })\r\n        }\r\n        this.elementSpace.push(eleSpace)\r\n        }\r\n        console.log(this.elementSpace)\r\n    }\r\n\r\n    calSpacePath(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let pathstr=\"\"\r\n            let segs=this.elementSpace[i]\r\n            if(i==5){\r\n                console.log()\r\n            }\r\n            for (let s=0;s<segs.length;s++){\r\n                let type=segs[s].type\r\n                let center=segs[s].center\r\n                let startp=segs[s].start\r\n                let endp=segs[s].end\r\n                let radius=re\r\n\r\n                if(type==\"circle\"){\r\n                    // drawCircle(segs[s].center[0],segs[s].center[1],segs[s].radius,\"none\",\"black\")\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    pathstr+=\"M \"+startpoint[0]+\",\"+startpoint[1]+\" a \"+radius+\",\"+radius+\" 0 1,0 \"+2*radius+\",0\"\r\n                    pathstr+=\" a \"+radius+\",\"+radius+\" 0 1,0 \"+-1*2*radius+\",0\"\r\n                }\r\n                else if(type==\"arc\"){\r\n                    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                    let largearcflag=0\r\n                    let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                    let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n/*                    if(i==5){\r\n                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                        drawLine(vec1[0],vec1[1],\"red\")\r\n                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                    }*/\r\n\r\n                    let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                    if(crossmul>0){\r\n                        largearcflag=1\r\n                    }\r\n                    else if(crossmul<=0){\r\n                        largearcflag=0\r\n                    }\r\n\r\n                    pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n\r\n\r\n                }\r\n                else if(type==\"line\"){\r\n                    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                    pathstr+=\"L \"+endp[0]+\",\"+endp[1]\r\n                }\r\n            }\r\n            d3.select(\"svg\")\r\n                .append(\"path\")\r\n                .attr(\"id\",\"elespace\"+i)\r\n                .attr(\"d\",pathstr)\r\n                .attr(\"fill\",\"none\")\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"stroke-width\",\"2\")\r\n            this.pathString.push(pathstr)\r\n        }\r\n    }\r\n\r\n    initVI(){\r\n        // console.log(this.VI)\r\n        let newVI=[]\r\n        for (let i=0;i<this.VI.length;i++){\r\n            for (let j=0;j<this.VI[i].length;j++){\r\n                let vpoint=this.VI[i][j]\r\n                let has=false\r\n                for (let v=0;v<newVI.length;v++){\r\n                    if(vpoint[0]==newVI[v].x&&vpoint[1]==newVI[v].y){\r\n                        has=true\r\n                        break\r\n                    }\r\n                }\r\n                if(!has){\r\n                    let vipoint={\r\n                        type:\"vi\",\r\n                        x:vpoint[0],\r\n                        y:vpoint[1],\r\n                        dataindex:[i,j],\r\n                        id:tanPointsNum\r\n                    }\r\n                    tanPointsNum+=1\r\n                    newVI.push(vipoint)\r\n                    this.tanGraphPoints.push(vipoint)\r\n                }\r\n            }\r\n\r\n        }\r\n        this.newVI=newVI\r\n        for(let i=0;i<newVI.length;i++){\r\n            for (let e=0;e<this.elementSpace.length;e++){\r\n                let espace=this.elementSpace[e]\r\n                for (let s=0;s<espace.length;s++){\r\n                    let eseg=espace[s]\r\n                    if(eseg.type==\"arc\"){\r\n                        let start=eseg.start\r\n                        let end=eseg.end\r\n                        if(start[0]==newVI[i].x&&start[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].startid=newVI[i].id\r\n                        }\r\n                        if(end[0]==newVI[i].x&&end[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].endid=newVI[i].id\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(this.newVI)\r\n    }\r\n\r\n    isPointOnArc(point,arc){\r\n        let start=arc.start\r\n        let end=arc.end\r\n        let center=arc.center\r\n        let startvec=[start[0]-center[0],start[1]-center[1]]\r\n        let endvec=[end[0]-center[0],end[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let startEndDeg=getDegreeTwoVec(startvec,endvec)\r\n        let pointStartDeg=getDegreeTwoVec(startvec,pointvec)\r\n\r\n        let crossmul1=crossMul(startvec,endvec)\r\n\r\n        if(crossmul1>0){\r\n            startEndDeg=2*Math.PI-startEndDeg\r\n        }\r\n\r\n        let crossmul2=crossMul(startvec,pointvec)\r\n\r\n        if(crossmul2>0){\r\n            pointStartDeg=2*Math.PI-pointStartDeg\r\n        }\r\n\r\n        if(pointStartDeg<=startEndDeg){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    calTangentGraph(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        console.log(this.catPointDict)\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        /*                            if(index1==80){\r\n                                                        drawLine(linestart,lineend,\"red\",2)\r\n                                                    }*/\r\n                        let startpoint={\r\n                            type:\"tanpoint\",\r\n                            x:linestart[0],\r\n                            y:linestart[1],\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        this.tanGraphPoints.push(startpoint)\r\n                        tanPointsNum+=1\r\n                        let endpoint={\r\n                            type:\"tanpoint\",\r\n                            x:lineend[0],\r\n                            y:lineend[1],\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        this.tanGraphPoints.push(endpoint)\r\n                        tanPointsNum+=1\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:startpoint.id,\r\n                            endid:endpoint.id,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                if(this.pointData[i].cat==this.pointData[j].cat){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n                }\r\n\r\n                if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                    //p to q\r\n                    let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    if(eleSpace2.length==1){\r\n                        let point0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[0].x,\r\n                            y:tanPoints[0].y,\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(point0)\r\n                        let point1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[1].x,\r\n                            y:tanPoints[1].y,\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(point1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:point0.id,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:point1.id,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints.length;p++){\r\n                            for (let e=0;e<eleSpace2.length;e++){\r\n                                if(eleSpace2[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                        let tanpoint={\r\n                                            type:\"tanpoint\",\r\n                                            x:tanPoints[p].x,\r\n                                            y:tanPoints[p].y,\r\n                                            dataindex:index2,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index1,\r\n                                            endid:tanpoint.id,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //q to p\r\n                    let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                    tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                    if(eleSpace1.length==1){\r\n                        let tanpoint0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints2[0].x,\r\n                            y:tanPoints2[0].y,\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint0)\r\n                        let tanpoint1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints2[1].x,\r\n                            y:tanPoints2[1].y,\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:tanpoint0.id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[0].x,tanPoints2[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:tanpoint1.id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[1].x,tanPoints2[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints2.length;p++){\r\n                            for (let e=0;e<eleSpace1.length;e++){\r\n                                if(eleSpace1[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                        let tanpoint={\r\n                                            type:\"tanpoint\",\r\n                                            x:tanPoints2[p].x,\r\n                                            y:tanPoints2[p].y,\r\n                                            dataindex:index1,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index2,\r\n                                            endid:tanpoint.id,\r\n                                            // startpoint:[points[j].x,points[j].y],\r\n                                            // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.newVI[i].dataindex[0]\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].cat\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n                this.tanGraphEdges.push({\r\n                    type:\"line\",\r\n                    startid:this.newVI[i].id,\r\n                    endid:this.pointData[p].id,\r\n                    // startpoint:[points[j].x,points[j].y],\r\n                    // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                })\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let tanpoint0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[0].x,\r\n                            y:tanPoints[0].y,\r\n                            dataindex:p,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint0)\r\n                        let tanpoint1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[1].x,\r\n                            y:tanPoints[1].y,\r\n                            dataindex:p,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:tanpoint0.id,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:tanpoint1.id,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n                                        let tanpoint={\r\n                                            type: \"tanpoint\",\r\n                                            x: tanPoints[t].x,\r\n                                            y: tanPoints[t].y,\r\n                                            dataindex: p,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n\r\n                                        this.tanGraphEdges.push({\r\n                                            type: \"line\",\r\n                                            startid: this.newVI[i].id,\r\n                                            endid: tanpoint.id,\r\n                                            // startpoint: vp,\r\n                                            // endpoint: [tanPoints[p].x, tanPoints[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(this.tanGraphPoints)\r\n\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            let points=this.VI[i]\r\n            for (let p=0;p<points.length;p++){\r\n                this.tanGraphEdges.push({\r\n                    startid:i,\r\n                    endid:i,\r\n                    startpoint:points[p],\r\n                    endpoint:[this.pointData[i].x,this.pointData[i].y]\r\n                })\r\n            }\r\n        }*/\r\n\r\n\r\n\r\n    }\r\n\r\n    splitCircularEdge(){\r\n        let viMap=[]\r\n        let tanPointMap=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            viMap.push([])\r\n            tanPointMap.push([])\r\n        }\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let id=this.newVI[i].dataindex[0]\r\n            viMap[id].push(this.newVI[i])\r\n        }\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].type==\"tanpoint\"){\r\n                let index=this.tanGraphPoints[i].dataindex\r\n                tanPointMap[index].push(this.tanGraphPoints[i])\r\n            }\r\n        }\r\n\r\n/*        for (let i=0;i<tanPointMap.length;i++){\r\n            if(i==91){\r\n                for (let j=0;j<tanPointMap[i].length;j++){\r\n                    drawCircle(tanPointMap[i][j].x,tanPointMap[i][j].y,2,\"red\",\"none\")\r\n                }\r\n            }\r\n        }*/\r\n\r\n\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            let elespace=this.elementSpace[i]\r\n            let vis=viMap[i]\r\n            let tanpoints=tanPointMap[i]\r\n            for(let e=0;e<elespace.length;e++){\r\n                let eseg=elespace[e]\r\n                if(eseg.type==\"arc\"){\r\n                    //split this eseg\r\n                    let startindex=-1\r\n                    let endindex=-1\r\n                    let startpoint\r\n                    let endpoint\r\n                    let onPoints=[]\r\n                    for (let v=0;v<vis.length;v++){\r\n                        if(vis[v].x==eseg.start[0]&&vis[v].y==eseg.start[1]){\r\n                            startindex=vis[v].id\r\n                            startpoint=this.tanGraphPoints[startindex]\r\n                        }\r\n                        if(vis[v].x==eseg.end[0]&&vis[v].y==eseg.end[1]){\r\n                            endindex=vis[v].id\r\n                            endpoint=this.tanGraphPoints[endindex]\r\n                        }\r\n                    }\r\n                    for (let t=0;t<tanpoints.length;t++){\r\n                        if(this.isPointOnArc([tanpoints[t].x,tanpoints[t].y],eseg)){\r\n                            onPoints.push(tanpoints[t])\r\n                        }\r\n                    }\r\n                    // console.log(startindex,endindex,onPoints)\r\n/*                    if(i==91){\r\n                        drawCircle(startpoint.x,startpoint.y,5,\"red\",\"none\")\r\n                        drawCircle(endpoint.x,endpoint.y,5,\"green\",\"none\")\r\n                        for (let o=0;o<onPoints.length;o++){\r\n                            drawCircle(onPoints[o].x,onPoints[o].y,2,\"blue\",\"none\")\r\n                        }\r\n\r\n                    }*/\r\n\r\n                    let deArray=[]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n                    let endvec=[endpoint.x-eseg.center[0],endpoint.y-eseg.center[1]]\r\n                    for (let p=0;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                        index:p,\r\n                        degree:degree\r\n                    })\r\n\r\n                    }\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n                else if(eseg.type==\"circle\"){\r\n                    let onPoints=tanpoints\r\n                    let startvec=[onPoints[0].x-eseg.center[0],onPoints[0].y-eseg.center[1]]\r\n                    let deArray=[]\r\n                    for (let p=1;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=onPoints[0]\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6002){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:onPoints[0].id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n        console.log(this.tanGraphEdges)\r\n/*        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].dataindex==91){\r\n                drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"green\",\"none\")\r\n            }\r\n        }*/\r\n    }\r\n\r\n    drawSplitEdge(){\r\n        for(let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].type==\"arc\"){\r\n                let pathstr=\"\"\r\n                let startid=this.tanGraphEdges[i].startid\r\n                let endid=this.tanGraphEdges[i].endid\r\n                let startp=[this.tanGraphPoints[startid].x,this.tanGraphPoints[startid].y]\r\n                let endp=[this.tanGraphPoints[endid].x,this.tanGraphPoints[endid].y]\r\n                let center=this.tanGraphEdges[i].center\r\n                let radius=this.tanGraphEdges[i].radius\r\n\r\n                // drawCircle(startp[0],startp[1],2,\"red\",\"none\")\r\n                // drawCircle(endp[0],endp[1],2,\"red\",\"none\")\r\n\r\n                pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                let largearcflag=0\r\n                let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n                /*                    if(i==5){\r\n                                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                                        drawLine(vec1[0],vec1[1],\"red\")\r\n                                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                                    }*/\r\n\r\n                let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                if(crossmul>0){\r\n                    largearcflag=1\r\n                }\r\n                else if(crossmul<=0){\r\n                    largearcflag=0\r\n                }\r\n\r\n                pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n                d3.select(\"svg\")\r\n                    .append(\"path\")\r\n                    .attr(\"d\",pathstr)\r\n                    .attr(\"fill\",\"none\")\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"stroke-width\",\"1\")\r\n            }\r\n        }\r\n    }\r\n\r\n    calScoreForAll(){\r\n        //cal distance,alpha and crossing num\r\n        console.time(\"cal score\")\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            let startdataid=startpoint.dataindex\r\n            let enddataid=endpoint.dataindex\r\n            let center=this.tanGraphEdges[i].center\r\n            if(this.tanGraphEdges[i].type==\"line\"){\r\n                let cat\r\n                if(startpoint.type==\"vi\"){\r\n                    cat=this.pointData[startpoint.dataindex[0]].cat\r\n                }\r\n                else{\r\n                    cat=this.pointData[startpoint.dataindex].cat\r\n                }\r\n                // console.log(cat)\r\n                let dis=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                this.tanGraphEdges[i].distance=dis\r\n                this.tanGraphEdges[i].crossnum=0\r\n                this.tanGraphEdges[i].alpha=0\r\n                //cal intersection with elespacepath\r\n                let crossnum=0\r\n                for (let e=0;e<this.pathString.length;e++){\r\n                    let cat2=this.pointData[e].cat\r\n                    if(cat!=cat2&&e!=startdataid&&e!=enddataid){\r\n                        const path = ShapeInfo.path(this.pathString[e]);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(path, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n\r\n                }\r\n                this.tanGraphEdges[i].crossnum=crossnum\r\n            }\r\n\r\n            else{\r\n                //arc edges\r\n                let startvec=[startpoint.x-center[0],startpoint.y-center[1]]\r\n                let endvec=[endpoint.x-center[0],endpoint.y-center[1]]\r\n                let degree=getDegreeTwoVec(startvec,endvec)\r\n                let littledegree=degree\r\n                let crossmul1=crossMul(startvec,endvec)\r\n                if(crossmul1>0){\r\n                    degree=2*Math.PI-degree\r\n                }\r\n                let arcLength=degree*re\r\n                this.tanGraphEdges[i].distance=arcLength\r\n                this.tanGraphEdges[i].crossnum=0\r\n/*                if(degree>Math.PI){\r\n                    this.tanGraphEdges[i].alpha=degree-Math.PI\r\n                }\r\n                else{\r\n                    this.tanGraphEdges[i].alpha=Math.PI-degree\r\n                }*/\r\n                this.tanGraphEdges[i].alpha=littledegree\r\n\r\n                drawArc([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],center,re)\r\n                // console.log()\r\n\r\n            }\r\n\r\n            this.tanGraphEdges[i].cl=cd*this.tanGraphEdges[i].distance+calpha*this.tanGraphEdges[i].alpha+ci*this.tanGraphEdges[i].crossnum\r\n\r\n\r\n        }\r\n        console.timeEnd(\"cal score\")\r\n    }\r\n\r\n    calScoreForAllWithPoly(){\r\n        //cal distance,alpha and crossing num\r\n        console.time(\"cal score\")\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n\r\n            let center=this.tanGraphEdges[i].center\r\n\r\n                let cat\r\n                if(startpoint.type==\"vi\"){\r\n                    cat=this.pointData[startpoint.dataindex[0]].cat\r\n                }\r\n                else{\r\n                    cat=this.pointData[startpoint.dataindex].cat\r\n                }\r\n                // console.log(cat)\r\n                let dis=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                this.tanGraphEdges[i].distance=dis\r\n                this.tanGraphEdges[i].crossnum=0\r\n                this.tanGraphEdges[i].alpha=0\r\n                //cal intersection with elespacepath\r\n                let crossnum=0\r\n                for (let p=0;p<this.elementPoly.length;p++){\r\n                    let cat2=this.pointData[p].cat\r\n                    if(cat!=cat2&&p!=startpoint.dataindex&&p!=endpoint.dataindex) {\r\n                        let polyPoints=[]\r\n                        for (let e=0;e<this.elementPoly[p].length;e++){\r\n                            polyPoints.push({\r\n                                x:this.elementPoly[p][e].x,\r\n                                y:this.elementPoly[p][e].y\r\n                            })\r\n                        }\r\n                        const poly = ShapeInfo.polygon(polyPoints);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(poly, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    }\r\n/*                for (let e=0;e<this.pathString.length;e++){\r\n                    let cat2=this.pointData[e].cat\r\n                    if(cat!=cat2&&e!=startdataid&&e!=enddataid){\r\n                        const path = ShapeInfo.path(this.pathString[e]);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(path, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n\r\n                }*/\r\n                this.tanGraphEdges[i].crossnum=crossnum\r\n\r\n\r\n            this.tanGraphEdges[i].cl=cd*this.tanGraphEdges[i].distance+calpha*this.tanGraphEdges[i].alpha+ci*this.tanGraphEdges[i].crossnum\r\n\r\n\r\n        }\r\n        console.timeEnd(\"cal score\")\r\n    }\r\n\r\n    normalizeEdgeLength(){\r\n        let maxDis=-1\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].distance>maxDis){\r\n                maxDis=this.tanGraphEdges[i].distance\r\n            }\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            this.tanGraphEdges[i].distance=this.tanGraphEdges[i].distance/maxDis\r\n        }\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calPathLength(path){\r\n        let length=0\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let startid=e.from()\r\n            let endid=e.to()\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            length+=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n        }\r\n        return length\r\n    }\r\n\r\n    isSamePath(path1,path2){\r\n        if(path1.length!=path2.length){\r\n            return false\r\n        }\r\n        for (let i=0;i<path1.length;i++){\r\n            let start1=path1[i].from()\r\n            let end1=path1[i].to()\r\n            let start2=path2[i].from()\r\n            let end2=path2[i].to()\r\n            if(start1==start2&&end1==end2||start1==end2&&start2==end1){\r\n\r\n            }\r\n        else{\r\n            return false\r\n            }\r\n\r\n        }\r\n        return true\r\n    }\r\n\r\n    calShortestPath(){\r\n        console.log(this.elementPoly)\r\n\r\n        this.calScoreForAllWithPoly()\r\n\r\n        this.normalizeEdgeLength()\r\n        //cal edge dict\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            edgeDict[startid].push(this.tanGraphEdges[i])\r\n            edgeDict[endid].push(this.tanGraphEdges[i])\r\n        }\r\n\r\n        //create graph\r\n        var g = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length);\r\n\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let score=this.tanGraphEdges[i].cl\r\n            g.addEdge(new jsgraphs.Edge(startid, endid, score));\r\n            g.addEdge(new jsgraphs.Edge(endid, startid, score));\r\n            g.edge(startid,endid).label=i\r\n            g.edge(endid,startid).label=i\r\n\r\n        }\r\n        // this.graph=g\r\n\r\n        var GL= new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length);\r\n\r\n        let dpq={}\r\n        for (var k in this.catPointDict){\r\n            let points=this.catPointDict[k]\r\n            for (let i=0;i<points.length;i++){\r\n                let p1=points[i]\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let p2=points[j]\r\n                    if(!dpq.hasOwnProperty(p1.id)){\r\n                        dpq[p1.id]={}\r\n                    }\r\n                    dpq[p1.id][p2.id]=-1\r\n\r\n                    if(!dpq.hasOwnProperty(p2.id)){\r\n                        dpq[p2.id]={}\r\n                    }\r\n                    dpq[p2.id][p1.id]=-1\r\n                }\r\n            }\r\n        }\r\n\r\n        let paths=[]\r\n\r\n\r\n        while(true){\r\n            let bestscore=-1\r\n            let bestindex1=-1\r\n            let bestindex2=-1\r\n            let minpath=[]\r\n            let hasInfinite=false\r\n\r\n            //find the best link\r\n            for (var k in this.catPointDict){\r\n                let points=this.catPointDict[k]\r\n                for (let i=0;i<points.length;i++){\r\n                    let p1=points[i]\r\n                    var dijkstra = new jsgraphs.Dijkstra(g,p1.id);\r\n\r\n                    for (let j=i+1;j<points.length;j++){\r\n                        let p2=points[j]\r\n\r\n                        //calculate cl and find maximum bpq\r\n                        let path=dijkstra.pathTo(p2.id)\r\n                        let cl=dijkstra.distanceTo(p2.id)\r\n                        let bpq\r\n                        if(dpq[p1.id][p2.id]==-1){\r\n                            if(!hasInfinite){\r\n                                let hasAdded=false\r\n                                for(let p=0;p<paths.length;p++){\r\n                                    if(this.isSamePath(path,paths[p])){\r\n                                        hasAdded=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(!hasAdded){\r\n                                    hasInfinite=true\r\n                                    bestindex1=p1.id\r\n                                    bestindex2=p2.id\r\n                                    bestscore=cl\r\n                                    minpath=path\r\n                                }\r\n                            }\r\n                            else{\r\n                                if(bestscore>cl){\r\n                                    let hasAdded=false\r\n                                    for(let p=0;p<paths.length;p++){\r\n                                        if(this.isSamePath(path,paths[p])){\r\n                                            hasAdded=true\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                    if(!hasAdded) {\r\n                                        bestindex1=p1.id\r\n                                        bestindex2=p2.id\r\n                                        bestscore=cl\r\n                                        minpath=path\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(hasInfinite){\r\n                                continue\r\n                            }\r\n                            else{\r\n                                bpq=dpq[p1.id][p2.id]/cl\r\n                                if(bpq>bestscore){\r\n                                    let hasAdded=false\r\n                                    for(let p=0;p<paths.length;p++){\r\n                                        if(this.isSamePath(path,paths[p])){\r\n                                            hasAdded=true\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                    if(!hasAdded) {\r\n                                        bestscore=bpq\r\n                                        bestindex1=p1.id\r\n                                        bestindex2=p2.id\r\n                                        minpath=path\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(bestscore<=bt){\r\n                break\r\n            }\r\n            else{\r\n                //add this path and update crossnum and dpq\r\n\r\n                this.drawPath(minpath)\r\n                paths.push(minpath)\r\n\r\n                for (let i=0;i<minpath.length;i++){\r\n                    let e=minpath[i]\r\n                    let start=e.from()\r\n                    let end=e.to()\r\n                    let startpoint=this.tanGraphPoints[start]\r\n                    let endpoint=this.tanGraphPoints[end]\r\n\r\n                    if(GL.edge(start,end)==null){\r\n                        GL.addEdge(new jsgraphs.Edge(start, end, calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)) )\r\n                        GL.addEdge(new jsgraphs.Edge(end, start, calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)) )\r\n                    }\r\n\r\n                    //update crossnum\r\n                    for (let p=0;p<this.tanGraphEdges.length;p++){\r\n                        if(this.tanGraphEdges[p].type==\"line\"){\r\n                            let cat\r\n                            if(startpoint.type==\"vi\"){\r\n                                cat=this.pointData[startpoint.dataindex[0]].cat\r\n                            }\r\n                            else{\r\n                                cat=this.pointData[startpoint.dataindex].cat\r\n                            }\r\n\r\n                                let start2=this.tanGraphEdges[p].startid\r\n                                let end2=this.tanGraphEdges[p].endid\r\n                                let startpoint2=this.tanGraphPoints[start2]\r\n                                let endpoint2=this.tanGraphPoints[end2]\r\n\r\n                                let cat2\r\n\r\n                                if(startpoint2.type==\"vi\"){\r\n                                    cat2=this.pointData[startpoint2.dataindex[0]].cat\r\n                                }\r\n                                else{\r\n                                    cat2=this.pointData[startpoint2.dataindex].cat\r\n                                }\r\n                                if(cat!=cat2){\r\n                                    if(this.checkEdgeCrossing(startpoint,endpoint,startpoint2,endpoint2)){\r\n                                        this.tanGraphEdges[p].crossnum+=1\r\n                                        this.tanGraphEdges[p].cl+=ci\r\n                                        let startid=this.tanGraphEdges[p].startid\r\n                                        let endid=this.tanGraphEdges[p].endid\r\n                                        g.edge(startid,endid).weight=this.tanGraphEdges[p].cl\r\n                                        g.edge(endid,startid).weight=this.tanGraphEdges[p].cl\r\n                                    }\r\n                                }\r\n\r\n\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                for(let id1=0;id1<this.pointData.length;id1++){\r\n                    let datapoint=this.pointData[id1]\r\n                    var dijkstraGL = new jsgraphs.Dijkstra(GL,datapoint.id);\r\n\r\n                    for (let id2=id1+1;id2<this.pointData.length;id2++){\r\n                        let datapoint2=this.pointData[id2]\r\n/*                        if(id1==10&&id2==15){\r\n                            console.log(GL.adj(15))\r\n                            console.log(GL.adj(16))\r\n                            console.log(dijkstraGL.hasPathTo(15))\r\n                            console.log()\r\n                        }*/\r\n                        if(dijkstraGL.hasPathTo(datapoint2.id)){\r\n                            let newd=dijkstraGL.distanceTo(datapoint2.id)\r\n                            if(dpq[id1][id2]==-1){\r\n                                dpq[id1][id2]=newd\r\n                                dpq[id2][id1]=newd\r\n                            }\r\n                            else{\r\n                                if(dpq[id1][id2]>newd){\r\n                                    dpq[id1][id2]=newd\r\n                                    dpq[id2][id1]=newd\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n        }\r\n\r\n        console.log(paths)\r\n\r\n    }\r\n\r\n    drawPath(path){\r\n        let that=this\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let start=e.from()\r\n            let end=e.to()\r\n            let startpoint=this.tanGraphPoints[start]\r\n            let endpoint=this.tanGraphPoints[end]\r\n\r\n                // drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"red\",2)\r\n                d3.select(\"svg\").append(\"line\")\r\n                    .attr(\"x1\",startpoint.x)\r\n                    .attr(\"y1\",startpoint.y)\r\n                    .attr(\"x2\",endpoint.x)\r\n                    .attr(\"y2\",endpoint.y)\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"black\")\r\n\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n\r\n        }\r\n    }\r\n\r\n\r\n\r\n    createGraph(){\r\n        //create full graph\r\n        let connectG={}\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let e=0;e<this.tanGraphEdges.length;e++){\r\n            let edge=this.tanGraphEdges[e]\r\n            let distance=calDistance(edge.startpoint[0],edge.startpoint[1],edge.endpoint[0],edge.endpoint[1])\r\n            edgeDict[edge.startid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n            edgeDict[edge.endid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n        }\r\n\r\n\r\n        console.log(edgeDict)\r\n        for (var k in this.catPointDict){\r\n            connectG[k]=[]\r\n            let points=this.catPointDict[k]\r\n            for(let i=0;i<points.length;i++){\r\n                let id1=points[i].id\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let id2=points[j].id\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawTanPoint(){\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"red\",\"none\")\r\n        }\r\n    }\r\n\r\n    drawTangentEdges(){\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            if(startpoint.dataindex==25||endpoint.dataindex==25)\r\n                drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"blue\",1)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData.id=i\r\n        }\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-40)+\" \"+(miny-40)+\" \"+(maxx-minx+80)+\" \"+(maxy-miny+80))\r\n\r\n\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        let offsetX = minx-20;\r\n        let offsetY = miny-20;\r\n        let viewWidth = maxx-minx+40;\r\n        let viewHeight = maxy-miny+40\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id=i\r\n            this.pointData[i].cat=this.pointData[i].cat.toString()\r\n            let cats=this.pointData[i].cat.split(\",\")\r\n            let catarray=[]\r\n            if (cats.length>1){\r\n                this.pointData[i].multicat=true\r\n                for (let c=0;c<cats.length;c++){\r\n                    catarray.push(cats[c])\r\n                }\r\n            }\r\n            else{\r\n                this.pointData[i].multicat=false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray=catarray\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n            }\r\n        }\r\n\r\n        // console.log(this.catPointDict)\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={900} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default KelpDiagram","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport './index.css';\r\nimport {\r\n    drawPolygon,\r\n    drawCircle,\r\n    drawLine,\r\n    calDistance,\r\n    calCommonTanPoint,\r\n    getDegreeTwoVec,\r\n    crossMul,\r\n    calTanPoint, drawArc, rotatePoint, clone\r\n} from \"./util\";\r\nimport * as turf from '@turf/turf'\r\n\r\n\r\nconst {ShapeInfo, Intersection, Point2D, IntersectionQuery} = require(\"kld-intersections\");\r\n\r\nvar d3Voronoi = require(\"d3-voronoi\")\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar triangulate = require(\"delaunay-triangulate\")\r\nvar AreaCal = require('2d-polygon-area');\r\nvar FileSaver = require('file-saver');\r\n// var colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar tanPointsNum = 0\r\nvar deltaDeg = 10 / 180 * Math.PI\r\nvar re = 15\r\nvar parameter_C = 0\r\nvar parameter_t = 3\r\nvar parameter_A = -1\r\nvar EdgeWidth = 10\r\nconst eps = 1e-10\r\nvar neighbors = {}\r\n\r\nvar lineFunction = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    //.curve(d3.curveCatmullRom);\r\n\r\n\r\nclass KelpFusion extends Component{\r\n    constructor(){\r\n        super()\r\n        this.pointData = [];\r\n        this.itemShape=\"circle\"\r\n        this.maxX=Number.MIN_VALUE\r\n        this.minX=Number.MAX_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.itemBBox=[]\r\n        this.catPointDict={}\r\n        this.voronoiPolygons=[]\r\n        this.elementSpace=[]\r\n        this.elementPoly=[]\r\n        //this.pathString=[]\r\n        this.VI=[]\r\n        this.tanGraphEdges=[]\r\n        this.tanGraphPoints=[]\r\n        this.edges=[]\r\n        this.newVI=[]\r\n        this.initGraph = {}\r\n        this.initPoints = {}\r\n        this.initEdges = {}\r\n        this.SPGEdges = {}\r\n        this.SPG = {}\r\n        this.catPointMap = {}\r\n        this.catInitEdges = {}\r\n        this.rGEdges = {}\r\n        this.rG = {}\r\n        this.tanPointMap = {}\r\n        this.visited = []\r\n        this.fa = []\r\n        this.circles = {}\r\n        this.polygons = {}\r\n        this.SPGAdjList = {}\r\n        // this.graph=null\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        let file_list = [\r\n            \"co2_gdppercapita\",\r\n            \"co2_income\",\r\n            \"life_children\",\r\n            \"life_income\",\r\n            \"Bronx\",\r\n            \"Brooklyn\",\r\n            \"Citywide\",\r\n            \"Manhattan\",\r\n            \"life_fertility\",\r\n            \"Staten Island\",\r\n            \"ex1\",\r\n            \"ex2\",\r\n            \"ex3\",\r\n            \"ex4\",\r\n            \"ex5\",\r\n            \"ex6\",\r\n            \"ex7\",\r\n            \"ex8\",\r\n            \"ex9\",\r\n            \"ex10\",\r\n            \"ex11\",\r\n            \"ex12\",\r\n            \"ex13\",\r\n            \"ex14\",\r\n            \"ex15\",\r\n            \"ex16\",\r\n            \"ex17\",\r\n            \"ex18\",\r\n            \"ex19\",\r\n            \"ex20\"\r\n        ];\r\n\r\n\r\n        //let fi = file_list[5]\r\n        let fi = \"ex13\"\r\n        let filename =  fi + \".txt\"\r\n        let flag = false\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n\r\n                console.time(\"running time\")\r\n                this.pointData = data;\r\n                this.itemShape = data[0].shape;\r\n                this.centralizeData()\r\n                //this.drawPointData()\r\n                console.log(filename)\r\n\r\n                /*\r\n                if(flag){\r\n                    let content = JSON.stringify(this.catPointDict)\r\n                    let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n                    FileSaver.saveAs(blob, fi + \".json\");\r\n                }\r\n                else{\r\n                    this.drawLineSets(fi)\r\n                }\r\n                 */\r\n\r\n                console.log(\"pointData!\")\r\n                console.log(this.pointData)\r\n                console.time(\"total time\")\r\n\r\n                this.calVoronoiDiagram()\r\n                this.calElementSpace()\r\n                this.approxArcWithPolygon()\r\n                this.drawSpacePathWithPolygon()\r\n\r\n                for(let k in this.catPointDict){\r\n                    this.rGEdges[k] = []\r\n                }\r\n\r\n                this.calTanGraphWithPolygon()\r\n\r\n                // Add point and edges on the element polygon\r\n                let preLen = this.tanGraphPoints.length\r\n                this.tanPointMap = {}\r\n                for(let k in this.catPointDict){\r\n                    this.catPointMap[k] = {}\r\n                }\r\n                let addIdx = {}\r\n\r\n                for(let i = 0; i < preLen; i ++){\r\n\r\n                    if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n\r\n                        this.tanPointMap[this.tanGraphPoints[i].dataindex] = i\r\n\r\n                        let idx = this.tanGraphPoints[i].dataindex\r\n                        for (let c = 0; c < this.pointData[idx].catArray.length; c ++){\r\n                            let nowcat = this.pointData[idx].catArray[c]\r\n                            if(!this.catPointMap[nowcat].hasOwnProperty(idx)){\r\n                                this.catPointMap[nowcat][idx] = 1\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                for(let i = 0; i < this.elementPoly.length; i ++){\r\n                    addIdx[i] = []\r\n                    for(let j = 0; j < this.elementPoly[i].length ; j ++){\r\n                        let idx = this.tanGraphPoints.length\r\n                        addIdx[i].push(idx)\r\n                        this.tanGraphPoints.push({\r\n                            type:\"addpoint\",\r\n                            x:this.elementPoly[i][j].x,\r\n                            y:this.elementPoly[i][j].y,\r\n                            dataindex:i,\r\n                            id:idx\r\n                        })\r\n                    }\r\n                    for(let j = 0; j < addIdx[i].length; j ++){\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:addIdx[i][j],\r\n                            endid:addIdx[i][(j + 1) % addIdx[i].length]\r\n                        })\r\n\r\n                        for(let k in this.catPointDict){\r\n                            this.rGEdges[k].push({\r\n                                type:\"line\",\r\n                                startid:addIdx[i][j],\r\n                                endid:addIdx[i][(j + 1) % addIdx[i].length]\r\n                            })\r\n                        }\r\n\r\n                        //TODO : Bug Fix\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:addIdx[i][j],\r\n                            endid:this.tanPointMap[i]\r\n                        })\r\n\r\n                        let cat_array = this.pointData[i].catArray\r\n                        for(let c = 0; c < cat_array.length; c ++){\r\n                            let nowcat = cat_array[c]\r\n                            this.rGEdges[nowcat].push({\r\n                                type:\"line\",\r\n                                startid:addIdx[i][j],\r\n                                endid:this.tanPointMap[i]\r\n                            })\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < preLen; i ++){\r\n                    if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n                        continue\r\n                    }\r\n                    let idx\r\n                    if(this.tanGraphPoints[i].type == \"vi\"){\r\n                        idx = this.tanGraphPoints[i].dataindex\r\n                    }\r\n                    else{\r\n                        idx = [this.tanGraphPoints[i].dataindex]\r\n                    }\r\n                    let x1 = this.tanGraphPoints[i].x\r\n                    let y1 = this.tanGraphPoints[i].y\r\n                    for(let j = 0; j < idx.length; j ++){\r\n                        let pointID = idx[j]\r\n                        let selectIdx = -1\r\n                        let minDis = Number.MAX_VALUE\r\n                        for(let p = 0; p < addIdx[pointID].length; p ++){\r\n                            let x2 = this.tanGraphPoints[addIdx[pointID][p]].x\r\n                            let y2 = this.tanGraphPoints[addIdx[pointID][p]].y\r\n                            let tmpDis = calDistance(x1, y1, x2, y2)\r\n                            if(tmpDis < minDis){\r\n                                minDis = tmpDis\r\n                                selectIdx = addIdx[pointID][p]\r\n                            }\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:i,\r\n                            endid:selectIdx\r\n                        })\r\n                        for(let k in this.catPointDict){\r\n                            this.rGEdges[k].push({\r\n                                type:\"line\",\r\n                                startid:i,\r\n                                endid:selectIdx\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //console.log(\"rGEdges\")\r\n                //console.log(this.rGEdges)\r\n\r\n                //for(let cur_k in this.catPointDict){\r\n                //    let cur_k = \"0\"\r\n                //    for(let i = 0; i < this.rGEdges[cur_k].length; i ++){\r\n                //        let startid = this.rGEdges[cur_k][i].startid\r\n                //        let endid = this.rGEdges[cur_k][i].endid\r\n                //        let startpoint = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                //        let endpoint = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n//\r\n                //        let idx1 = this.tanGraphPoints[startid].dataindex\r\n                //        if(this.tanGraphPoints[startid].type != \"vi\"){\r\n                //            idx1 = [idx1]\r\n                //        }\r\n//\r\n                //        let idx2 = this.tanGraphPoints[endid].dataindex\r\n                //        if(this.tanGraphPoints[endid].type != \"vi\"){\r\n                //            idx2 = [idx2]\r\n                //        }\r\n//\r\n                //        let cat1 = this.pointData[idx1[0]].cat\r\n                //        let cat2 = this.pointData[idx2[0]].cat\r\n//\r\n                //        //if(cat1 == cat2 && cat1 == \"2\" && this.tanGraphPoints[endid].type == \"datapoint\" &&this.tanGraphPoints[endid].type == \"datapoint\")\r\n                //            //drawLine(startpoint, endpoint, 'black', 1)\r\n                //    }\r\n               // }\r\n\r\n                //for(let i = 0; i < this.tanGraphEdges.length; i ++){\r\n                //    let startid = this.tanGraphEdges[i].startid\r\n                //    let endid = this.tanGraphEdges[i].endid\r\n                //    let startpoint = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                //    let endpoint = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                //    //drawLine(startpoint, endpoint, 'black', 1)\r\n                //}\r\n\r\n\r\n                //this.drawTanPoint()\r\n                //this.drawTangentEdges()\r\n                //console.log(\"tanGraph!\")\r\n                //console.log(this.tanGraphPoints)\r\n                //console.log(this.tanGraphEdges)\r\n                //console.log(this.elementPoly)\r\n                //console.log(this.elementSpace)\r\n\r\n                //for(let i = 0; i < this.tanGraphPoints.length ; i ++){\r\n                //    d3.select('svg').append(\"circle\")\r\n                //        .attr(\"cx\",this.tanGraphPoints[i].x)\r\n                //        .attr(\"cy\",this.tanGraphPoints[i].y)\r\n                //        .attr(\"r\",1)\r\n                //        .attr(\"fill\",\"black\")\r\n                //}\r\n\r\n                //for(let i = 0; i < )\r\n\r\n\r\n                this.createInitGraph()\r\n                this.createSPG()\r\n\r\n                console.timeEnd(\"total time\")\r\n\r\n                //this.calCrossEdges()\r\n\r\n                console.timeEnd(\"running time\")\r\n\r\n                this.findAllCircles()\r\n                this.findPolygons()\r\n                this.judgePolygons()\r\n                this.drawKelpFusion()\r\n                this.drawPointData()\r\n                this.saveSVG(fi)\r\n\r\n                //console.log(this.elementSpace)\r\n\r\n               //console.log(\"element space\")\r\n               //console.log(this.elementSpace)\r\n               //console.log(\"element ploygon\")\r\n               //console.log(this.elementPoly)\r\n\r\n\r\n\r\n            })\r\n\r\n\r\n    }\r\n\r\n    saveSVG(filename){\r\n        let svg=d3.select(\"#mainsvg\")\r\n        let width=svg.attr(\"width\")\r\n        let height=svg.attr(\"height\")\r\n        let viewbox=svg.attr(\"viewBox\")\r\n        let svgstr=svg.html()\r\n        let xmlns=\"http://www.w3.org/2000/svg\"\r\n        svgstr=\"<svg xmlns=\\\"\"+xmlns+\"\\\" width=\\\"\"+width+\"\\\" height=\\\"\"+height+\"\\\" viewBox=\\\"\"+viewbox+\"\\\" >\\n\"+svgstr+\"\\n</svg>\"\r\n        let content = svgstr;\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n        FileSaver.saveAs(blob, filename + \".svg\");\r\n        // console.log(svgstr)\r\n    }\r\n\r\n    drawLineSets(fi){\r\n        let filename1 = fi + \".txt\"\r\n        let filename2 = fi + \"_cross.txt\"\r\n        fetch('/data/line_data/'+filename1,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                let path = data\r\n                console.log(path)\r\n                for(let k in this.catPointDict){\r\n                    d3.select(\"svg\").append(\"path\")\r\n                        .attr('d',lineFunction(path[k]))\r\n                        .attr(\"id\",\"path\" + k)\r\n                        .attr(\"fill\",'none')\r\n                        .style('stroke', colors[parseInt(k)])\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n\r\n                this.saveSVG(fi)\r\n\r\n                /*\r\n                fetch('/data/line_data/'+filename2,{\r\n                    method:'GET',\r\n                    headers:{\r\n                        'Content-Type':'application/json;charset=UTF-8'\r\n                    },\r\n                    mode:'cors',\r\n                    cache:'default'\r\n                })\r\n                    .then(res=>res.json())\r\n                    .then(data=>{\r\n                        let cross_edge = data\r\n                        for(let k in cross_edge){\r\n                            let tmpPath = d3.select(\"#path\" + k).node()\r\n                            let totLen = tmpPath.getTotalLength()\r\n                            for(let p = 0; p < cross_edge[k].length; p ++){\r\n                                let st = [cross_edge[k][p][0], cross_edge[k][p][1]]\r\n                                let en = [cross_edge[k][p][2], cross_edge[k][p][3]]\r\n                                //drawLine(st, en, \"red\", 4)\r\n                                let idx1 = -1\r\n                                let idx2 = -1\r\n                                let mindis1 = Number.MAX_VALUE\r\n                                let mindis2 = Number.MAX_VALUE\r\n                                for(let l = 0; l < totLen / 5; l ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * l)\r\n                                    let dis1 = calDistance(st[0], st[1], tmp_p.x, tmp_p.y)\r\n                                    let dis2 = calDistance(en[0], en[1], tmp_p.x, tmp_p.y)\r\n                                    if(dis1 < mindis1){\r\n                                        mindis1 = dis1\r\n                                        idx1 = l\r\n                                    }\r\n                                    if(dis2 < mindis2){\r\n                                        mindis2 = dis2\r\n                                        idx2 = l\r\n                                    }\r\n                                }\r\n                                let tmp_lines = []\r\n                                for(let l = idx1; l <= idx2; l ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * l)\r\n                                    tmp_lines.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr('d',lineFunction(tmp_lines))\r\n                                    .attr(\"fill\",'none')\r\n                                    .style('stroke', \"red\")\r\n                                    .style(\"stroke-width\", 4);\r\n                            }\r\n                        }\r\n\r\n                        this.saveSVG(fi)\r\n\r\n                    })\r\n                 */\r\n            })\r\n    }\r\n\r\n    addCircularEdge(tanPoints){\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for (let i=0;i<tanPoints.length;i++){\r\n            let points=tanPoints[i]\r\n            for(let e=0;e<this.elementSpace[i].length;e++){\r\n                let eseg=this.elementSpace[i][e]\r\n                if(eseg.type==\"arc\"){\r\n                    let onpoints=[]\r\n                    let dearray=[]\r\n                    for(let p=0;p<points.length;p++){\r\n                        if(this.isPointOnArc([points[p].x,points[p].y],eseg)){\r\n                            onpoints.push(points[p])\r\n                        }\r\n                    }\r\n                    //sort the points according to degree\r\n\r\n                    let startpoint=this.tanGraphPoints[eseg.startid]\r\n                    let endpoint=this.tanGraphPoints[eseg.endid]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n\r\n                    for (let p=0;p<onpoints.length;p++){\r\n                        let pointvec=[onpoints[p].x-eseg.center[0],onpoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n\r\n                        dearray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n                    dearray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<dearray.length;d++){\r\n                        nextd=onpoints[dearray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push({\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:nextd.id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            })\r\n                        }\r\n\r\n\r\n\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:endpoint.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                    }\r\n\r\n                    /*                    if(this.tanGraphEdges.length>=60036){\r\n                                            console.log()\r\n                                        }*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    findApproxPointOnArc(point,arc){\r\n        let polypoints=arc.polysegment\r\n        let startpoint=arc.start\r\n        let center=arc.center\r\n        let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let degree=getDegreeTwoVec(startvec,pointvec)\r\n        let crossmul1=crossMul(startvec,pointvec)\r\n        if(crossmul1>0){\r\n            degree=2*Math.PI-degree\r\n        }\r\n        if(degree<0.000001){\r\n            return 0\r\n        }\r\n        let index=parseInt(degree/deltaDeg)\r\n\r\n        /*        if(index>polypoints.length-1){\r\n                    d3.select(\"svg\").selectAll(\"circle\").remove()\r\n                    drawCircle(point[0],point[1],5,\"red\",\"none\")\r\n                    drawCircle(polypoints[polypoints.length-1][0],polypoints[polypoints.length-1][1],5,\"blue\",\"none\")\r\n                    drawCircle(polypoints[0][0],polypoints[0][1],5,\"black\",\"none\")\r\n\r\n                }*/\r\n\r\n        return index\r\n    }\r\n\r\n    isExist(p,points){\r\n        for(let i=0;i<points.length;i++){\r\n            if(p[0]==points[i].x&&p[1]==points[i].y){\r\n                return points[i].id\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n    calTanGraphWithPolygon(){\r\n        let tempTanEdges=[]\r\n        let tempTanPoints=[]\r\n        let pointsOnSameArc=[]\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            pointsOnSameArc.push([])\r\n        }\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            tempTanPoints.push(this.newVI[i])\r\n        }\r\n        //console.log(this.catPointDict)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    let arc1\r\n                    let arc2\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    arc1=eleSpace1[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                        arc1=eleSpace1[0]\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    arc2=eleSpace2[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        arc2=eleSpace2[0]\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        let polyindex1=this.findApproxPointOnArc(linestart,arc1)\r\n                        let tanpoint1=arc1.polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        // drawCircle(tanpoint1[0],tanpoint1[1],2,\"green\",\"none\")\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex2=this.findApproxPointOnArc(lineend,arc2)\r\n\r\n                        let tanpoint2=arc2.polysegment[polyindex2]\r\n                        // drawCircle(tanpoint2[0],tanpoint2[1],2,\"green\",\"none\")\r\n\r\n                        let existindex2=this.isExist(tanpoint2,tempTanPoints)\r\n                        if(existindex2==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint2[0],\r\n                                y:tanpoint2[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex2=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:existindex1,\r\n                            endid:existindex2,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push({\r\n                                type:\"line\",\r\n                                startid:existindex1,\r\n                                endid:existindex2,\r\n                                // startpoint:linestart,\r\n                                // endpoint:lineend\r\n                            })\r\n                        }\r\n\r\n                        // drawLine([this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],[this.tanGraphPoints[existindex2].x,this.tanGraphPoints[existindex2].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                let sameflag = false\r\n                let addcat = []\r\n                for(let p = 0; p < this.pointData[i].catArray.length; p ++){\r\n                    for(let q = 0; q < this.pointData[j].catArray.length; q ++){\r\n                        if(this.pointData[i].catArray[p] == this.pointData[j].catArray[q]){\r\n                            sameflag = true\r\n                            addcat.push(this.pointData[i].catArray[p])\r\n                        }\r\n                    }\r\n                }\r\n                //if(sameflag){\r\n                if(true){\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n\r\n                    for(let p = 0; p < addcat.length; p ++){\r\n                        this.rGEdges[addcat[p]].push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:index2,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[points[j].x,points[j].y]\r\n                        })\r\n                    }\r\n\r\n\r\n                    if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                        //p to q\r\n                        let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                        tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                        if(eleSpace2.length==1){\r\n                            let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace2[0])\r\n                            let tanpoint0=eleSpace2[0].polysegment[polyindex0]\r\n                            let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                            if(existindex0==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint0[0],\r\n                                    y:tanpoint0[1],\r\n                                    dataindex:index2,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex0=tanpoint.id\r\n                                pointsOnSameArc[index2].push(tanpoint)\r\n                            }\r\n\r\n                            let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace2[0])\r\n                            let tanpoint1=eleSpace2[0].polysegment[polyindex1]\r\n                            let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                            if(existindex1==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint1[0],\r\n                                    y:tanpoint1[1],\r\n                                    dataindex:index2,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex1=tanpoint.id\r\n                                pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                            }\r\n\r\n\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index1,\r\n                                endid:existindex0,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                            })\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index1,\r\n                                endid:existindex1,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                            })\r\n\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index1,\r\n                                    endid:existindex0,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                })\r\n                            }\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index1,\r\n                                    endid:existindex1,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                })\r\n                            }\r\n\r\n\r\n                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                            // console.log()\r\n\r\n                        }\r\n                        else{\r\n\r\n                            for (let p=0;p<tanPoints.length;p++){\r\n                                for (let e=0;e<eleSpace2.length;e++){\r\n                                    if(eleSpace2[e].type==\"arc\"){\r\n                                        if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                            let polyindex=this.findApproxPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])\r\n                                            let tanpoint=eleSpace2[e].polysegment[polyindex]\r\n                                            let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                            if(existindex==-1){\r\n                                                let tanpointp={\r\n                                                    type:\"tanpoint\",\r\n                                                    x:tanpoint[0],\r\n                                                    y:tanpoint[1],\r\n                                                    dataindex:index2,\r\n                                                    id:tanPointsNum\r\n                                                }\r\n                                                this.tanGraphPoints.push(tanpointp)\r\n                                                tempTanPoints.push(tanpointp)\r\n                                                tanPointsNum+=1\r\n                                                existindex=tanpointp.id\r\n                                                pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                                            }\r\n                                            this.tanGraphEdges.push({\r\n                                                type:\"line\",\r\n                                                startid:index1,\r\n                                                endid:existindex,\r\n                                                // startpoint:[points[i].x,points[i].y],\r\n                                                // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                            })\r\n\r\n                                            for(let cat_k in this.catPointDict){\r\n                                                this.rGEdges[cat_k].push({\r\n                                                    type:\"line\",\r\n                                                    startid:index1,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                })\r\n                                            }\r\n                                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                            // console.log()\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        //q to p\r\n                        let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                        tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                        if(eleSpace1.length==1){\r\n                            let polyindex0=this.findApproxPointOnArc([tanPoints2[0].x,tanPoints2[0].y],eleSpace1[0])\r\n                            let tanpoint0=eleSpace1[0].polysegment[polyindex0]\r\n                            let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                            if(existindex0==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint0[0],\r\n                                    y:tanpoint0[1],\r\n                                    dataindex:index1,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex0=tanpoint.id\r\n                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                            }\r\n\r\n                            let polyindex1=this.findApproxPointOnArc([tanPoints2[1].x,tanPoints2[1].y],eleSpace1[0])\r\n                            let tanpoint1=eleSpace1[0].polysegment[polyindex1]\r\n                            let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                            if(existindex1==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint1[0],\r\n                                    y:tanpoint1[1],\r\n                                    dataindex:index1,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex1=tanpoint.id\r\n                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                            }\r\n\r\n\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index2,\r\n                                endid:existindex0,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                            })\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index2,\r\n                                endid:existindex1,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                            })\r\n\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index2,\r\n                                    endid:existindex0,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                })\r\n                            }\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index2,\r\n                                    endid:existindex1,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                })\r\n                            }\r\n\r\n                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                            // console.log()\r\n                        }\r\n                        else{\r\n                            for (let p=0;p<tanPoints2.length;p++){\r\n                                for (let e=0;e<eleSpace1.length;e++){\r\n                                    if(eleSpace1[e].type==\"arc\"){\r\n                                        if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                            let polyindex=this.findApproxPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])\r\n                                            let tanpoint=eleSpace1[e].polysegment[polyindex]\r\n                                            let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                            if(existindex==-1){\r\n                                                let tanpointp={\r\n                                                    type:\"tanpoint\",\r\n                                                    x:tanpoint[0],\r\n                                                    y:tanpoint[1],\r\n                                                    dataindex:index1,\r\n                                                    id:tanPointsNum\r\n                                                }\r\n                                                this.tanGraphPoints.push(tanpointp)\r\n                                                tempTanPoints.push(tanpointp)\r\n                                                tanPointsNum+=1\r\n                                                existindex=tanpointp.id\r\n                                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                                            }\r\n                                            this.tanGraphEdges.push({\r\n                                                type:\"line\",\r\n                                                startid:index2,\r\n                                                endid:existindex,\r\n                                                // startpoint:[points[i].x,points[i].y],\r\n                                                // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                            })\r\n\r\n                                            for(let cat_k in this.catPointDict){\r\n                                                this.rGEdges[cat_k].push({\r\n                                                    type:\"line\",\r\n                                                    startid:index2,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                })\r\n                                            }\r\n\r\n\r\n                                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                            // console.log()\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.pointData[this.newVI[i].dataindex[0]].catArray\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].catArray\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n\r\n                let sameflag = false\r\n                let addcat = []\r\n                for(let id1 = 0; id1 < cat1.length; id1 ++){\r\n                    for(let id2 = 0; id2 < cat2.length; id2 ++){\r\n                        if(cat1[id1] == cat2[id2]){\r\n                            sameflag = true\r\n                            addcat.push(cat1[id1])\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //if(sameflag){\r\n                if(true){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:this.newVI[i].id,\r\n                        endid:this.pointData[p].id,\r\n                        // startpoint:[points[j].x,points[j].y],\r\n                        // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                    })\r\n\r\n                    for(let cur_idx = 0; cur_idx < addcat.length; cur_idx ++){\r\n                        this.rGEdges[addcat[cur_idx]].push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:this.pointData[p].id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                        })\r\n                    }\r\n\r\n                }\r\n\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace[0])\r\n                        let tanpoint0=eleSpace[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace[0])\r\n                        let tanpoint1=eleSpace[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex0,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex1,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"line\",\r\n                                    startid:this.newVI[i].id,\r\n                                    endid:existindex0,\r\n                                    // startpoint:vp,\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                }\r\n                            )\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"line\",\r\n                                    startid:this.newVI[i].id,\r\n                                    endid:existindex1,\r\n                                    // startpoint:vp,\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                }\r\n                            )\r\n                        }\r\n\r\n\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[t].x,tanPoints[t].y],eleSpace[e])\r\n                                        let tanpoint=eleSpace[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:p,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:this.newVI[i].id,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n\r\n                                        for(let cat_k in this.catPointDict){\r\n                                            this.rGEdges[cat_k].push(\r\n                                                {\r\n                                                    type:\"line\",\r\n                                                    startid:this.newVI[i].id,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                }\r\n                                            )\r\n                                        }\r\n\r\n\r\n                                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        this.addCircularEdge(pointsOnSameArc)\r\n    }\r\n\r\n    above(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) > 0\r\n    }\r\n\r\n    below(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) < 0\r\n    }\r\n\r\n    isLeft(P0, P1, P2) {\r\n        return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);\r\n    }\r\n\r\n    RLtangent_PolyPolyC(V, W) {\r\n        let  ix1, ix2;      // search indices for polygons 1 and 2\r\n\r\n        // first get the initial vertex on each polygon\r\n        // ix1 = this.Rtangent_PointPolyC(W[0], V);   // right tangent from W[0] to V\r\n        ix1=this.tangent_PointPoly(W[0],V)[1]\r\n        // ix2 = this.Ltangent_PointPolyC(V[ix1], W); // left tangent from V[ix1] to W\r\n\r\n        ix2=this.tangent_PointPoly(V[ix1],W)[0]\r\n\r\n        // ping-pong linear search until it stabilizes\r\n        let done = false                    // flag when done\r\n        while (done == false) {\r\n            done = true;                     // assume done until...\r\n            while (this.isLeft(W[(ix2+W.length)%W.length], V[ix1], V[ix1+1]) <= 0){\r\n                ++ix1;                       // get Rtangent from W[ix2] to V\r\n            }\r\n\r\n            while (this.isLeft(V[ix1], W[(ix2+W.length)%W.length], W[(ix2-1+W.length)%W.length]) >= 0){\r\n                --ix2;                       // get Ltangent from V[ix1] to W\r\n                done = false;                // not done if had to adjust this\r\n            }\r\n        }\r\n        let t1 = ix1;\r\n        let t2 = ix2;\r\n        if(t1<0){\r\n            t1=t1+V.length\r\n        }\r\n        if(t2<0){\r\n            t2=t2+W.length\r\n        }\r\n\r\n        return[t1,t2]\r\n    }\r\n\r\n    drawSpacePathWithPolygon(){\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let espace=this.elementPoly[i]\r\n            let nowp=espace[0]\r\n            let nextp\r\n            for (let e=1;e<espace.length;e++){\r\n                nextp=espace[e]\r\n                drawLine([nowp.x,nowp.y],[nextp.x,nextp.y],\"black\",1)\r\n                nowp=nextp\r\n            }\r\n        }\r\n    }\r\n\r\n    approxArcWithPolygon(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            for (let e=0;e<espace.length;e++){\r\n\r\n                let center=espace[e].center\r\n                let radius=espace[e].radius\r\n                if(espace[e].type==\"arc\"){\r\n                    let startpoint=espace[e].start\r\n                    let endpoint=espace[e].end\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    let endvec=[endpoint[0]-center[0],endpoint[1]-center[1]]\r\n                    // let vecstart=[espace[e].]\r\n                    let degree=getDegreeTwoVec(startvec,endvec)\r\n\r\n                    let crossmul1=crossMul(startvec,endvec)\r\n                    if(crossmul1>0){\r\n                        degree=2*Math.PI-degree\r\n                    }\r\n\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n\r\n                    polySegs.push(startpoint)\r\n                    while(d<degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n                else if(espace[e].type==\"circle\"){\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    let endpoint=startpoint\r\n                    espace[e].start=startpoint\r\n                    espace[e].end=endpoint\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n                    let degree=Math.PI*2\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n                    polySegs.push(startpoint)\r\n                    while(d<=degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            let newespace=[]\r\n            for (let e=0;e<espace.length;e++){\r\n                if(espace[e].type==\"line\"){\r\n                    newespace.push(espace[e])\r\n                }\r\n                else{\r\n                    //arc segments\r\n                    let nowp=espace[e].polysegment[0]\r\n                    for (let s=1;s<espace[e].polysegment.length;s++){\r\n                        let nextp=espace[e].polysegment[s]\r\n                        newespace.push({\r\n                            type:\"line\",\r\n                            center:espace[e].center,\r\n                            radius:re,\r\n                            start:nowp,\r\n                            end:nextp\r\n                        })\r\n                        nowp=nextp\r\n                    }\r\n                }\r\n            }\r\n            this.elementPoly.push(newespace)\r\n        }\r\n\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let eseg=this.elementPoly[i]\r\n            let newsegs=[]\r\n            newsegs.push({\r\n                x:eseg[0].start[0],\r\n                y:eseg[0].start[1],\r\n                degree:0\r\n            })\r\n            for (let e=0;e<eseg.length;e++){\r\n                let point=eseg[e].end\r\n                newsegs.push({\r\n                    x:point[0],\r\n                    y:point[1],\r\n                    degree:0\r\n                })\r\n            }\r\n            this.elementPoly[i]=newsegs\r\n        }\r\n\r\n        console.log(this.elementPoly)\r\n\r\n    }\r\n\r\n    calVoronoiDiagram(){\r\n        let that=this\r\n        let diagram=d3Voronoi.voronoi()\r\n            .extent([[that.minX-50,that.minY-50],[that.maxX+50,that.maxY+50]])\r\n            .x(function(d){\r\n                return d.x\r\n            })\r\n            .y(function(d){\r\n                return d.y\r\n            })\r\n        let polygons=diagram.polygons(this.pointData)\r\n        this.voronoiPolygons=polygons\r\n        //Polygons are also counterclockwise\r\n        /*        for (let i=0;i<polygons.length;i++){\r\n                    drawPolygon(polygons[i],0,0,\"red\")\r\n                }*/\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    drawCircle(this.pointData[i].x,this.pointData[i].y,re,\"none\",\"black\")\r\n                }*/\r\n\r\n        console.log(polygons)\r\n\r\n    }\r\n\r\n    calElementSpace(){\r\n        for (let i=0;i<this.voronoiPolygons.length;i++){\r\n            let polypoints=this.voronoiPolygons[i]\r\n            let pointnum=polypoints.length\r\n            let data=polypoints.data\r\n            let id=polypoints.data.id\r\n            let eleSpace=[]\r\n            let insideLines=[]\r\n            let circle=ShapeInfo.circle({cx: data.x, cy: data.y, r: re})\r\n            let vi=[]\r\n            for (let p=0;p<polypoints.length;p++){\r\n                let thisp=polypoints[p]\r\n                let nextp=polypoints[(p+1)%pointnum]\r\n                // drawLine(thisp,nextp,\"blue\")\r\n                //check intersection between line and circle\r\n                let inside=IntersectionQuery.pointInCircle( {x:thisp[0],y:thisp[1]}, {x:data.x,y:data.y} ,  re)\r\n                if(inside){\r\n                    let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                    if(inside2){\r\n                        insideLines.push([thisp,nextp])\r\n                    }\r\n                    else{\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        let point=intersections.points[0]\r\n                        vi.push([point.x,point.y])\r\n                        insideLines.push([thisp,[point.x,point.y]])\r\n                    }\r\n                }\r\n                else{\r\n                    let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                    if(inside2){\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        let point=intersections.points[0]\r\n                        vi.push([point.x,point.y])\r\n                        insideLines.push([[point.x,point.y],nextp])\r\n                    }\r\n                    else{\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            let points=intersections.points\r\n                            let dis1=calDistance(thisp[0],thisp[1],points[0].x,points[0].y)\r\n                            let dis2=calDistance(thisp[0],thisp[1],points[1].x,points[1].y)\r\n                            if(dis1<dis2){\r\n                                insideLines.push([[points[0].x,points[0].y],[points[1].x,points[1].y]])\r\n                                vi.push([points[0].x,points[0].y])\r\n                                vi.push([points[1].x,points[1].y])\r\n                            }\r\n                            else{\r\n                                insideLines.push([[points[1].x,points[1].y],[points[0].x,points[0].y]])\r\n                                vi.push([points[1].x,points[1].y])\r\n                                vi.push([points[0].x,points[0].y])\r\n                            }\r\n                        }\r\n                        else{\r\n                            //no intersection with the circle\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.VI.push(vi)\r\n            if(insideLines.length>0){\r\n                for (let l=0;l<insideLines.length;l++){\r\n                    // drawLine(insideLines[l][0],insideLines[l][1],\"blue\")\r\n                    eleSpace.push({\r\n                        type:\"line\",\r\n                        start:insideLines[l][0],\r\n                        end:insideLines[l][1],\r\n                        center:[data.x,data.y],\r\n                        radius:re\r\n                    })\r\n                    let point1=insideLines[l][1]\r\n                    let point2=insideLines[(l+1)%insideLines.length][0]\r\n                    if(point1[0]==point2[0]&&point1[1]==point2[1]){\r\n\r\n                    }\r\n                    else{\r\n                        //insert an arc\r\n                        eleSpace.push({\r\n                            type:\"arc\",\r\n                            start:point1,\r\n                            end:point2,\r\n                            center:[data.x,data.y],\r\n                            radius:re\r\n                        })\r\n                    }\r\n\r\n                }\r\n            }\r\n            else{\r\n                eleSpace.push({\r\n                    type:\"circle\",\r\n                    start:[],\r\n                    end:[],\r\n                    center:[data.x,data.y],\r\n                    radius:re\r\n                })\r\n            }\r\n            this.elementSpace.push(eleSpace)\r\n        }\r\n        console.log(this.elementSpace)\r\n    }\r\n\r\n    initVI(){\r\n        // console.log(this.VI)\r\n        let newVI=[]\r\n        for (let i=0;i<this.VI.length;i++){\r\n            for (let j=0;j<this.VI[i].length;j++){\r\n                let vpoint=this.VI[i][j]\r\n                let has=false\r\n                for (let v=0;v<newVI.length;v++){\r\n                    if(vpoint[0]==newVI[v].x&&vpoint[1]==newVI[v].y){\r\n                        has=true\r\n                        break\r\n                    }\r\n                }\r\n                if(!has){\r\n                    let vipoint={\r\n                        type:\"vi\",\r\n                        x:vpoint[0],\r\n                        y:vpoint[1],\r\n                        dataindex:[i,j],\r\n                        id:tanPointsNum\r\n                    }\r\n                    tanPointsNum+=1\r\n                    newVI.push(vipoint)\r\n                    this.tanGraphPoints.push(vipoint)\r\n                }\r\n            }\r\n\r\n        }\r\n        this.newVI=newVI\r\n        for(let i=0;i<newVI.length;i++){\r\n            for (let e=0;e<this.elementSpace.length;e++){\r\n                let espace=this.elementSpace[e]\r\n                for (let s=0;s<espace.length;s++){\r\n                    let eseg=espace[s]\r\n                    if(eseg.type==\"arc\"){\r\n                        let start=eseg.start\r\n                        let end=eseg.end\r\n                        if(start[0]==newVI[i].x&&start[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].startid=newVI[i].id\r\n                        }\r\n                        if(end[0]==newVI[i].x&&end[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].endid=newVI[i].id\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(this.newVI)\r\n    }\r\n\r\n    isPointOnArc(point,arc){\r\n        let start=arc.start\r\n        let end=arc.end\r\n        let center=arc.center\r\n        let startvec=[start[0]-center[0],start[1]-center[1]]\r\n        let endvec=[end[0]-center[0],end[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let startEndDeg=getDegreeTwoVec(startvec,endvec)\r\n        let pointStartDeg=getDegreeTwoVec(startvec,pointvec)\r\n\r\n        let crossmul1=crossMul(startvec,endvec)\r\n\r\n        if(crossmul1>0){\r\n            startEndDeg=2*Math.PI-startEndDeg\r\n        }\r\n\r\n        let crossmul2=crossMul(startvec,pointvec)\r\n\r\n        if(crossmul2>0){\r\n            pointStartDeg=2*Math.PI-pointStartDeg\r\n        }\r\n\r\n        if(pointStartDeg<=startEndDeg){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    splitCircularEdge(){\r\n        let viMap=[]\r\n        let tanPointMap=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            viMap.push([])\r\n            tanPointMap.push([])\r\n        }\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let id=this.newVI[i].dataindex[0]\r\n            viMap[id].push(this.newVI[i])\r\n        }\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].type==\"tanpoint\"){\r\n                let index=this.tanGraphPoints[i].dataindex\r\n                tanPointMap[index].push(this.tanGraphPoints[i])\r\n            }\r\n        }\r\n\r\n        /*        for (let i=0;i<tanPointMap.length;i++){\r\n                    if(i==91){\r\n                        for (let j=0;j<tanPointMap[i].length;j++){\r\n                            drawCircle(tanPointMap[i][j].x,tanPointMap[i][j].y,2,\"red\",\"none\")\r\n                        }\r\n                    }\r\n                }*/\r\n\r\n\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            let elespace=this.elementSpace[i]\r\n            let vis=viMap[i]\r\n            let tanpoints=tanPointMap[i]\r\n            for(let e=0;e<elespace.length;e++){\r\n                let eseg=elespace[e]\r\n                if(eseg.type==\"arc\"){\r\n                    //split this eseg\r\n                    let startindex=-1\r\n                    let endindex=-1\r\n                    let startpoint\r\n                    let endpoint\r\n                    let onPoints=[]\r\n                    for (let v=0;v<vis.length;v++){\r\n                        if(vis[v].x==eseg.start[0]&&vis[v].y==eseg.start[1]){\r\n                            startindex=vis[v].id\r\n                            startpoint=this.tanGraphPoints[startindex]\r\n                        }\r\n                        if(vis[v].x==eseg.end[0]&&vis[v].y==eseg.end[1]){\r\n                            endindex=vis[v].id\r\n                            endpoint=this.tanGraphPoints[endindex]\r\n                        }\r\n                    }\r\n                    for (let t=0;t<tanpoints.length;t++){\r\n                        if(this.isPointOnArc([tanpoints[t].x,tanpoints[t].y],eseg)){\r\n                            onPoints.push(tanpoints[t])\r\n                        }\r\n                    }\r\n                    // console.log(startindex,endindex,onPoints)\r\n                    /*                    if(i==91){\r\n                                            drawCircle(startpoint.x,startpoint.y,5,\"red\",\"none\")\r\n                                            drawCircle(endpoint.x,endpoint.y,5,\"green\",\"none\")\r\n                                            for (let o=0;o<onPoints.length;o++){\r\n                                                drawCircle(onPoints[o].x,onPoints[o].y,2,\"blue\",\"none\")\r\n                                            }\r\n\r\n                                        }*/\r\n\r\n                    let deArray=[]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n                    let endvec=[endpoint.x-eseg.center[0],endpoint.y-eseg.center[1]]\r\n                    for (let p=0;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n\r\n                    }\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"arc\",\r\n                                    startid:thisd.id,\r\n                                    endid:nextd.id,\r\n                                    center:eseg.center,\r\n                                    radius:re\r\n                                }\r\n                            )\r\n                        }\r\n\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push(\r\n                            {\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:endpoint.id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n                else if(eseg.type==\"circle\"){\r\n                    let onPoints=tanpoints\r\n                    let startvec=[onPoints[0].x-eseg.center[0],onPoints[0].y-eseg.center[1]]\r\n                    let deArray=[]\r\n                    for (let p=1;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=onPoints[0]\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"arc\",\r\n                                    startid:thisd.id,\r\n                                    endid:nextd.id,\r\n                                    center:eseg.center,\r\n                                    radius:re\r\n                                }\r\n                            )\r\n                        }\r\n\r\n                        // if(this.tanGraphEdges.length==6002){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:onPoints[0].id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push(\r\n                            {\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:onPoints[0].id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n        console.log(this.tanGraphEdges)\r\n        /*        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n                    if(this.tanGraphPoints[i].dataindex==91){\r\n                        drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"green\",\"none\")\r\n                    }\r\n                }*/\r\n    }\r\n\r\n    drawSplitEdge(){\r\n        for(let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].type==\"arc\"){\r\n                let pathstr=\"\"\r\n                let startid=this.tanGraphEdges[i].startid\r\n                let endid=this.tanGraphEdges[i].endid\r\n                let startp=[this.tanGraphPoints[startid].x,this.tanGraphPoints[startid].y]\r\n                let endp=[this.tanGraphPoints[endid].x,this.tanGraphPoints[endid].y]\r\n                let center=this.tanGraphEdges[i].center\r\n                let radius=this.tanGraphEdges[i].radius\r\n\r\n                // drawCircle(startp[0],startp[1],2,\"red\",\"none\")\r\n                // drawCircle(endp[0],endp[1],2,\"red\",\"none\")\r\n\r\n                pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                let largearcflag=0\r\n                let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n                /*                    if(i==5){\r\n                                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                                        drawLine(vec1[0],vec1[1],\"red\")\r\n                                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                                    }*/\r\n\r\n                let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                if(crossmul>0){\r\n                    largearcflag=1\r\n                }\r\n                else if(crossmul<=0){\r\n                    largearcflag=0\r\n                }\r\n\r\n                pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n                d3.select(\"svg\")\r\n                    .append(\"path\")\r\n                    .attr(\"d\",pathstr)\r\n                    .attr(\"fill\",\"none\")\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"stroke-width\",\"1\")\r\n            }\r\n        }\r\n    }\r\n\r\n    normalizeEdgeLength(){\r\n        let maxDis=-1\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].distance>maxDis){\r\n                maxDis=this.tanGraphEdges[i].distance\r\n            }\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            this.tanGraphEdges[i].distance=this.tanGraphEdges[i].distance/maxDis\r\n        }\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calPathLength(path){\r\n        let length=0\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let startid=e.from()\r\n            let endid=e.to()\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            length+=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n        }\r\n        return length\r\n    }\r\n\r\n    isSamePath(path1,path2){\r\n        if(path1.length!=path2.length){\r\n            return false\r\n        }\r\n        for (let i=0;i<path1.length;i++){\r\n            let start1=path1[i].from()\r\n            let end1=path1[i].to()\r\n            let start2=path2[i].from()\r\n            let end2=path2[i].to()\r\n            if(start1==start2&&end1==end2||start1==end2&&start2==end1){\r\n\r\n            }\r\n            else{\r\n                return false\r\n            }\r\n\r\n        }\r\n        return true\r\n    }\r\n\r\n    drawPath(path){\r\n        let that=this\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let edgeid=e.label\r\n            let edge=this.tanGraphEdges[edgeid]\r\n            let startpoint=this.tanGraphPoints[edge.startid]\r\n            let endpoint=this.tanGraphPoints[edge.endid]\r\n            if(edge.type==\"line\"){\r\n                // drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"red\",2)\r\n                d3.select(\"svg\").append(\"line\")\r\n                    .attr(\"x1\",startpoint.x)\r\n                    .attr(\"y1\",startpoint.y)\r\n                    .attr(\"x2\",endpoint.x)\r\n                    .attr(\"y2\",endpoint.y)\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.tanGraphEdges[edgeid])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n            }\r\n        }\r\n    }\r\n\r\n    createGraph(){\r\n        //create full graph\r\n        let connectG={}\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let e=0;e<this.tanGraphEdges.length;e++){\r\n            let edge=this.tanGraphEdges[e]\r\n            let distance=calDistance(edge.startpoint[0],edge.startpoint[1],edge.endpoint[0],edge.endpoint[1])\r\n            edgeDict[edge.startid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n            edgeDict[edge.endid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n        }\r\n\r\n\r\n        console.log(edgeDict)\r\n        for (var k in this.catPointDict){\r\n            connectG[k]=[]\r\n            let points=this.catPointDict[k]\r\n            for(let i=0;i<points.length;i++){\r\n                let id1=points[i].id\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let id2=points[j].id\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawTanPoint(){\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"red\",\"none\")\r\n        }\r\n    }\r\n\r\n    drawTangentEdges(){\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            if(startpoint.dataindex==25||endpoint.dataindex==25)\r\n                drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"blue\",1)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData.id=i\r\n        }\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-40)+\" \"+(miny-40)+\" \"+(maxx-minx+80)+\" \"+(maxy-miny+80))\r\n\r\n\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        let offsetX = minx-20;\r\n        let offsetY = miny-20;\r\n        let viewWidth = maxx-minx+40;\r\n        let viewHeight = maxy-miny+40\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id=i\r\n            this.pointData[i].cat=this.pointData[i].cat.toString()\r\n            let cats=this.pointData[i].cat.split(\",\")\r\n            let catarray=[]\r\n            if (cats.length>1){\r\n                this.pointData[i].multicat=true\r\n                for (let c=0;c<cats.length;c++){\r\n                    catarray.push(cats[c])\r\n                }\r\n            }\r\n            else{\r\n                this.pointData[i].multicat=false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray=catarray\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n            }\r\n        }\r\n\r\n        // console.log(this.catPointDict)\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\", this.pointData[i].cat)\r\n                    .attr(\"index\", index)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 1)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 1)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    // Phase 1 : Shortest-path graph\r\n    // create the reachability graph for all sets\r\n    // edges are constrained as below:\r\n    // 1. w/2 away from any allocation areas except for the endpoints\r\n    // 2. the edges between the pairs of nodes that are neighbors in the Delauay triangulation\r\n    // 3. the weight of edges = Math.power(|e| + C, t)\r\n\r\n    calDelauayTriangulation(){\r\n        neighbors = {}\r\n        let tmp_pts = []\r\n        let points = this.pointData\r\n        for(let i = 0; i < points.length; i ++){\r\n            tmp_pts.push([points[i].x, points[i].y])\r\n        }\r\n        let triangles = triangulate(tmp_pts)\r\n        // construct dict for delauay triangulation neighbors\r\n        for(let i = 0; i < triangles.length; i ++){\r\n\r\n            let p1 = triangles[i][0]\r\n            let p2 = triangles[i][1]\r\n            let p3 = triangles[i][2]\r\n\r\n            //let tmp_poly = []\r\n            //tmp_poly.push([this.pointData[p1].x, this.pointData[p1].y])\r\n            //tmp_poly.push([this.pointData[p2].x, this.pointData[p2].y])\r\n            //tmp_poly.push([this.pointData[p3].x, this.pointData[p3].y])\r\n            //drawPolygon(tmp_poly, 0, 0, \"red\")\r\n\r\n            //p1 = this.catPointDict[k][p1].id\r\n            //p2 = this.catPointDict[k][p2].id\r\n            //p3 = this.catPointDict[k][p3].id\r\n\r\n\r\n            if(!neighbors.hasOwnProperty(p1)){\r\n                neighbors[p1] = {}\r\n                neighbors[p1][p2] = 1\r\n                neighbors[p1][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p2)){\r\n                neighbors[p2] = {}\r\n                neighbors[p2][p1] = 1\r\n                neighbors[p2][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p3)){\r\n                neighbors[p3] = {}\r\n                neighbors[p3][p1] = 1\r\n                neighbors[p3][p2] = 1\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEdgeConstrains(edge, k){\r\n\r\n\r\n        let startid = edge.startid\r\n        let endid = edge.endid\r\n\r\n        // judge whether the endpoints are neighbors\r\n        let dataindex1 = this.tanGraphPoints[startid].dataindex\r\n        let dataindex2 = this.tanGraphPoints[endid].dataindex\r\n\r\n        if(this.tanGraphPoints[startid].type == \"datapoint\"){\r\n            let cat_Array = this.pointData[dataindex1].catArray\r\n            let flag = false\r\n            for(let c = 0; c < cat_Array.length; c ++){\r\n                if(cat_Array[c] == k){\r\n                    flag = true\r\n                    break\r\n                }\r\n            }\r\n            if(!flag){\r\n                return false\r\n            }\r\n        }\r\n\r\n        if(this.tanGraphPoints[endid].type == \"datapoint\"){\r\n            let cat_Array = this.pointData[dataindex2].catArray\r\n            let flag = false\r\n            for(let c = 0; c < cat_Array.length; c ++){\r\n                if(cat_Array[c] == k){\r\n                    flag = true\r\n                    break\r\n                }\r\n            }\r\n            if(!flag){\r\n                return false\r\n            }\r\n        }\r\n\r\n\r\n        let idx1, idx2\r\n\r\n        if(this.tanGraphPoints[startid].type != \"vi\"){\r\n            idx1 = [dataindex1]\r\n        }\r\n        else{\r\n            idx1 = dataindex1\r\n        }\r\n\r\n        if(this.tanGraphPoints[endid].type != \"vi\"){\r\n            idx2 = [dataindex2]\r\n        }\r\n        else{\r\n            idx2 = dataindex2\r\n        }\r\n\r\n        /*\r\n        let neighborFlag = false\r\n        for(let p = 0; p < idx1.length; p ++){\r\n            let pt1 = idx1[p]\r\n            for(let q = 0; q < idx2.length; q ++){\r\n                let pt2 = idx2[q]\r\n                if(neighbors.hasOwnProperty(pt1)){\r\n                    if(neighbors[pt1].hasOwnProperty(pt2)){\r\n                        neighborFlag = true\r\n                        break\r\n                    }\r\n                }\r\n                if(neighbors.hasOwnProperty(pt2)){\r\n                    if(neighbors[pt2].hasOwnProperty(pt1)){\r\n                        neighborFlag = true\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!neighborFlag){\r\n            //return false\r\n        }\r\n        */\r\n\r\n        let disFlag = true\r\n\r\n        // judge whether the edge is w/2 away from any allocation areas except for the endpoints\r\n        for(let j = 0; j < this.elementPoly.length; j ++){\r\n\r\n            let flagg = false\r\n            for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                if(this.pointData[j].catArray[cur_idx] == k){\r\n                    flagg = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            if(flagg){\r\n\r\n                continue\r\n            }\r\n\r\n            let isSame1 = false\r\n            let isSame2 = false\r\n\r\n            for(let p = 0; p < idx1.length; p ++){\r\n                if(j == idx1[p]){\r\n                    isSame1 = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            for(let q = 0; q < idx2.length; q ++){\r\n                if(j == idx2[q]){\r\n                    isSame2 = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            //if(isSame1 || isSame2){\r\n            //    continue\r\n            //}\r\n\r\n\r\n            let flagg1 = false\r\n            if(isSame1){\r\n                if(this.tanGraphPoints[startid].type == \"vi\"){\r\n                    for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                        if(this.pointData[j].catArray[cur_idx] == k){\r\n                            flagg1 = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    flagg1 = true\r\n                }\r\n            }\r\n\r\n            if(flagg1){\r\n                continue\r\n            }\r\n\r\n            let flagg2 = false\r\n            if(isSame2){\r\n                if(this.tanGraphPoints[endid].type == \"vi\"){\r\n                    for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                        if(this.pointData[j].catArray[cur_idx] == k){\r\n                            flagg2 = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    flagg2 = true\r\n                }\r\n            }\r\n\r\n            if(flagg2){\r\n                continue\r\n            }\r\n\r\n            // first cal the perpendicular from the point to the edge\r\n            let s_pt = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n            let e_pt = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n            let pt = [this.pointData[j].x, this.pointData[j].y]\r\n            let k1\r\n            let k2\r\n            let pt_o\r\n            let withinFlag = false\r\n            if(Math.abs(s_pt[0] - e_pt[0]) < eps){\r\n                k1 = null\r\n                k2 = 0\r\n                // cal intersection point for two lines\r\n                pt_o = [s_pt[0], pt[1]]\r\n                if(pt[1] >= Math.min(s_pt[1], e_pt[1]) && pt[1] <= Math.max(s_pt[1], e_pt[1])){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n            else if(Math.abs(s_pt[1] - e_pt[1]) < eps){\r\n                k1 = 0\r\n                k2 = null\r\n                // cal intersection point for two lines\r\n                pt_o = [pt[0], s_pt[1]]\r\n                if(pt[0] >= Math.min(s_pt[0], e_pt[0]) && pt[0] <= Math.max(s_pt[0], e_pt[0])){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n            else{\r\n                k1 = (e_pt[1] - s_pt[1]) / (e_pt[0] - s_pt[0])\r\n                k2 = (-1.0) / k1\r\n                // cal intersection point for two lines\r\n                let b1 = s_pt[1] - k1 * s_pt[0]\r\n                let b2 = pt[1] - k2 * pt[0]\r\n                let tmpx = (b1 - b2) / (k2 - k1)\r\n                let tmpy = k1 * tmpx + b1\r\n                pt_o = [tmpx, tmpy]\r\n                let tmpt = (tmpx - s_pt[0]) / (e_pt[0] - s_pt[0])\r\n                if(tmpt >= 0 && tmpt <= 1){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n\r\n            // if the intersection point not in the region of edge then continue\r\n            if(!withinFlag){\r\n                let dis1 = calDistance(pt[0], pt[1], s_pt[0], s_pt[1])\r\n                let dis2 = calDistance(pt[0], pt[1], e_pt[0], e_pt[1])\r\n                if(dis1 < dis2){\r\n                    pt_o = [s_pt[0], s_pt[1]]\r\n                }\r\n                else{\r\n                    pt_o = [e_pt[0], e_pt[1]]\r\n                }\r\n            }\r\n\r\n            // else cal the intersection point of the vertical line and the polygon\r\n            let tmp_poly = []\r\n            for(let p = 0; p < this.elementPoly[j].length; p ++){\r\n                tmp_poly.push([this.elementPoly[j][p].x, this.elementPoly[j][p].y])\r\n            }\r\n            let area_poly = ShapeInfo.polygon(tmp_poly)\r\n            let tmpvv = [pt_o[0] - pt[0], pt_o[1] - pt[1]]\r\n            let pt_oo = [pt[0] + 2 * tmpvv[0], pt[1] + 2 * tmpvv[1]]\r\n            let o_line = ShapeInfo.line(pt, pt_oo)\r\n            let intersections = Intersection.intersect(area_poly, o_line)\r\n            let mindis = Number.MAX_VALUE\r\n            let i_pts = intersections.points\r\n\r\n            //console.log(\"intersection points:\")\r\n            //console.log(i_pts)//\r\n\r\n            let hasIntersect = false\r\n\r\n            for(let p = 0; p < i_pts.length; p ++){\r\n                hasIntersect = true\r\n                let tmpdis = calDistance(pt[0], pt[1], i_pts[p].x, i_pts[p].y)\r\n                mindis = Math.min(mindis, tmpdis)\r\n            }\r\n\r\n            if(!hasIntersect){\r\n                disFlag = false\r\n                break\r\n            }\r\n\r\n            let linedis = calDistance(pt[0], pt[1], pt_o[0], pt_o[1]) - mindis - (EdgeWidth / 2) + 2\r\n\r\n            // finally cal the distance from the intersection point to the edge and judge whether the distance > w/2\r\n            if(linedis <= 0){\r\n                disFlag = false\r\n                break\r\n            }\r\n\r\n        }\r\n\r\n        if(!disFlag){\r\n            return false\r\n        }\r\n        else{\r\n            return true\r\n        }\r\n\r\n\r\n    }\r\n\r\n    moveOutEdge(k, i){\r\n\r\n    }\r\n\r\n    createInitGraph(){\r\n\r\n        // first create (pointData, tanPoints) map\r\n\r\n        for(let k in this.catPointDict){\r\n            //this.catPointMap[k] = {}\r\n            this.catInitEdges[k] = []\r\n        }\r\n\r\n        /*\r\n        for(let i = 0; i < this.tanGraphPoints.length; i ++){\r\n\r\n            let dataidx = this.tanGraphPoints[i].dataindex\r\n            let addidx = []\r\n\r\n            if(this.tanGraphPoints[i].type == \"vi\"){\r\n                addidx = dataidx\r\n            }\r\n            else{\r\n                addidx = [dataidx]\r\n            }\r\n\r\n            if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n                this.tanPointMap[addidx[0]] = i\r\n            }\r\n\r\n            for(let j = 0; j < addidx.length ; j ++){\r\n                let idx = addidx[j]\r\n                for (let c = 0; c < this.pointData[idx].catArray.length; c ++){\r\n                    let nowcat = this.pointData[idx].catArray[c]\r\n                    if(!this.catPointMap[nowcat].hasOwnProperty(idx)){\r\n                        this.catPointMap[nowcat][idx] = []\r\n                    }\r\n                    this.catPointMap[nowcat][idx].push(this.tanGraphPoints[i])\r\n                }\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        //let rG = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length)\r\n\r\n\r\n        //this.calDelauayTriangulation()\r\n\r\n        //console.log(neighbors)\r\n        /*\r\n        // constrain the edges to delauay triangulation and w/2 far away from allocation areas\r\n        for(let i = this.tanGraphEdges.length - 1; i >= 0; i --){\r\n            let e = this.tanGraphEdges[i]\r\n            if(this.calEdgeConstrains(e)){\r\n                //console.log(\"yes\")\r\n                // add edge to the rG\r\n                let startid = e.startid\r\n                let endid = e.endid\r\n                let dis = calDistance(\r\n                    this.tanGraphPoints[startid].x,\r\n                    this.tanGraphPoints[startid].y,\r\n                    this.tanGraphPoints[endid].x,\r\n                    this.tanGraphPoints[endid].y\r\n                )\r\n                let edge_weight = Math.pow(dis + parameter_C, parameter_t)\r\n                rG.addEdge(new jsgraphs.Edge(startid, endid, edge_weight));\r\n                rG.addEdge(new jsgraphs.Edge(endid, startid, edge_weight));\r\n            }\r\n        }\r\n        */\r\n        //console.log(\"rG\")\r\n        //console.log(rG)\r\n        //return\r\n\r\n        //console.log(\"catPointMap!\")\r\n        //console.log(this.catPointMap)\r\n\r\n        // create the edges array for each cat\r\n        for(let k in this.catPointMap){\r\n\r\n            this.rG[k] = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length)\r\n\r\n            for(let i = this.rGEdges[k].length - 1; i >= 0; i --){\r\n                let e = this.rGEdges[k][i]\r\n                if(this.calEdgeConstrains(e, k)){\r\n                    //console.log(\"yes\")\r\n                    // add edge to the rG\r\n                    let startid = e.startid\r\n                    let endid = e.endid\r\n                    let dis = calDistance(\r\n                        this.tanGraphPoints[startid].x,\r\n                        this.tanGraphPoints[startid].y,\r\n                        this.tanGraphPoints[endid].x,\r\n                        this.tanGraphPoints[endid].y\r\n                    )\r\n                    //let edge_weight = Math.pow(dis + parameter_C, parameter_t)\r\n                    let edge_weight = dis\r\n                    //let edge_weight = dis\r\n                    this.rG[k].addEdge(new jsgraphs.Edge(startid, endid, edge_weight));\r\n                    this.rG[k].addEdge(new jsgraphs.Edge(endid, startid, edge_weight));\r\n                }\r\n            }\r\n\r\n\r\n            let node_array = []\r\n\r\n            for(let node in this.catPointMap[k]){\r\n                node_array.push(node)\r\n            }\r\n\r\n            //console.log(\"node_array!!!\")\r\n            //console.log(node_array)\r\n\r\n            console.log(\"info!!\")\r\n            console.log(k)\r\n            console.log(node_array)\r\n\r\n            for(let i = 0; i < node_array.length; i ++){\r\n\r\n                //let nodes1 = this.catPointMap[k][node_array[i]]\r\n                //console.log(\"nodes1!!!\")\r\n                //console.log(nodes1)\r\n\r\n                let nodeid1 = this.tanPointMap[node_array[i]]\r\n                let dijkstra = new jsgraphs.Dijkstra(this.rG[k], nodeid1)\r\n\r\n                for(let j = i + 1; j < node_array.length; j ++){\r\n\r\n                    //if(i == j){\r\n                    //    continue\r\n                    //}\r\n\r\n                    let nodeid2 = this.tanPointMap[node_array[j]]\r\n\r\n                    if(dijkstra.hasPathTo(nodeid2)){\r\n                        let path = dijkstra.pathTo(nodeid2)\r\n                        let tmp_w = 0\r\n                        for(let eid = 0; eid < path.length; eid ++){\r\n                            tmp_w += path[eid].weight\r\n                        }\r\n                        //tmp_w = Math.pow(tmp_w + parameter_C, parameter_t)\r\n                        let tmp_e = {\r\n                            cat:k,\r\n                            start:parseInt(node_array[i]),\r\n                            end:parseInt(node_array[j]),\r\n                            edges:path,\r\n                            weight: Math.pow(tmp_w + parameter_C, parameter_t)\r\n                        }\r\n                        this.catInitEdges[k].push(tmp_e)\r\n                    }\r\n\r\n                    //let nodes2 = this.catPointMap[k][node_array[j]]\r\n                    /*\r\n                    for(let p = 0; p < nodes1.length; p ++){\r\n                        if(this.tanGraphPoints[nodes1[p].id].type != \"datapoint\"){\r\n                            continue\r\n                        }\r\n                        let dijkstra = new jsgraphs.Dijkstra(this.rG[k], nodes1[p].id);\r\n                        for(let q = 0; q < nodes2.length; q ++){\r\n                            if(this.tanGraphPoints[nodes2[q].id].type != \"datapoint\"){\r\n                                continue\r\n                            }\r\n                            if(dijkstra.hasPathTo(nodes2[q].id)){\r\n                                let path = dijkstra.pathTo(nodes2[q].id)\r\n                                let tmp_w = 0\r\n                                for(let eid = 0; eid < path.length; eid ++){\r\n                                    tmp_w += path[eid].weight\r\n                                }\r\n                                //tmp_w = Math.pow(tmp_w + parameter_C, parameter_t)\r\n                                let tmp_e = {\r\n                                    cat:k,\r\n                                    start:parseInt(node_array[i]),\r\n                                    end:parseInt(node_array[j]),\r\n                                    edges:path,\r\n                                    weight:tmp_w\r\n                                }\r\n                                this.catInitEdges[k].push(tmp_e)\r\n                            }\r\n                        }\r\n\r\n                     */\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n        /*\r\n        // add cat attribute for tan points\r\n        for(let i = 0; i < this.tanGraphPoints.length ; i ++){\r\n            let dataindex = this.tanGraphPoints[i].dataindex\r\n            if(this.tanGraphPoints[i].type == \"vi\"){\r\n                if(this.pointData[dataindex[0]].cat != this.pointData[dataindex[1]].cat){\r\n                    this.tanGraphPoints[i].cat = [this.pointData[dataindex[0]].cat, this.pointData[dataindex[1]].cat]\r\n                }\r\n                else{\r\n                    this.tanGraphPoints[i].cat = [this.pointData[dataindex[0]].cat]\r\n                }\r\n            }\r\n            else{\r\n                this.tanGraphPoints[i].cat = [this.pointData[dataindex].cat]\r\n            }\r\n        }\r\n\r\n\r\n        // split tan edges by cat\r\n        let edgeDict = {}\r\n\r\n        for(let i = 0; i < this.tanGraphEdges.length; i ++){\r\n            let startid = this.tanGraphEdges[i].startid\r\n            let endid = this.tanGraphEdges[i].endid\r\n            let cat1 = this.tanGraphPoints[startid].cat\r\n            let cat2 = this.tanGraphPoints[endid].cat\r\n            let dis = calDistance(\r\n                this.tanGraphPoints[startid].x,\r\n                this.tanGraphPoints[startid].y,\r\n                this.tanGraphPoints[endid].x,\r\n                this.tanGraphPoints[endid].y\r\n            )\r\n            this.tanGraphEdges[i].weight = Math.pow(dis + parameter_C, parameter_t)\r\n            let flag = false\r\n            let catidx = {}\r\n            for(let j = 0; j < cat1.length; j ++){\r\n                let idx1 = cat1[j]\r\n                for(let k = 0; k < cat2.length; k ++){\r\n                    if(idx1 == cat2[k]){\r\n                        flag = true\r\n                        catidx[idx1] = 1\r\n                    }\r\n                }\r\n            }\r\n            if(flag){\r\n                for(let key_cat in catidx){\r\n                    if(!edgeDict.hasOwnProperty(key_cat)){\r\n                        edgeDict[key_cat] = []\r\n                    }\r\n                    edgeDict[key_cat].push(this.tanGraphEdges[i])\r\n                }\r\n            }\r\n        }\r\n\r\n        //console.log(\"createInitGraph\")\r\n        //console.log(this.catPointDict)\r\n\r\n\r\n        //this.initGraph[k] = new jsgraphs.WeightedDiGraph(points.length)\r\n\r\n\r\n        // cal delauay triangulation\r\n        let tmp_pts = []\r\n        let points = this.pointData\r\n        for(let i = 0; i < points.length; i ++){\r\n            tmp_pts.push([points[i].x, points[i].y])\r\n        }\r\n        let triangles = triangulate(tmp_pts)\r\n        let neighbors = {}\r\n        // construct dict for delauay triangulation neighbors\r\n        for(let i = 0; i < triangles.length; i ++){\r\n\r\n            let p1 = triangles[i][0]\r\n            let p2 = triangles[i][1]\r\n            let p3 = triangles[i][2]\r\n\r\n            let tmp_poly = []\r\n            tmp_poly.push([this.pointData[p1].x, this.pointData[p1].y])\r\n            tmp_poly.push([this.pointData[p2].x, this.pointData[p2].y])\r\n            tmp_poly.push([this.pointData[p3].x, this.pointData[p3].y])\r\n            drawPolygon(tmp_poly, 0, 0, \"red\")\r\n\r\n            //p1 = this.catPointDict[k][p1].id\r\n            //p2 = this.catPointDict[k][p2].id\r\n            //p3 = this.catPointDict[k][p3].id\r\n\r\n\r\n            if(!neighbors.hasOwnProperty(p1)){\r\n                neighbors[p1] = {}\r\n                neighbors[p1][p2] = 1\r\n                neighbors[p1][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p2)){\r\n                neighbors[p2] = {}\r\n                neighbors[p2][p1] = 1\r\n                neighbors[p2][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p3)){\r\n                neighbors[p3] = {}\r\n                neighbors[p3][p1] = 1\r\n                neighbors[p3][p2] = 1\r\n            }\r\n        }\r\n\r\n\r\n        for(var k in this.catPointDict){\r\n            //let points = this.catPointDict[k]\r\n\r\n            for(let i = 0; i < edgeDict[k].length; i ++){\r\n\r\n                let startid = edgeDict[k][i].startid\r\n                let endid = edgeDict[k][i].endid\r\n\r\n                // judge whether the endpoints are neighbors\r\n                let dataindex1 = this.tanGraphPoints[startid].dataindex\r\n                let dataindex2 = this.tanGraphPoints[endid].dataindex\r\n\r\n                let idx1, idx2\r\n\r\n                if(this.tanGraphPoints[startid].type != \"vi\"){\r\n                    idx1 = [dataindex1]\r\n                }\r\n                else{\r\n                    idx1 = dataindex1\r\n                }\r\n\r\n                if(this.tanGraphPoints[endid].type != \"vi\"){\r\n                    idx2 = [dataindex2]\r\n                }\r\n                else{\r\n                    idx2 = dataindex2\r\n                }\r\n\r\n                let neighborFlag = false\r\n                for(let p = 0; p < idx1.length; p ++){\r\n                    let pt1 = idx1[p]\r\n                    for(let q = 0; q < idx2.length; q ++){\r\n                        let pt2 = idx2[q]\r\n                        if(neighbors.hasOwnProperty(pt1)){\r\n                            if(neighbors[pt1].hasOwnProperty(pt2)){\r\n                                neighborFlag = true\r\n                                break\r\n                            }\r\n                        }\r\n                        if(neighbors.hasOwnProperty(pt2)){\r\n                            if(neighbors[pt2].hasOwnProperty(pt1)){\r\n                                neighborFlag = true\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(!neighborFlag){\r\n                    continue\r\n                }\r\n\r\n                let disFlag = true\r\n\r\n                // judge whether the edge is w/2 away from any allocation areas except for the endpoints\r\n                for(let j = 0; j < this.elementPoly.length; j ++){\r\n\r\n                    let isSame = false\r\n\r\n                    for(let p = 0; p < idx1.length; p ++){\r\n                        if(j == idx1[p]){\r\n                            isSame = true\r\n                            break\r\n                        }\r\n                    }\r\n                    for(let q = 0; q < idx2.length; q ++){\r\n                        if(j == idx2[q]){\r\n                            isSame = true\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    if(isSame){\r\n                        continue\r\n                    }\r\n\r\n                    // first cal the perpendicular from the point to the edge\r\n                    let s_pt = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                    let e_pt = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                    let pt = [this.pointData[j].x, this.pointData[j].y]\r\n                    let k1\r\n                    let k2\r\n                    let pt_o\r\n                    let withinFlag = false\r\n                    if(Math.abs(s_pt[0] - e_pt[0]) < eps){\r\n                        k1 = null\r\n                        k2 = 0\r\n                        // cal intersection point for two lines\r\n                        pt_o = [s_pt[0], pt[1]]\r\n                        if(pt[1] >= Math.min(s_pt[1], e_pt[1]) && pt[1] <= Math.max(s_pt[1], e_pt[1])){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n                    else if(Math.abs(s_pt[1] - e_pt[1]) < eps){\r\n                        k1 = 0\r\n                        k2 = null\r\n                        // cal intersection point for two lines\r\n                        pt_o = [pt[0], s_pt[1]]\r\n                        if(pt[0] >= Math.min(s_pt[0], e_pt[0]) && pt[0] <= Math.max(s_pt[0], e_pt[0])){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n                    else{\r\n                        k1 = (e_pt[1] - s_pt[1]) / (e_pt[0] - s_pt[0])\r\n                        k2 = (-1.0) / k1\r\n                        // cal intersection point for two lines\r\n                        let b1 = s_pt[1] - k1 * s_pt[0]\r\n                        let b2 = pt[1] - k2 * pt[0]\r\n                        let tmpx = (b1 - b2) / (k2 - k1)\r\n                        let tmpy = k1 * tmpx + b1\r\n                        pt_o = [tmpx, tmpy]\r\n                        let tmpt = (tmpx - s_pt[0]) / (e_pt[0] - s_pt[0])\r\n                        if(tmpt >= 0 && tmpt <= 1){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n\r\n                    // if the intersection point not in the region of edge then continue\r\n                    if(!withinFlag){\r\n                        continue\r\n                    }\r\n\r\n                    // else cal the intersection point of the vertical line and the polygon\r\n                    let tmp_poly = []\r\n                    for(let p = 0; p < this.elementPoly[j].length; p ++){\r\n                        tmp_poly.push([this.elementPoly[j][p].x, this.elementPoly[j][p].y])\r\n                    }\r\n                    let area_poly = ShapeInfo.polygon(tmp_poly)\r\n                    let o_line = ShapeInfo.line(pt, pt_o)\r\n                    let intersections = Intersection.intersect(area_poly, o_line);\r\n                    let mindis = Number.MAX_VALUE\r\n                    let i_pts = intersections.points\r\n\r\n                    //console.log(\"intersection points:\")\r\n                    //console.log(i_pts)//\r\n\r\n                    for(let p = 0; p < i_pts.length; p ++){\r\n                        let tmpdis = calDistance(pt_o[0], pt_o[1], i_pts[p].x, i_pts[p].y)\r\n                        mindis = Math.min(mindis, tmpdis)\r\n                    }\r\n\r\n                    // finally cal the distance from the intersection point to the edge and judge whether the distance > w/2\r\n                    if(mindis < EdgeWidth/2){\r\n                        disFlag = false\r\n                        break\r\n                    }\r\n\r\n                }\r\n\r\n                if(!disFlag){\r\n                    //continue\r\n                }\r\n\r\n                // add the edge to the reachability graph\r\n                if(!this.initEdges.hasOwnProperty(k)){\r\n                    this.initEdges[k] = []\r\n                }\r\n\r\n                this.initEdges[k].push(edgeDict[k][i])\r\n\r\n                let start_points = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                let end_points = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                //drawLine(start_points, end_points, \"black\", 2)\r\n\r\n            }\r\n\r\n        }\r\n\r\n        console.log(this.initEdges)\r\n\r\n         */\r\n\r\n    // create SPG according to the Algorithm 2\r\n    createSPG(){\r\n\r\n\r\n\r\n        /*\r\n        for(let k in this.catInitEdges){\r\n            this.catInitEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n            let edges = this.catInitEdges[k]\r\n            for(let i = 0; i < edges.length; i ++){\r\n                console.log(\"draw\")\r\n                let st = edges[i].start\r\n                let en = edges[i].end\r\n                let w = edges[i].weight\r\n                let edge_path = edges[i].edges\r\n                let tmp_color = colors[parseInt(edges[i].cat)]\r\n                for(let p = 0; p < edge_path.length; p ++){\r\n                    let u = edge_path[p].from()\r\n                    let v = edge_path[p].to()\r\n                    let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                    let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n                if(edge_path.length == 0){\r\n                    let start_points = [this.tanGraphPoints[st].x, this.tanGraphPoints[st].y]\r\n                    let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n                else{\r\n                    let start_points = [this.tanGraphPoints[edge_path[edge_path.length - 1].to()].x, this.tanGraphPoints[edge_path[edge_path.length - 1].to()].y]\r\n                    let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        console.log(\"catInitEdges!!!\")\r\n        console.log(this.catInitEdges)\r\n\r\n\r\n        for(let k in this.catInitEdges){\r\n            this.catInitEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n            let edges = this.catInitEdges[k]\r\n            this.SPG[k] = new jsgraphs.WeightedDiGraph(this.pointData.length)\r\n            for(let i = 0; i < edges.length; i ++){\r\n                let st = edges[i].start\r\n                let en = edges[i].end\r\n                let w = edges[i].weight\r\n                let e = new jsgraphs.Edge(st, en, w)\r\n                e.label = i\r\n                e.flag = false\r\n                let e1 = new jsgraphs.Edge(en, st, w)\r\n                e1.label = i\r\n                e1.flag = true\r\n                let dijkstra = new jsgraphs.Dijkstra(this.SPG[k], st)\r\n                let drawFlag = false\r\n                if(dijkstra.hasPathTo(en)){\r\n                    let path = dijkstra.pathTo(en)\r\n                    let path_weight = 0\r\n                    for(let p = 0; p < path.length; p ++){\r\n                        path_weight += path[p].weight\r\n                    }\r\n                    if(path_weight >= w){\r\n                        //console.log(\"(\" + path_weight + \", \" + w + \")\")\r\n                        drawFlag = true\r\n                        this.SPG[k].addEdge(e)\r\n                        this.SPG[k].addEdge(e1)\r\n                    }\r\n                }\r\n                else{\r\n                    drawFlag = true\r\n                    this.SPG[k].addEdge(e)\r\n                    this.SPG[k].addEdge(e1)\r\n                }\r\n\r\n                if(drawFlag){\r\n                    if(!this.SPGEdges.hasOwnProperty(k)){\r\n                        this.SPGEdges[k] = []\r\n                    }\r\n                    this.SPGEdges[k].push(i)\r\n                    this.drawEdgePath(k, i, colors[parseInt(k)], 1)\r\n                    //console.log(edges[i])\r\n                    /*\r\n                    let edge_path = edges[i].edges\r\n                    let tmp_color = colors[parseInt(edges[i].cat)]\r\n                    for(let p = 0; p < edge_path.length; p ++){\r\n                        let u = edge_path[p].from()\r\n                        let v = edge_path[p].to()\r\n                        let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                        let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n                    if(edge_path.length == 0){\r\n                        let start_points = [this.tanGraphPoints[st].x, this.tanGraphPoints[st].y]\r\n                        let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n                    else{\r\n                        let start_points = [this.tanGraphPoints[edge_path[edge_path.length - 1].to()].x, this.tanGraphPoints[edge_path[edge_path.length - 1].to()].y]\r\n                        let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n\r\n                     */\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /*\r\n        //console.log(this.pointData)\r\n        for(var k in this.initEdges){\r\n\r\n            // increasing order\r\n            this.initEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n\r\n            //console.log(this.initEdges[k])\r\n            this.SPG[k] = new jsgraphs.WeightedDiGraph(this.pointData.length)\r\n            this.SPGEdges[k] = []\r\n\r\n            for(let i = 0; i < this.initEdges[k].length; i ++){\r\n                let startid = this.initEdges[k][i].startid\r\n                let endid = this.initEdges[k][i].endid\r\n                let weight = this.initEdges[k][i].weight\r\n                let s_ptid\r\n                let e_ptid\r\n\r\n                if(this.tanGraphPoints[startid].type == \"vi\"){\r\n                    s_ptid = this.tanGraphPoints[startid].dataindex\r\n                }else{\r\n                    s_ptid = [this.tanGraphPoints[startid].dataindex]\r\n                }\r\n\r\n                if(this.tanGraphPoints[endid].type == \"vi\"){\r\n                    e_ptid = this.tanGraphPoints[endid].dataindex\r\n                }else{\r\n                    e_ptid = [this.tanGraphPoints[endid].dataindex]\r\n                }\r\n\r\n                for(let j = s_ptid.length - 1; j >= 0; j --){\r\n                    if(this.pointData[s_ptid[j]].cat != k){\r\n                        s_ptid.splice(j, 1)\r\n                    }\r\n                }\r\n\r\n                for(let j = e_ptid.length - 1; j >= 0; j --){\r\n                    if(this.pointData[e_ptid[j]].cat != k){\r\n                        e_ptid.splice(j, 1)\r\n                    }\r\n                }\r\n\r\n                if(s_ptid.length == 0 || e_ptid.length == 0){\r\n                    continue\r\n                }\r\n\r\n                for(let j = 0 ; j < s_ptid.length ; j ++){\r\n\r\n                    let startidx = s_ptid[j]\r\n                    var dijkstra = new jsgraphs.Dijkstra(this.SPG[k], startidx);\r\n                    let hasLink = false\r\n                    let adjLink = false\r\n                    //let pathWeight = Number.MAX_VALUE\r\n\r\n                    for(let p = 0; p < e_ptid.length; p ++){\r\n\r\n                        let endidx = e_ptid[p]\r\n                        let adjList = this.SPG[k].adjList\r\n\r\n                        //for(let q = 0; q < adjList[startidx].length; q ++){\r\n                        //    let e = adjList[startidx][q]\r\n                        //    if(e.w == endidx){\r\n                        //        adjLink = true\r\n                        //    }\r\n                        //}\r\n//\r\n                        //if(adjLink){\r\n                        //    continue\r\n                        //}\r\n\r\n                        let tmp_w = 0\r\n                        if(dijkstra.hasPathTo(endidx)){\r\n                            hasLink = true\r\n                            let path = dijkstra.pathTo(e_ptid[p])\r\n                            for(let q = 0; q < path.length; q ++){\r\n                                let e = path[q]\r\n                                tmp_w += e.weight\r\n                            }\r\n                        }\r\n\r\n                        if((!hasLink) || (hasLink && tmp_w >= weight)){\r\n                            // add edge to SPG\r\n                            this.SPG[k].addEdge(new jsgraphs.Edge(startidx, endidx, weight))\r\n                            this.SPG[k].addEdge(new jsgraphs.Edge(endidx, startidx, weight))\r\n                            this.SPGEdges[k].push(this.initEdges[k][i])\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n        //console.log(this.SPG)\r\n        //console.log(this.SPGEdges)\r\n\r\n        for(var k in this.SPGEdges){\r\n            for(let i = 0; i < this.SPGEdges[k].length; i ++){\r\n                let startid = this.SPGEdges[k][i].startid\r\n                let endid = this.SPGEdges[k][i].endid\r\n                let start_points = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                let end_points = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                drawLine(start_points, end_points, \"black\", 3)\r\n            }\r\n        }\r\n\r\n         */\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calCrossEdges(){\r\n        console.log(this.SPGEdges)\r\n        var Edge_Array = {}\r\n        for(let k in this.SPGEdges){\r\n            Edge_Array[k] = []\r\n            for(let i = 0; i < this.SPGEdges[k].length; i ++){\r\n                let idx = this.SPGEdges[k][i]\r\n                let edge_path = this.catInitEdges[k][idx].edges\r\n                let tmp_e = []\r\n                for(let p = 0; p < edge_path.length; p ++){\r\n                    let tmp_line = {}\r\n                    let u = edge_path[p].v\r\n                    let v = edge_path[p].w\r\n                    tmp_line.start = {x: this.tanGraphPoints[u].x,\r\n                                      y:this.tanGraphPoints[u].y}\r\n                    tmp_line.end = {x:this.tanGraphPoints[v].x,\r\n                                    y:this.tanGraphPoints[v].y}\r\n                    tmp_e.push(tmp_line)\r\n                }\r\n                Edge_Array[k].push(tmp_e)\r\n            }\r\n        }\r\n\r\n        let crossnum = 0\r\n        for(let k1 in Edge_Array){\r\n\r\n            for(let i = 0; i < Edge_Array[k1].length; i ++){\r\n                let e1 = Edge_Array[k1][i]\r\n                for(let k2 in Edge_Array){\r\n                    if(k1 == k2){\r\n                        continue\r\n                    }\r\n                    for(let j = 0; j < Edge_Array[k2].length; j ++){\r\n                        let e2 = Edge_Array[k2][j]\r\n                        let flag = false\r\n                        for(let p = 0; p < e1.length; p ++){\r\n                            let eS1 = e1[p].start\r\n                            let eE1 = e1[p].end\r\n                            for(let q = 0; q < e2.length; q ++){\r\n                                let eS2 = e2[q].start\r\n                                let eE2 = e2[q].end\r\n                                if(this.checkEdgeCrossing(eS1, eE1, eS2, eE2)){\r\n                                    crossnum ++\r\n                                    flag = true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(flag){\r\n\r\n                                for(let q = 0; q < e2.length; q ++){\r\n                                    let eS2 = e2[q].start\r\n                                    let eE2 = e2[q].end\r\n                                    let startpoints = [eS2.x, eS2.y]\r\n                                    let endpoints = [eE2.x, eE2.y]\r\n                                    drawLine(startpoints, endpoints, \"red\", 2)\r\n                                }\r\n\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        crossnum /= 2\r\n\r\n        console.log(\"Points Num : \")\r\n        console.log(this.pointData.length)\r\n        console.log(\"Cross Num : \")\r\n        console.log(crossnum)\r\n\r\n    }\r\n\r\n    //Phase 2 : Fillable faces\r\n    // find all faces in SPG\r\n\r\n    drawEdgePath(k, i, color, width){\r\n        let edge_path = this.catInitEdges[k][i].edges\r\n        for(let p = 0; p < edge_path.length; p ++){\r\n            let u = edge_path[p].v\r\n            let v = edge_path[p].w\r\n            let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n            let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n            drawLine(start_points, end_points, color, width)\r\n        }\r\n    }\r\n\r\n    judgeClockWise(pointIdx){\r\n\r\n        //counterclockwise return true\r\n        //clockwise return false\r\n        let p1 = [this.pointData[pointIdx[0]].x, this.pointData[pointIdx[0]].y]\r\n        let p2 = [this.pointData[pointIdx[1]].x, this.pointData[pointIdx[1]].y]\r\n        let p3 = [this.pointData[pointIdx[2]].x, this.pointData[pointIdx[2]].y]\r\n        let res = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\r\n        if(res > 0){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n    }\r\n\r\n    dfs(s, k){\r\n        this.visited[s] = 1\r\n        for(let i = 0; i < this.SPG[k].adjList[s].length; i ++){\r\n            let e = this.SPG[k].adjList[s][i]\r\n            let to = e.w\r\n            if(this.visited[to] == 0){\r\n                this.fa[to] = s\r\n                this.dfs(to, k)\r\n            }\r\n            else if(this.visited[to] == 1 && to != this.fa[s]){\r\n                let tmp = s\r\n                let tmp_circle = []\r\n                tmp_circle.push(to)\r\n                while(tmp != to){\r\n                    tmp_circle.push(tmp)\r\n                    tmp = this.fa[tmp]\r\n                }\r\n                //tmp_circle.push(tmp)\r\n                if(tmp_circle.length < 3){\r\n                    continue\r\n                }\r\n                if(!this.circles.hasOwnProperty(k)){\r\n                    this.circles[k] = []\r\n                }\r\n                if(!this.judgeClockWise(tmp_circle)){\r\n                    tmp_circle.reverse()\r\n                }\r\n                this.circles[k].push(tmp_circle)\r\n                this.circles[k][this.circles[k].length - 1].delflag = false\r\n            }\r\n        }\r\n        this.visited[s] = 2\r\n    }\r\n\r\n    findAllCircles(){\r\n\r\n        console.log(\"SPG\")\r\n        console.log(this.SPG)\r\n\r\n        for(let k in this.SPG){\r\n            for(let i = 0; i < this.SPG[k].V; i ++){\r\n                this.visited = []\r\n                this.fa = []\r\n                this.visited = new Array(this.SPG[k].V).fill(0)\r\n                this.fa = new Array(this.SPG[k].V).fill(-1)\r\n                this.dfs(i, k)\r\n            }\r\n        }\r\n\r\n        //console.log(this.circles)\r\n\r\n        //for(let i = 0; i < this.circles.length; i ++){\r\n        //    for(let j = 0; j < this.circles[i].length ; j ++){\r\n        //        let id1 = this.circles[i][j]\r\n        //        let id2 = this.circles[i][(j + 1) % this.circles[i].length]\r\n        //        let startpoint = [this.pointData[id1].x, this.pointData[id1].y]\r\n        //        let endpoint = [this.pointData[id2].x, this.pointData[id2].y]\r\n        //        drawLine(startpoint, endpoint, \"red\", 3)\r\n        //    }\r\n        //}\r\n\r\n    }\r\n\r\n    // remove same faces\r\n    findPolygons(){\r\n\r\n        this.polygons = {}\r\n\r\n\r\n        // remove same faces\r\n        for(let k in this.circles){\r\n\r\n            for(let i = 0; i < this.circles[k].length; i ++){\r\n\r\n                if(this.circles[k][i].delflag){\r\n                    continue\r\n                }\r\n\r\n                let head1 = this.circles[k][i][0]\r\n                let len1 = this.circles[k][i].length\r\n\r\n                for(let j = i + 1; j < this.circles[k].length; j ++){\r\n                    let len2 = this.circles[k][j].length\r\n                    let idx2 = -1\r\n                    if(len1 != len2){\r\n                        continue\r\n                    }\r\n                    for(let p = 0; p < len2; p ++){\r\n                        if(this.circles[k][j][p] == head1){\r\n                            idx2 = p\r\n                        }\r\n                    }\r\n                    if(idx2 == -1){\r\n                        continue\r\n                    }\r\n\r\n                    let sameflag = true\r\n\r\n                    for(let cnt = 0; cnt < len2; cnt ++){\r\n                        let id1 = cnt\r\n                        let id2 = (idx2 + cnt) % len2\r\n                        if(this.circles[k][i][id1] != this.circles[k][j][id2]){\r\n                            sameflag = false\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    if(sameflag){\r\n                        this.circles[k][j].delflag = true\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            for(let i = 0; i < this.circles[k].length; i ++){\r\n\r\n                if(this.circles[k][i].delflag){\r\n                    continue\r\n                }\r\n\r\n                if(!this.polygons.hasOwnProperty(k)){\r\n                    this.polygons[k] = []\r\n                }\r\n\r\n                this.polygons[k].push(this.circles[k][i])\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        //for(let k in this.catPointDict){\r\n        //    this.polygons[k] = []\r\n        //}\r\n        //this.polygons[\"0\"].push([12,10,9])\r\n        //this.polygons[\"0\"].push([26,27,28,32,33])\r\n        //this.polygons[\"0\"].push([29,31,30])\r\n//\r\n        //this.polygons[\"1\"].push([38,41,42,36])\r\n//\r\n        //this.polygons[\"2\"].push([59,61,60])\r\n        //this.polygons[\"2\"].push([66,68,69])\r\n        //this.polygons[\"2\"].push([90,64,65,73])\r\n//\r\n        //for(let k in this.polygons){\r\n        //    for(let i = 0; i < this.polygons[k].length; i ++){\r\n        //        this.polygons[k][i].fillFlag = true\r\n        //    }\r\n        //}\r\n\r\n        //console.log(\"circles\")\r\n        //console.log(this.circles)\r\n        //console.log(\"polygons\")\r\n        //console.log(this.polygons)\r\n\r\n        /*\r\n        for(let k in this.polygons){\r\n            for(let i = 0; i < this.polygons[k].length; i ++){\r\n                for(let j = 0; j < this.polygons[k][i].length; j ++){\r\n                    //console.log(this.polygons[k][i][j])\r\n                    let id1 = this.polygons[k][i][j]\r\n                    let id2 = this.polygons[k][i][(j + 1) % this.polygons[k][i].length]\r\n                    let adjList = this.SPG[k].adjList\r\n                    for(let p = 0; p < adjList[id1].length; p ++){\r\n                        let e = adjList[id1][p]\r\n                        if(e.w == id2){\r\n                            //this.drawEdgePath(k, e.label, \"red\", 3)\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    //console.log(\"(\" + id1 + \", \" + id2 + \")\")\r\n                    //let startpoint = [this.pointData[id1].x, this.pointData[id1].y]\r\n                    //let endpoint = [this.pointData[id2].x, this.pointData[id2].y]\r\n                    //drawLine(startpoint, endpoint, \"red\", 3)\r\n                }\r\n            }\r\n        }\r\n        */\r\n    }\r\n\r\n    // judge whether a given face can be filled\r\n    judgePolygons(){\r\n\r\n        for(let k in this.polygons){\r\n            for(let i = 0; i < this.polygons[k].length; i ++){\r\n                // cal nodes_f\r\n                this.polygons[k][i].nodes_f = this.polygons[k][i].length\r\n                // cal area\r\n                let p_pts = []\r\n                for(let j = 0; j < this.polygons[k][i].length; j ++){\r\n\r\n                    let id1 = this.polygons[k][i][j]\r\n                    let id2 = this.polygons[k][i][(j + 1) % this.polygons[k][i].length]\r\n\r\n                    let adjList = this.SPG[k].adjList\r\n\r\n                    for(let pp = 0; pp < adjList[id1].length; pp ++){\r\n                        let e = adjList[id1][pp]\r\n                        if(e.w == id2){\r\n                            let edge_path = this.catInitEdges[k][e.label].edges\r\n                            let tmp_pts = []\r\n                            for(let ppp = 0; ppp < edge_path.length; ppp ++){\r\n                                let u = edge_path[ppp].v\r\n                                let v = edge_path[ppp].w\r\n                                tmp_pts.push([this.tanGraphPoints[u].x, this.tanGraphPoints[u].y])\r\n                                tmp_pts.push([this.tanGraphPoints[v].x, this.tanGraphPoints[v].y])\r\n                            }\r\n                            if(e.flag){\r\n                                for(let tid = tmp_pts.length - 1; tid >= 0; tid --){\r\n                                    p_pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                }\r\n                            }\r\n                            else{\r\n                                for(let tid = 0; tid < tmp_pts.length; tid ++){\r\n                                    p_pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                }\r\n                            }\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                }\r\n                //console.log(\"p_pts!\")\r\n                //console.log(p_pts)\r\n                this.polygons[k][i].area_f = Math.abs(AreaCal(p_pts))\r\n                this.polygons[k][i].fillFlag = false\r\n                this.polygons[k][i].PolygonInfo = ShapeInfo.polygon(p_pts)\r\n            }\r\n        }\r\n        let Set_Order = []\r\n        for(let k in this.catPointDict){\r\n            let tmp = {}\r\n            tmp.num = this.catPointDict[k].length\r\n            tmp.cat = k\r\n            Set_Order.push(tmp)\r\n        }\r\n        Set_Order.sort(function (a, b){\r\n            return a.num - b.num\r\n        })\r\n        for(let i = Set_Order.length - 1; i >= 0; i --){\r\n            let k = Set_Order[i].cat\r\n            if(!this.polygons.hasOwnProperty(k)){\r\n                continue\r\n            }\r\n            let outer_set = {}\r\n            for(let N = 0; N < this.pointData.length; N ++){\r\n                outer_set[N] = 1\r\n            }\r\n            for(let M = 0; M < this.catPointDict[k].length; M ++){\r\n                let cur_id = this.catPointDict[k][M].id\r\n                if(outer_set.hasOwnProperty(cur_id)){\r\n                    delete outer_set[cur_id]\r\n                }\r\n            }\r\n            for(let p = 0; p < this.polygons[k].length; p ++){\r\n                // Rule 1\r\n                let rule1 = false\r\n                let rule1_res = this.polygons[k][p].area_f / ( 1 + this.polygons[k][p].nodes_f)\r\n                if(rule1_res < parameter_A){\r\n                    rule1 = true\r\n                }\r\n                if(!rule1){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule1!\")\r\n                // Rule 2\r\n                let rule2 = true\r\n                for(let idd in outer_set){\r\n                    let tmp_ppt = [this.pointData[parseInt(idd)].x, this.pointData[parseInt(idd)].y]\r\n                    console.log(\"Polygon Info\")\r\n                    console.log(this.polygons[k][p].PolygonInfo.args[0])\r\n                    if(IntersectionQuery.pointInPolygon(tmp_ppt, this.polygons[k][p].PolygonInfo.args[0])){\r\n                        rule2 = false\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule2){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule2!\")\r\n                // Rule 3\r\n                let rule3 = true\r\n                let cur_polygon = this.polygons[k][p].PolygonInfo\r\n                for(let j = Set_Order.length - 1; j > i; j --){\r\n                    let n_k = Set_Order[j].cat\r\n                    let n_adj = this.SPG[n_k].adjList\r\n                    for(let m = 0; m < n_adj.length; m ++){\r\n                        for(let n = 0; n < n_adj[m].length; n ++){\r\n                            let cur_e = this.catInitEdges[n_k][n_adj[m][n].label].edges\r\n                            for(let a = 0; a < cur_e.length; a ++){\r\n                                let u = cur_e[a].v\r\n                                let v = cur_e[a].w\r\n                                let startpoint = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                                let endpoint = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                                let line = ShapeInfo.line(startpoint, endpoint)\r\n                                let pts = Intersection.intersect(line, cur_polygon)\r\n                                if(pts.points.length > 0){\r\n                                    rule3 = false\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(!rule3){\r\n                                break\r\n                            }\r\n                        }\r\n                        if(!rule3){\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!rule3){\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule3){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule3!\")\r\n                // Rule 4\r\n                let rule4 = true\r\n                for(let j = Set_Order.length - 1; j > i; j --){\r\n                    let n_k = Set_Order[j].cat\r\n                    let set_other = {}\r\n                    for(let pid = 0; pid < this.catPointDict[n_k].length; pid ++){\r\n                        set_other[this.catPointDict[n_k][pid].id] = 1\r\n                    }\r\n                    let n_adj = this.SPG[n_k].adjList\r\n                    for(let q = 0; q < this.polygons[k][p].length; q ++){\r\n                        let id1 = this.polygons[k][p][q]\r\n                        let id2 = this.polygons[k][p][(q + 1) % this.polygons[k][p].length]\r\n                        for(let alen = 0; alen < n_adj[id1].length; alen ++){\r\n                            let e = n_adj[id1][alen]\r\n                            if(e.w == id2){\r\n                                for(let qq = 0; qq < this.polygons[k][p].length; qq ++){\r\n                                    if(!set_other.hasOwnProperty(this.polygons[k][p][qq])){\r\n                                        rule4 = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(!rule4){\r\n                                break\r\n                            }\r\n                        }\r\n                        if(!rule4){\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!rule4){\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule4){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule4!\")\r\n                console.log(\"A\")\r\n                console.log(rule1_res)\r\n                this.polygons[k][p].fillFlag = true\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    // Phase 3 : Visualization\r\n\r\n    drawAreas(k,curdata){\r\n\r\n        d3.select('svg').append(\"path\")\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 1)\r\n            //.attr('fill-rule',\"evenodd\")\r\n\r\n    }\r\n\r\n\r\n    drawKelpFusion(){\r\n\r\n        console.log(\"Polygons!!\")\r\n        console.log(this.polygons)\r\n\r\n        let Set_Order = []\r\n\r\n        for(let k in this.catPointDict){\r\n            let tmp = {}\r\n            tmp.num = this.catPointDict[k].length\r\n            tmp.cat = k\r\n            Set_Order.push(tmp)\r\n        }\r\n\r\n        Set_Order.sort(function (a, b){\r\n            return a.num - b.num\r\n        })\r\n\r\n        for(let i = Set_Order.length - 1; i >= 0; i --){\r\n\r\n            let cur_k = Set_Order[i].cat\r\n\r\n            // draw points\r\n            for(let j = 0; j < this.catPointDict[cur_k].length; j ++){\r\n                let pointID = this.catPointDict[cur_k][j].id\r\n                let v1 = [this.pointData[pointID].x, this.pointData[pointID].y]\r\n                let tmp_polygon = []\r\n                for(let p = 0; p < this.elementPoly[pointID].length; p ++){\r\n                    //let v2 = [this.elementPoly[pointID][p].x, this.elementPoly[pointID][p].y]\r\n                    //let v = [v2[0] - v1[0], v2[1] - v1[1]]\r\n                    //let len = Math.sqrt(v[0] * v[0] + v[1] * v[1])\r\n                    //let cur_v = [v[0] * (len + EdgeWidth / 2) / len, v[1] * (len + EdgeWidth / 2) / len]\r\n                    //tmp_polygon.push([v1[0] + cur_v[0], v1[1] + cur_v[1]])\r\n                    tmp_polygon.push([this.elementPoly[pointID][p].x, this.elementPoly[pointID][p].y])\r\n                }\r\n                this.drawAreas(cur_k, lineFunction(tmp_polygon))\r\n            }\r\n\r\n            // draw edges\r\n\r\n            if(this.SPGEdges.hasOwnProperty(cur_k)){\r\n                if(this.SPGEdges[cur_k].hasOwnProperty(\"length\")){\r\n                    for(let j = 0; j < this.SPGEdges[cur_k].length; j ++){\r\n                        let idx = this.SPGEdges[cur_k][j]\r\n                        let e = this.catInitEdges[cur_k][idx].edges\r\n                        let pts = []\r\n                        let pt1 = []\r\n                        let pt2 = []\r\n                        for(let p = 0; p < e.length; p ++){\r\n                            if(this.tanGraphPoints[e[p].v].type == \"addpoint\" || this.tanGraphPoints[e[p].w].type == \"addpoint\"){\r\n                                //continue\r\n                            }\r\n                            let vidx = e[p].v\r\n                            let widx = e[p].w\r\n\r\n                            let dataindex1 = -1\r\n                            let dataindex2 = -1\r\n                            let st, en\r\n\r\n                            if(this.tanGraphPoints[vidx].type != \"vi\" && this.tanGraphPoints[vidx].type != \"datapoint\"){\r\n                                dataindex1 = this.tanGraphPoints[vidx].dataindex\r\n                            }\r\n\r\n                            if(dataindex1 == -1){\r\n                                st = [this.tanGraphPoints[vidx].x, this.tanGraphPoints[vidx].y]\r\n                            }\r\n                            else{\r\n                                let catArray = this.pointData[dataindex1].catArray\r\n                                let isSame = false\r\n                                for(let c = 0; c < catArray.length; c ++){\r\n                                    if(catArray[c] == cur_k){\r\n                                        isSame = true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(isSame){\r\n                                    st = [this.tanGraphPoints[vidx].x, this.tanGraphPoints[vidx].y]\r\n                                }\r\n                                else{\r\n                                    let ve = [this.tanGraphPoints[vidx].x - this.pointData[dataindex1].x, this.tanGraphPoints[vidx].y - this.pointData[dataindex1].y]\r\n                                    let nlen = Math.sqrt(ve[0] * ve[0] + ve[1] * ve[1])\r\n                                    st = [this.tanGraphPoints[vidx].x + ve[0] * EdgeWidth / (2 * nlen), this.tanGraphPoints[vidx].y + ve[1] * EdgeWidth / (2 * nlen)]\r\n                                }\r\n                            }\r\n\r\n                            if(this.tanGraphPoints[widx].type != \"vi\" && this.tanGraphPoints[widx].type != \"datapoint\"){\r\n                                dataindex2 = this.tanGraphPoints[widx].dataindex\r\n                            }\r\n\r\n                            if(dataindex2 == -1){\r\n                                en = [this.tanGraphPoints[widx].x, this.tanGraphPoints[widx].y]\r\n                            }\r\n                            else{\r\n                                let catArray = this.pointData[dataindex2].catArray\r\n                                let isSame = false\r\n                                for(let c = 0; c < catArray.length; c ++){\r\n                                    if(catArray[c] == cur_k){\r\n                                        isSame = true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(isSame){\r\n                                    en = [this.tanGraphPoints[widx].x, this.tanGraphPoints[widx].y]\r\n                                }\r\n                                else{\r\n                                    let ve = [this.tanGraphPoints[widx].x - this.pointData[dataindex2].x, this.tanGraphPoints[widx].y - this.pointData[dataindex2].y]\r\n                                    let nlen = Math.sqrt(ve[0] * ve[0] + ve[1] * ve[1])\r\n                                    en = [this.tanGraphPoints[widx].x + ve[0] * EdgeWidth / (2 * nlen), this.tanGraphPoints[widx].y + ve[1] * EdgeWidth / (2 * nlen)]\r\n                                }\r\n                            }\r\n\r\n                            //drawLine(st, en, colors[cur_k], EdgeWidth)\r\n\r\n                            let v1 = [en[0] - st[0], en[1] - st[1]]\r\n                            let v2 = [(-1.0) * v1[1], v1[0]]\r\n                            let normlen = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1])\r\n                            v2 = [v2[0] / normlen, v2[1] / normlen]\r\n                            // Counterclockwise\r\n                            pt1.push([st[0] + v2[0] * EdgeWidth / 2 , st[1] + v2[1] * EdgeWidth / 2])\r\n                            pt1.push([en[0] + v2[0] * EdgeWidth / 2 , en[1] + v2[1] * EdgeWidth / 2])\r\n                            // Clockwise\r\n                            pt2.push([st[0] - v2[0] * EdgeWidth / 2 , st[1] - v2[1] * EdgeWidth / 2])\r\n                            pt2.push([en[0] - v2[0] * EdgeWidth / 2 , en[1] - v2[1] * EdgeWidth / 2])\r\n                        }\r\n                        for(let p = 0; p < pt1.length; p ++){\r\n                            if(!Object.is(pt1[p][0], NaN) && !Object.is(pt1[p][0], NaN)){\r\n                                //drawCircle(pt1[p][0], pt1[p][1], 2, 'red', 1)\r\n                                pts.push([pt1[p][0], pt1[p][1]])\r\n                            }\r\n                        }\r\n                        for(let p = pt2.length - 1; p >= 0; p --){\r\n                            if(!Object.is(pt2[p][0], NaN) && !Object.is(pt2[p][0], NaN)){\r\n                                //drawCircle(pt2[p][0], pt2[p][1], 2, 'red', 1)\r\n                                pts.push([pt2[p][0], pt2[p][1]])\r\n                            }\r\n                        }\r\n                        //console.log(\"pts!\")\r\n                        //console.log(pts)\r\n                        this.drawAreas(cur_k, lineFunction(pts))\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n\r\n            // fill polygons\r\n            if(this.polygons.hasOwnProperty(cur_k)){\r\n                //if(this.polygons.hasOwnProperty(\"length\")){\r\n                    for(let j = 0; j < this.polygons[cur_k].length; j ++){\r\n                        if(this.polygons[cur_k][j].fillFlag){\r\n                            let pts = []\r\n                            for(let p = 0; p < this.polygons[cur_k][j].length; p ++){\r\n                                let id1 = this.polygons[cur_k][j][p]\r\n                                let id2 = this.polygons[cur_k][j][(p + 1) % this.polygons[cur_k][j].length]\r\n                                let adjList = this.SPG[cur_k].adjList\r\n                                for(let pp = 0; pp < adjList[id1].length; pp ++){\r\n                                    let e = adjList[id1][pp]\r\n                                    if(e.w == id2){\r\n                                        let edge_path = this.catInitEdges[cur_k][e.label].edges\r\n                                        let tmp_pts = []\r\n                                        for(let ppp = 0; ppp < edge_path.length; ppp ++){\r\n                                            let u = edge_path[ppp].v\r\n                                            let v = edge_path[ppp].w\r\n                                            tmp_pts.push([this.tanGraphPoints[u].x, this.tanGraphPoints[u].y])\r\n                                            tmp_pts.push([this.tanGraphPoints[v].x, this.tanGraphPoints[v].y])\r\n                                        }\r\n                                        if(e.flag){\r\n                                            for(let tid = tmp_pts.length - 1; tid >= 0; tid --){\r\n                                                pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                            }\r\n                                        }\r\n                                        else{\r\n                                            for(let tid = 0; tid < tmp_pts.length; tid ++){\r\n                                                pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                            }\r\n                                        }\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            console.log(\"fill\")\r\n                            //for(let id = 0; id < pts.length; id ++){\r\n                            //    drawCircle(pts[id][0], pts[id][1], 5, 'red' , 2)\r\n                            //}\r\n\r\n                            this.drawAreas(cur_k, lineFunction(pts))\r\n                        }\r\n                    }\r\n                //}\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={900} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default KelpFusion","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport * as d3 from \"d3\"\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport {Button, Switch} from 'antd';\r\nimport {calDistance, PointToSegDist} from \"./util\"\r\nimport * as A from '@svgdotjs/svg.js'\r\nimport * as B from '@svgdotjs/svg.topoly.js'\r\nimport BSpline from \"./BSpline\";\r\nconst { pathDataToPolys } = require('svg-path-to-polygons');\r\n\r\n\r\nvar IsoInsideTest = require('point-in-polygon');\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n// var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n\r\nclass CalOverLap extends Component{\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        //this.getPath()\r\n        this.getSVG()\r\n\r\n    }\r\n\r\n\r\n    getSVG(){\r\n\r\n        let filename=\"Citywide.svg\"\r\n\r\n        fetch('/data/Evaluation/bubbleset/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'image/svg+xml'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.text())\r\n            .then(data=>{\r\n                //console.log(data)\r\n                console.log(data)\r\n\r\n                let doc = new DOMParser();\r\n                let xml = doc.parseFromString(data,\"image/svg+xml\")\r\n                let gs = xml.getElementsByTagName(\"g\")\r\n                console.log(\"select g res:\")\r\n                console.log(gs)\r\n                var paths = []\r\n                for(let i = 0; i < gs.length; i ++){\r\n                    let stylestr = gs[i].attributes[0].nodeValue.toString()\r\n                    let cmpstr = \"fill: none\"\r\n                    if(stylestr.match(cmpstr)==null){\r\n                      paths.push(gs[i].getElementsByTagName(\"path\"))\r\n                    }\r\n                }\r\n                //var paths = xml.getElementsByTagName(\"path\");\r\n\r\n                console.log(paths)\r\n                //console.log(xml)\r\n                //console.log(paths)\r\n\r\n                //console.log(paths)\r\n\r\n                let cat_Polygon = []\r\n                let cat_Area = []\r\n                let cat_Overlap_Area = []\r\n\r\n                let minX = Number.MAX_VALUE\r\n                let minY = Number.MAX_VALUE\r\n                let maxX = Number.MIN_VALUE\r\n                let maxY = Number.MIN_VALUE\r\n\r\n                for(let i = 0; i < paths.length; i ++){\r\n                    //console.log(paths[i])\r\n                    console.time(\"to polygon\")\r\n                    let path_data = paths[i][0].attributes.d.nodeValue\r\n                    let canvas = A.SVG().addTo('body')\r\n                    let p = canvas.path(path_data)\r\n                    let points = p.toPoly('5px')._array\r\n                    cat_Polygon.push(points)\r\n                    cat_Area.push(0)\r\n                    cat_Overlap_Area.push(0)\r\n                    for(let j = 0; j < points.length; j ++){\r\n                        let x = points[j][0]\r\n                        let y = points[j][1]\r\n                        minX = Math.min(minX, x)\r\n                        minY = Math.min(minY, y)\r\n                        maxX = Math.max(maxX, x)\r\n                        maxY = Math.max(maxY, y)\r\n                    }\r\n                    //console.log(points)\r\n                    d3.select(\"#mainsvg\").append(\"path\")\r\n                        .attr(\"d\",path_data)\r\n                        .attr(\"fill\",colors[i])\r\n                        .style('opacity', 0.5)\r\n                    //for(let j = 0; j < points.length; j ++){\r\n                    //    let x = points[j][0]\r\n                    //    let y = points[j][1]\r\n                    //    d3.select(\"#mainsvg\").append('circle')\r\n                    //        .attr(\"cx\",x)\r\n                    //        .attr(\"cy\",y)\r\n                    //        .attr(\"r\",2)\r\n                    //        .attr(\"fill\",\"red\")\r\n                    //}\r\n                    console.timeEnd(\"to polygon\")\r\n                }\r\n\r\n                d3.select(\"#mainsvg\")\r\n                    .attr(\"viewBox\",minX+\" \"+minY+\" \"+(maxX-minX)+\" \"+(maxY-minY))\r\n\r\n\r\n                minX -= 5\r\n                minY -= 5\r\n                maxX += 5\r\n                maxY += 5\r\n\r\n                for(let x = minX; x <= maxX; x ++){\r\n                    for(let y= minY; y <= maxY; y ++){\r\n                        let overlapID = []\r\n                        for(let i = 0; i < cat_Polygon.length; i ++){\r\n                            if(IsoInsideTest([x, y], cat_Polygon[i])){\r\n                                overlapID.push(i)\r\n                                cat_Area[i] ++\r\n                            }\r\n                        }\r\n                        if(overlapID.length > 1){\r\n                            d3.select('#mainsvg').append(\"circle\")\r\n                                .attr(\"cx\",x)\r\n                                .attr(\"cy\",y)\r\n                                .attr(\"r\",1)\r\n                                .attr(\"fill\",\"red\")\r\n                            for(let i = 0; i < overlapID.length; i ++){\r\n                                cat_Overlap_Area[i] ++\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let Sum_Area = 0\r\n                let Overlap_Area = 0\r\n\r\n                for(let i = 0; i < cat_Area.length; i ++){\r\n                    Sum_Area += cat_Area[i]\r\n                    Overlap_Area += cat_Overlap_Area[i]\r\n                }\r\n\r\n                console.log(filename)\r\n                console.log(\"OverLap Area: \" + Overlap_Area)\r\n                console.log(\"Sum Area: \" + Sum_Area)\r\n                console.log(\"Result: \" + Overlap_Area / Sum_Area)\r\n\r\n            })\r\n\r\n    }\r\n\r\n    getPath(){\r\n\r\n        //for(let f = 1; f <= 10; f ++){\r\n            //let filename = \"ex\" + f.toString() + \".txt\"\r\n            //console.log(filename)\r\n            let filename = \"Citywide.txt\"\r\n            fetch('/data/Evaluation/'+filename,{\r\n                method:'GET',\r\n                headers:{\r\n                    'Content-Type':'application/json;charset=UTF-8'\r\n                },\r\n                mode:'cors',\r\n                cache:'default'\r\n            })\r\n                .then(res=>res.json())\r\n                .then(data=>{\r\n                    //console.log(data)\r\n                    var paths = data\r\n\r\n                    let cat_Polygon = {}\r\n                    let cat_Area = {}\r\n                    let cat_Overlap_Area = {}\r\n                    let selectIdx = {}\r\n\r\n                    let minX = Number.MAX_VALUE\r\n                    let minY = Number.MAX_VALUE\r\n                    let maxX = Number.MIN_VALUE\r\n                    let maxY = Number.MIN_VALUE\r\n\r\n                    //console.log(paths)\r\n                    console.time(\"cal\")\r\n                    for(let k in paths){\r\n\r\n                        let draw_data = \"\"\r\n\r\n                        cat_Polygon[k] = []\r\n                        cat_Area[k] = 0\r\n                        cat_Overlap_Area[k] = 0\r\n\r\n                        let sID = 0\r\n                        let maxPath = -1\r\n\r\n                        console.time(\"to polygon\")\r\n                        for(let i = 0; i < paths[k].length; i ++){\r\n                            let path_data = paths[k][i]\r\n                            draw_data += path_data\r\n                            let canvas = A.SVG().addTo('body')\r\n                            let p = canvas.path(path_data)\r\n                            let points = p.toPoly('5px')._array\r\n                            cat_Polygon[k].push(points)\r\n                            if(points.length > maxPath){\r\n                                maxPath = points.length\r\n                                sID = i\r\n                            }\r\n                            for(let j = 0; j < points.length; j ++){\r\n                                let x = points[j][0]\r\n                                let y = points[j][1]\r\n                                minX = Math.min(minX, x)\r\n                                minY = Math.min(minY, y)\r\n                                maxX = Math.max(maxX, x)\r\n                                maxY = Math.max(maxY, y)\r\n                            }\r\n                        }\r\n                        console.timeEnd(\"to polygon\")\r\n\r\n                        selectIdx[k] = sID\r\n\r\n                        d3.select(\"#mainsvg\").append(\"path\")\r\n                            .attr(\"d\",draw_data)\r\n                            .style(\"fill\",colors[parseInt(k)])\r\n                            .style('opacity', 0.5)\r\n\r\n                    }\r\n\r\n                    d3.select(\"#mainsvg\")\r\n                        .attr(\"viewBox\",minX+\" \"+minY+\" \"+(maxX-minX)+\" \"+(maxY-minY))\r\n\r\n                    minX -= 5\r\n                    minY -= 5\r\n                    maxX += 5\r\n                    maxY += 5\r\n\r\n                    //console.log(cat_Polygon)\r\n\r\n                    for(let x = minX; x <= maxX; x ++){\r\n                        for(let y= minY; y <= maxY; y ++){\r\n\r\n                            let overlapID = []\r\n\r\n                            for(let k in cat_Polygon){\r\n\r\n                                let sID = selectIdx[k]\r\n\r\n                                if(!IsoInsideTest([x, y], cat_Polygon[k][sID])){\r\n                                    continue\r\n                                }\r\n\r\n                                let flag2 = true\r\n                                for(let i = 0; i < cat_Polygon[k].length; i ++){\r\n                                    if(i == sID){\r\n                                        continue\r\n                                    }\r\n                                    if(IsoInsideTest([x, y], cat_Polygon[k][i])){\r\n                                        flag2 = false\r\n                                        break\r\n                                    }\r\n                                }\r\n\r\n                                if(flag2){\r\n                                    cat_Area[k] ++\r\n                                    overlapID.push(k)\r\n                                }\r\n\r\n                            }\r\n\r\n                            if(overlapID.length > 1){\r\n                                d3.select('#mainsvg').append(\"circle\")\r\n                                    .attr(\"cx\",x)\r\n                                    .attr(\"cy\",y)\r\n                                    .attr(\"r\",1)\r\n                                    .attr(\"fill\",\"red\")\r\n                                for(let i = 0; i < overlapID.length; i ++){\r\n                                    cat_Overlap_Area[i] ++\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n                    let Sum_Area = 0\r\n                    let Overlap_Area = 0\r\n\r\n                    for(let k in cat_Area){\r\n                        Sum_Area += cat_Area[k]\r\n                        Overlap_Area += cat_Overlap_Area[k]\r\n                    }\r\n\r\n                    console.log(filename)\r\n                    console.log(\"OverLap Area: \" + Overlap_Area)\r\n                    console.log(\"Sum Area: \" + Sum_Area)\r\n                    console.log(\"Result: \" + Overlap_Area / Sum_Area)\r\n\r\n                    console.timeEnd(\"cal\")\r\n\r\n\r\n\r\n                })\r\n        //}\r\n        //let filename=\"life_fertility.txt\"\r\n\r\n\r\n    }\r\n\r\n\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={1200} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default CalOverLap","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport BubbleDemo from \"./BubbleDemo\"\r\nimport KelpDiagram from\"./KelpDiagram\"\r\nimport KelpFusion from \"./KelpFusion\";\r\nimport CalOverLap from \"./CalOverLap\";\r\nimport CSVData from \"./CSVData\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n\r\n      <BubbleDemo></BubbleDemo>\r\n      {/*<KelpDiagram></KelpDiagram>*/}\r\n      {/*<KelpFusion></KelpFusion>*/}\r\n      {/*<CalOverLap></CalOverLap>*/}\r\n      {/*<CSVData></CSVData>*/}\r\n\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}